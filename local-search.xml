<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3.存储管理</title>
    <link href="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/"/>
    <url>/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/</url>
    
    <content type="html"><![CDATA[<h2 id="Lecture3-存储管理"><a href="#Lecture3-存储管理" class="headerlink" title="Lecture3-存储管理"></a>Lecture3-存储管理</h2><ol><li>存储管理是操作系统的重要组成部分，负责管理计算机系统的重要资源——内存储器。</li><li>内存空间一般分为两部分<ol><li>系统区：存放操作系统内核程序和数据结构等。</li><li>用户区：存放应用程序和数据。</li></ol></li><li>存储管理包括以下功能：<ol><li>存储分配：位进程分配内存空间以便运行，完成内存区的分配和去配工作。</li><li>地址映射：内存被抽象为一维或二维地址空间；逻辑空间到物理空间映射。</li><li>存储保护：系统隔离分配给进程的内存区，防止地址越界或操作越权。</li><li>存储共享：系统允许多个进程共享内存区。</li><li>存储扩充：形成虚拟存储器。</li></ol></li></ol><h1 id="1-存储管理的基础"><a href="#1-存储管理的基础" class="headerlink" title="1. 存储管理的基础"></a>1. 存储管理的基础</h1><h2 id="1-1-逻辑地址"><a href="#1-1-逻辑地址" class="headerlink" title="1.1. 逻辑地址"></a>1.1. 逻辑地址</h2><ol><li>逻辑地址：又称相对地址，即用户编程所使用的地址空间</li><li>逻辑地址从零开始编号，有两种形式：<ol><li>一维逻辑地址(地址)</li><li>二维逻辑地址(段号:段内地址)<br>。</li></ol></li></ol><h2 id="1-2-物理地址：从处理器角度看到的物理内存单元。"><a href="#1-2-物理地址：从处理器角度看到的物理内存单元。" class="headerlink" title="1.2. 物理地址：从处理器角度看到的物理内存单元。"></a>1.2. 物理地址：从处理器角度看到的物理内存单元。</h2><ol><li>物理地址：又称绝对地址，即程序执行所使用的地址空间</li><li>处理器执行指令时按照物理地址进行</li></ol><h2 id="1-3-段式程序设计"><a href="#1-3-段式程序设计" class="headerlink" title="1.3. 段式程序设计"></a>1.3. 段式程序设计</h2><ol><li>把一个程序设计成多个段：代码段、数据段、堆栈段等等</li><li>用户可以自己应用<strong>段覆盖技术</strong>扩充内存空间使用量，这一技术是程序设计技术，不是OS存储管理的功能：只是用一些段构成一个比较小的程序，然后动态来调整。</li><li>结合虚存完成内存部分的扩充</li></ol><h2 id="1-4-主存储器的复用"><a href="#1-4-主存储器的复用" class="headerlink" title="1.4. 主存储器的复用"></a>1.4. 主存储器的复用</h2><ol><li>多道程序设计需要复用主存</li><li>按照分区复用：<ol><li>主存划分为多个固定&#x2F;可变尺寸的分区</li><li>一个程序&#x2F;程序段占用一个分区</li></ol></li><li>按照页架复用：<ol><li>主存划分成多个固定大小的页架</li><li>一个程序&#x2F;程序段占用多个页架</li></ol></li></ol><h2 id="1-5-存储管理的基本模式"><a href="#1-5-存储管理的基本模式" class="headerlink" title="1.5. 存储管理的基本模式"></a>1.5. 存储管理的基本模式</h2><ol><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定分区或可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li><li>注意是否可以虚拟化</li></ol><h2 id="1-6-存储管理模式示意图"><a href="#1-6-存储管理模式示意图" class="headerlink" title="1.6. 存储管理模式示意图"></a>1.6. 存储管理模式示意图</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/1.png"></p><ol><li>应用级程序员直接面对的是<strong>逻辑地址</strong>，而最后运行需要使用的是<strong>物理地址：从处理器角度看到的物理内存单元。</strong>。</li><li>一般目前常用的是<strong>动态重定位</strong>，将逻辑地址转换为对应的物理地址。</li><li>分页：形成页框加载程序，页框和页框之间可以是不连续的。</li><li>分段：每一个段有相应分区，使用段表完成逻辑段向物理段的映射</li><li>段页式：在分段基础上，还实现了页框部分。</li></ol><h1 id="2-存储管理的功能"><a href="#2-存储管理的功能" class="headerlink" title="2. 存储管理的功能"></a>2. 存储管理的功能</h1><h2 id="2-1-地址转换"><a href="#2-1-地址转换" class="headerlink" title="2.1. 地址转换"></a>2.1. 地址转换</h2><ol><li><strong>地址转换</strong>：又称重定位，即把逻辑地址转换成绝对地址<ol><li><strong>静态重定位</strong>：在<strong>程序装入内存</strong>时进行地址转换：由装入程序执行，早期小型OS使用，基于地址固定值进行偏移。</li><li><strong>动态重地位(主流)<strong>：在</strong>CPU执行程序时进行地址转换</strong>：从效率出发，依赖硬件地址转换机构，运行时正确的将其逻辑地址转换为物理地址。</li></ol></li><li>解释执行指令的时候才进行地址的转换，必须要借助硬件电路完成，而不能用软件完成(效率考量)</li></ol><h2 id="2-2-存储保护"><a href="#2-2-存储保护" class="headerlink" title="2.2. 存储保护"></a>2.2. 存储保护</h2><ol><li>为<strong>避免</strong>主存中的多个进程<strong>相互干扰</strong>，必须<strong>对主存中的程序和数据进行保护</strong><ol><li>私有主存区中的信息：可读可写</li><li>公共区中的共享信息：根据授权</li><li>非本进程信息：不可读写</li></ol></li><li>这一功能需要软硬件协同完成：CPU检查是否允许访问，不允许则<strong>产生地址保护异常</strong>，由OS进行相应处理<ol><li>地址越界保护依赖于硬件设施、常用的有界地址和存储键。</li><li>进程在访问分配给自己的内存区时，要对访问权限进行检查</li></ol></li></ol><h2 id="2-3-主存储器空间的分配与去配"><a href="#2-3-主存储器空间的分配与去配" class="headerlink" title="2.3. 主存储器空间的分配与去配"></a>2.3. 主存储器空间的分配与去配</h2><ol><li><strong>分配</strong>：进程装入主存时，存储管理软件进行具体的<strong>主存分配</strong>操作，并设置<strong>一个表格</strong>记录主存空间的分配情况</li><li><strong>去配</strong>：当某个进程撤离或主动归还主存资源时，存储管理软件要收回它所占用的全部或者部分存储空间，调整主存分配表信息</li></ol><h2 id="2-4-主存储器空间的共享"><a href="#2-4-主存储器空间的共享" class="headerlink" title="2.4. 主存储器空间的共享"></a>2.4. 主存储器空间的共享</h2><ol><li><strong>多个进程共享主存储器资源</strong>：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li><li><strong>多个进程共享主存储器的某些区域</strong>：若干个协作进程有共同的主存程序块或者主存数据块</li></ol><h2 id="2-5-主存储器空间的扩充"><a href="#2-5-主存储器空间的扩充" class="headerlink" title="2.5. 主存储器空间的扩充"></a>2.5. 主存储器空间的扩充</h2><ol><li><strong>存储扩充</strong>：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存：扩大多道程序设计的道数<ol><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容，对单个进程不使用对换技术完成，特点是自动化、透明</li></ol></li><li>这一工作需要软硬件协作完成<ol><li>对换进程决定对换，硬件结构完成调入</li><li>CPU处理到不在主存的地址，发出<strong>虚拟地址异常</strong>，OS将其调入，重执指令</li></ol></li><li>进程的内存为$4MB$，一个页框$4KB$，有$1024$个页框，页框表一共$16$个页框，页的压缩比是$\frac{1024}{16} &#x3D; 64$。</li></ol><h1 id="3-连续存储管理"><a href="#3-连续存储管理" class="headerlink" title="3. 连续存储管理"></a>3. 连续存储管理</h1><h2 id="3-1-单连续分区存储管理"><a href="#3-1-单连续分区存储管理" class="headerlink" title="3.1. 单连续分区存储管理"></a>3.1. 单连续分区存储管理</h2><ol><li>每个进程占用一个物理上完全连续的存储空间(区域)</li><li>单连续分区存储管理细分:<ol><li>单用户连续存储管理</li><li>固定分区存储管理</li><li>可变分区存储管理</li></ol></li><li>分区方式不能实现虚拟存储。</li></ol><h3 id="3-1-1-单用户连续分区存储管理"><a href="#3-1-1-单用户连续分区存储管理" class="headerlink" title="3.1.1. 单用户连续分区存储管理"></a>3.1.1. 单用户连续分区存储管理</h3><ol><li>适用于单用户单任务操作系统，如DOS</li><li>主存区域(内存空间)划分为<strong>系统区</strong>与<strong>用户区</strong><ol><li>系统区用于存放操作系统内核程序和数据结构等</li><li>用户区用于存放应用程序和数据</li></ol></li><li>设置一个<strong>栅栏寄存器</strong>界分两个区域，硬件用它在执行时进行存储保护</li><li>一般采用<strong>静态重定位</strong>进行地址转换</li><li>硬件实现代价低</li><li>单用户连续分区存储管理示意<ol><li>静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址全部转换成绝对地址</li><li>界限地址:放置软件访问到操作系统的部分</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/6.png"></p><h3 id="3-1-2-固定分区存储管理"><a href="#3-1-2-固定分区存储管理" class="headerlink" title="3.1.2. 固定分区存储管理"></a>3.1.2. 固定分区存储管理</h3><ol><li>固定分区存储管理又称静态分区模式</li></ol><h4 id="3-1-2-1-固定分区方式的基本思想"><a href="#3-1-2-1-固定分区方式的基本思想" class="headerlink" title="3.1.2.1. 固定分区方式的基本思想"></a>3.1.2.1. 固定分区方式的基本思想</h4><ol><li>内存空间被划分为数目固定不变的分区，各分区大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们都可以并发执行。</li><li>可用静态&#x2F;动态重定位、硬件实现代价低、被早期OS采用<br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/7.png"></li></ol><h4 id="3-1-2-2-固定分区方式的主存分配"><a href="#3-1-2-2-固定分区方式的主存分配" class="headerlink" title="3.1.2.2. 固定分区方式的主存分配"></a>3.1.2.2. 固定分区方式的主存分配</h4><ol><li>主存分配表：包含内容：起始地址、长度、占用标志</li><li>内存分配方法很简单，其任务有何时吧内存空间划分成分区：由系统管理员和操作系统初始化模块协同完成。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/8.png"></p><ol start="3"><li>作业进入分区的排队策略：<ol><li>每个分区有自己的作业等待队列，作业等待能装下自身的最小分区。</li><li>所有等待处理作业排成等待队列，每当有空闲，找到队列中能进入的最大的一个。</li></ol></li></ol><h4 id="3-1-2-3-固定分区方式的地址转换"><a href="#3-1-2-3-固定分区方式的地址转换" class="headerlink" title="3.1.2.3. 固定分区方式的地址转换"></a>3.1.2.3. 固定分区方式的地址转换</h4><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/9.png"></p><h4 id="3-1-2-4-固定分区存储管理的缺点"><a href="#3-1-2-4-固定分区存储管理的缺点" class="headerlink" title="3.1.2.4. 固定分区存储管理的缺点"></a>3.1.2.4. 固定分区存储管理的缺点</h4><ol><li>由于预先规定了分区的大小，使得大作业无法装入，而不得不采用覆盖技术，带来负担。</li><li>内存空间利用率不高，作业很少填满分区：固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存<strong>内零头</strong>，有浪费，内存内零头是因为在分区内部有零头。</li><li>如果作业在运行中要求动态扩展内存空间是困难的。</li><li>分区数目是操作系统初启动时确定的，会限制多道运行程序的道数。</li></ol><h2 id="3-2-可变分区存储管理"><a href="#3-2-可变分区存储管理" class="headerlink" title="3.2. 可变分区存储管理"></a>3.2. 可变分区存储管理</h2><ol><li>可变分区存储管理又称动态分区模式，按照作业大小划分分区，但划分的时间、大小和位置都是动态的。</li><li>创建一个进程时，根据进程所需主存量查看主存中是否有足够的连续空闲空间<ol><li>若有，则按需要量分割一个分区</li><li>若无，则令该进程等待主存资源</li></ol></li><li>由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的</li></ol><h3 id="3-2-1-可变分区方式的内存分配示例"><a href="#3-2-1-可变分区方式的内存分配示例" class="headerlink" title="3.2.1. 可变分区方式的内存分配示例"></a>3.2.1. 可变分区方式的内存分配示例</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/10.png"></p><h3 id="3-2-2-可变分区方式的主存分配表"><a href="#3-2-2-可变分区方式的主存分配表" class="headerlink" title="3.2.2. 可变分区方式的主存分配表"></a>3.2.2. 可变分区方式的主存分配表</h3><ol><li>管理的数据结构：已分配区表与未分配区表，采用链表实现</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/11.png"></p><ol start="2"><li>找一个最大的空闲的位置进行分配</li></ol><h3 id="3-2-3-可变分区方式的内存回收"><a href="#3-2-3-可变分区方式的内存回收" class="headerlink" title="3.2.3. 可变分区方式的内存回收"></a>3.2.3. 可变分区方式的内存回收</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/12.png"></p><ol><li>可变分区方式的内存回收会导致内存空间的转换</li><li>作业X撤离后有且仅有如上4种情况。</li></ol><h3 id="3-2-4-可变分区方式的内存分配"><a href="#3-2-4-可变分区方式的内存分配" class="headerlink" title="3.2.4. 可变分区方式的内存分配"></a>3.2.4. 可变分区方式的内存分配</h3><ol><li>最先适应分配算法：<ol><li>最先适应就是从上向下查找，找到第一块区域放进去，将剩下的区域分割后仍作为空闲区。</li><li>有利于大作业装入，但也使得内存低地址和搞地质两端的分区利用不均衡，回收分区麻烦。</li></ol></li><li>邻近适应分配算法：<ol><li>从上次查找结束的地方开始执行最先适应分配算法</li><li>缩短平均查找时间，且存储空间利用率更均衡，不会使得小空闲区集中在内存一侧</li></ol></li><li>最优适应分配算法：<ol><li>每次都是分配最接近需要使用大小的部分，会生成很多很小的内存内零头。</li><li>通常会将空闲区按照长度递增顺序排列，等同于最先适应分配算法，查找时间最长</li></ol></li><li>最坏适应分配算法：<ol><li>每次都是挑选最大的一块区域进行分配</li><li>有利于中小型作业。</li><li>可把空闲区按长度递减顺序排列，等同于最先适应分配算法。</li></ol></li><li>快速适应分配算法：课本补充<ol><li>为经常用到的长度的空闲区设立单独的空闲区链表，查找非常快速</li><li>归还内存空间时和邻近空闲区的合并复杂且耗时。</li></ol></li><li>最常用的是最先适应分配算法，其次是邻近适应分配算法和最优适应分配算法</li></ol><h2 id="3-3-地址转换与存储保护"><a href="#3-3-地址转换与存储保护" class="headerlink" title="3.3. 地址转换与存储保护"></a>3.3. 地址转换与存储保护</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/34.png"></p><ol><li>硬件实现机制与动态重定位</li><li>进程的程序和数据的地址由硬件完成<ol><li>基址寄存器：分配进程的起始地址</li><li>限长寄存器：进程占用的连续存储空间的长度</li></ol></li></ol><h2 id="3-4-分区方式的内存零头"><a href="#3-4-分区方式的内存零头" class="headerlink" title="3.4. 分区方式的内存零头"></a>3.4. 分区方式的内存零头</h2><ol><li>固定分区方式会产生<strong>内存内零头</strong></li><li>可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为<strong>内存外零头</strong>，内存外零头是指分区内部是没有零头的，而是在外面的零头。</li><li><strong>最优适配算法最容易产生外零头</strong></li><li>任何适配算法都<strong>不能避免</strong>产生外零头</li></ol><h2 id="3-5-内存不足的存储技术"><a href="#3-5-内存不足的存储技术" class="headerlink" title="3.5. 内存不足的存储技术"></a>3.5. 内存不足的存储技术</h2><h3 id="3-5-1-移动技术-程序浮动技术"><a href="#3-5-1-移动技术-程序浮动技术" class="headerlink" title="3.5.1. 移动技术(程序浮动技术)"></a>3.5.1. 移动技术(程序浮动技术)</h3><ol><li>碎片：内存中的小空闲区，移动分区来解决内存外零头问题。</li><li>当未分配区表中找不到足够大的空闲区来装入新进程时，我们使用移动技术来完成内存紧凑，实现方法：<ol><li>全部移动到一侧</li><li>移动直到有足够大的空闲区</li></ol></li><li>需要动态重定位支撑:静态重定位无法解决内存外零头</li><li>问题：移动技术有极大的系统开销，而且并不是任何时间下都可以进行的，比如通道或DMA等按照绝对物理地址交换信息时。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/13.png"></p><ol start="5"><li><p>移动技术的工作流程<br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/14.png"></p></li><li><p>注意如果剩余空间地方不足，那么是不会移动分区的</p></li></ol><h3 id="3-5-2-对换技术"><a href="#3-5-2-对换技术" class="headerlink" title="3.5.2. 对换技术"></a>3.5.2. 对换技术</h3><ol><li>对换技术广泛应用于分时系统的调度，用来解决内存容量不足的问题，也可以应用于批处理系统，以平衡系统负载。</li><li>如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用；同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为<strong>对换</strong>。</li><li>被对换出去的进程的状态会调整为就绪态，并且通知存储管理程序，一旦内存可用，立即将该进程对换回内存。</li><li>对换技术关键点<ol><li>被对换进程：通常系统选择时间片耗尽或优先级较低的进程对换出去。</li><li>对换的进程信息：将数据区和堆栈通过文件系统转换为特殊文件保存。</li><li>被对换的时机：<ol><li>批处理系统中：进程需要扩充内存空间但不能被满足时</li><li>分时系统：<ol><li>时间片结束时</li><li>执行I&#x2F;O操作时</li></ol></li></ol></li></ol></li><li>对换需要访问磁盘，是I&#x2F;O集中型操作，但是操作系统可以让计算型任务与对换并行，不会造成系统效率显著下降。</li><li>详见P205</li></ol><h3 id="3-5-3-覆盖技术"><a href="#3-5-3-覆盖技术" class="headerlink" title="3.5.3. 覆盖技术"></a>3.5.3. 覆盖技术</h3><ol><li>移动和对换技术解决因多个程序存在而导致内存区不足问题。</li><li>但是如果程序长度超过物理内存的总和，或者超出固定分区大小，则会出现内存永久性短缺，大程序无法运行，解决方案是覆盖技术。</li><li>覆盖是指程序执行过程中程序的不同模块在内存中相互替代，以达到小内存执行大程序的目的。</li><li>基本的实现技术是把用户空间分成固定区和一个或多个覆盖区，把控制或不可覆盖的部分放到固定区，其余按照调用结构以及先后关系分段并存放在磁盘上，运行时一次调入覆盖区。</li><li>不足是将存储管理工作转给程序员，他们必须根据可用物理内存空间来设计和编写程序。</li></ol><h1 id="4-虚拟存储器的概念"><a href="#4-虚拟存储器的概念" class="headerlink" title="4. 虚拟存储器的概念"></a>4. 虚拟存储器的概念</h1><ol><li>之前所介绍的存储管理，我们称为实存管理，必须为进程分配足够内存空间，装入其全部信息，否则无法运行。</li></ol><h2 id="4-1-虚拟存储器思想的提出"><a href="#4-1-虚拟存储器思想的提出" class="headerlink" title="4.1. 虚拟存储器思想的提出"></a>4.1. 虚拟存储器思想的提出</h2><ol><li>主存容量限制带来诸多不便<ol><li>用户编写程序必须考虑主存容量限制</li><li>多道程序设计的道数受到限制</li></ol></li><li>用户编程行为分析<ol><li>全面考虑各种情况，执行时有互斥性</li><li>顺序性和循环性等空间局部性行为</li><li>某一阶段执行的时间局部性行为</li></ol></li><li>因此可以考虑部分调入进程内容</li></ol><h3 id="4-1-1-分区存储的限制"><a href="#4-1-1-分区存储的限制" class="headerlink" title="4.1.1. 分区存储的限制"></a>4.1.1. 分区存储的限制</h3><ol><li>每个进程(每个连续逻辑地址空间)必须获得物理地址上的完全连续，突破：分区，分段</li><li>必须一次性满足满足每个进程运行时的全部内存需求，突破：虚拟存储，部分装入对换</li><li>注：一旦发生缺页，则会从运行态调整到阻塞态，可能会导致部分进程的速度被拖慢，但是整体效率会提高</li></ol><h3 id="4-1-2-程序运行的局部性原理"><a href="#4-1-2-程序运行的局部性原理" class="headerlink" title="4.1.2. 程序运行的局部性原理"></a>4.1.2. 程序运行的局部性原理</h3><ol><li>在一个周期内，这个进程在运行时会集中访问一些存储区：某存储单元被访问，改单元机器相邻存储单元很可能会被访问(空间局部性)，或者最近访问过的存储单元很快又能被访问(时间局部性)。</li><li>根据程序运行的局部性原理，会保证程序的访问效率比较高，缺页率相对低，以时间换取空间</li></ol><h2 id="4-2-虚拟存储器的基本思想"><a href="#4-2-虚拟存储器的基本思想" class="headerlink" title="4.2. 虚拟存储器的基本思想"></a>4.2. 虚拟存储器的基本思想</h2><ol><li>部分装入：存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为<strong>随用随调入</strong></li><li>按需调出：如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息<strong>调出</strong>到辅存上去</li></ol><h2 id="4-3-虚拟存储器的实现思路"><a href="#4-3-虚拟存储器的实现思路" class="headerlink" title="4.3. 虚拟存储器的实现思路"></a>4.3. 虚拟存储器的实现思路</h2><ol><li>需要建立与自动管理两个地址空间<ol><li>(辅存)<strong>虚拟地址</strong>空间：容纳进程装入</li><li>(主存)<strong>实际地址</strong>空间：承载进程执行</li></ol></li><li>对于用户，计算机系统具有一个容量大得多的主存空间，即<strong>虚拟存储器</strong></li></ol><h2 id="4-4-虚拟存储器"><a href="#4-4-虚拟存储器" class="headerlink" title="4.4. 虚拟存储器"></a>4.4. 虚拟存储器</h2><ol><li>在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理内存容量大得多的、可寻址的内存储器。</li><li>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计<ol><li>逻辑地址：进程角度看到的逻辑内存单元。</li><li>物理地址：从处理器角度看到的物理内存单元。</li></ol></li><li>对换技术以进程为单位，虚存管理以页或段为单位。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/2.png"></p><h1 id="5-存储管理的硬件支撑"><a href="#5-存储管理的硬件支撑" class="headerlink" title="5. 存储管理的硬件支撑"></a>5. 存储管理的硬件支撑</h1><h2 id="5-1-存储器的组织层次"><a href="#5-1-存储器的组织层次" class="headerlink" title="5.1. 存储器的组织层次"></a>5.1. 存储器的组织层次</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/3.png"></p><ol><li>越处于顶端，访问速度越快，容量越小，单位字节价格会越高。我们根据实际情况，选择使用什么样子的存储器。<ol><li><strong>寄存器、缓存和内存</strong>属于操作系统存储管理的范畴，掉电后信息丢失。</li><li><strong>磁盘和磁带</strong>属于稳健管理和设备管理的管辖对象，信息永久保存。</li></ol></li><li>可执行程序必须被保存在<strong>内存</strong>中，与设备交换的信息也依托于<strong>内存地址空间</strong>。</li><li>由于程序处理数据时存在<strong>顺序性和局部性</strong>，故执行时仅需调入当前运行使用的一部分，其他部分待需要时再逐步调入。</li></ol><h2 id="5-2-存储管理涉及的存储对象"><a href="#5-2-存储管理涉及的存储对象" class="headerlink" title="5.2. 存储管理涉及的存储对象"></a>5.2. 存储管理涉及的存储对象</h2><ol><li>存储管理是OS管理主存储器的<strong>软件部分</strong></li><li>为获得更好的处理性能，部分主存程序与数据(特别是关键性能数据)被调入Cache，存储管理需要对其进行管理，甚至包括对联想存储器的管理</li><li>为获得更大的虚拟地址空间，存储管理需要对存放在硬盘、固态硬盘、甚至网络硬盘上的虚拟存储器文件进行管理，首选固态硬盘</li></ol><h2 id="5-3-高速缓存存储器-Cache"><a href="#5-3-高速缓存存储器-Cache" class="headerlink" title="5.3. 高速缓存存储器(Cache)"></a>5.3. 高速缓存存储器(Cache)</h2><ol><li>Cache是介于CPU和主存储器间的高速小容量存储器，由<strong>静态存储芯片SRAM</strong>组成，容量较小但比主存DRAM技术更加昂贵而快速，接近于CPU的速度</li><li>CPU往往需要重复读取同样的数据块，Cache的引入与缓存容量的增大，可以大幅提升CPU内部读取数据的命中率，从而提高系统性能</li></ol><h3 id="5-3-1-高速缓存存储器的构成"><a href="#5-3-1-高速缓存存储器的构成" class="headerlink" title="5.3.1. 高速缓存存储器的构成"></a>5.3.1. 高速缓存存储器的构成</h3><ol><li>高速缓冲存储器通常由<strong>高速存储器、联想存储器、地址转换部件、替换逻辑</strong>等组成<ol><li><strong>联想存储器</strong>：根据内容进行寻址的存储器</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache；未命中时从内存读取放入Cache</li><li>替换逻辑部件：在缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li></ol></li><li>MMU：硬件，存储管理单元</li></ol><h3 id="5-3-2-高速缓存存储器的组织"><a href="#5-3-2-高速缓存存储器的组织" class="headerlink" title="5.3.2. 高速缓存存储器的组织"></a>5.3.2. 高速缓存存储器的组织</h3><ol><li>由于CPU芯片面积和成本，Cache很小</li><li>根据成本控制，划分为L1、L2、L3三级</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/4.png"></p><h3 id="5-3-3-高速缓存存储器的分级"><a href="#5-3-3-高速缓存存储器的分级" class="headerlink" title="5.3.3. 高速缓存存储器的分级"></a>5.3.3. 高速缓存存储器的分级</h3><ol><li>L1 Cache：分为数据缓存和指令缓存；内置；其成本最高，对CPU的性能影响最大；通常在32KB-256KB之间</li><li>L2 Cache：分内置和外置两种，后者性能低一些；通常在512KB-8MB之间</li><li>L3 Cache：多为外置，在游戏和服务器领域有效；但对很多应用来说，<strong>总线改善</strong>比<strong>设置L3</strong>更加有利于提升系统性能</li></ol><h3 id="5-3-4-早期奔腾处理器架构"><a href="#5-3-4-早期奔腾处理器架构" class="headerlink" title="5.3.4. 早期奔腾处理器架构"></a>5.3.4. 早期奔腾处理器架构</h3><ol><li>Intel在最初的奔腾处理器中只包含L1 Cache(含Code Cache和Data Cache)</li></ol><h3 id="5-3-5-奔腾4处理器架构"><a href="#5-3-5-奔腾4处理器架构" class="headerlink" title="5.3.5. 奔腾4处理器架构"></a>5.3.5. 奔腾4处理器架构</h3><ol><li>奔腾4的处理器中包含L1 Cache和L2 Cache</li></ol><h3 id="5-3-6-i5处理器架构"><a href="#5-3-6-i5处理器架构" class="headerlink" title="5.3.6. i5处理器架构"></a>5.3.6. i5处理器架构</h3><h3 id="5-3-7-i7处理器架构"><a href="#5-3-7-i7处理器架构" class="headerlink" title="5.3.7. i7处理器架构"></a>5.3.7. i7处理器架构</h3><ol><li>i7处理器中包含L1至L3三级Cache，如果是包含了三级Cache，那么意味着CPU与Cache之间的链接在CPU内部，Core i7处理器方案是将L3 Cache设计为包含在处理中的多个核心Cache</li></ol><h2 id="5-4-地址转换-x2F-存储保护的硬件支撑"><a href="#5-4-地址转换-x2F-存储保护的硬件支撑" class="headerlink" title="5.4. 地址转换&#x2F;存储保护的硬件支撑"></a>5.4. 地址转换&#x2F;存储保护的硬件支撑</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/5.png"></p><ol><li>限长寄存器来检查越界中断</li><li>相加体现了动态重定位</li><li>比较体现了存储保护</li></ol><h2 id="5-5-存储管理与硬件支撑"><a href="#5-5-存储管理与硬件支撑" class="headerlink" title="5.5. 存储管理与硬件支撑"></a>5.5. 存储管理与硬件支撑</h2><ol><li>鉴于程序执行与数据访问的<strong>局部性原理</strong>，存储管理软件使用<strong>Cache</strong>可以大幅度提升程序执行效率</li><li><strong>动态重定位、存储保护</strong>等，若无硬件支撑在效率上是无意义的，即无实现价值</li><li>无<strong>虚拟地址中断</strong>，虚拟存储器无法实现</li><li>无页面替换等硬件支撑机制，虚拟存储器在效率上是无意义的</li></ol><h2 id="5-6-虚拟存储与硬件支撑"><a href="#5-6-虚拟存储与硬件支撑" class="headerlink" title="5.6. 虚拟存储与硬件支撑"></a>5.6. 虚拟存储与硬件支撑</h2><ol><li>操作系统的存储管理依靠底层硬件支撑来完成任务，该硬件是存储管理部件(Memory Managment Unit, MMU)，提供地址转换和存储保护并支持虚存管理和多任务管理。</li><li>MMU由一组集成电路芯片组成，逻辑地址作为输入，物理地址作为输出，直接送达总线，对内存单元进行寻址。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/86.png"></p><ol start="3"><li>主要功能：P217<ol><li>管理硬件页表基址寄存器</li><li>分解逻辑地址</li><li>管理快表</li><li>访问页表</li><li>发出异常</li><li>管理特征位</li></ol></li></ol><h1 id="6-页式存储管理"><a href="#6-页式存储管理" class="headerlink" title="6. 页式存储管理"></a>6. 页式存储管理</h1><h2 id="6-1-页式存储管理的基本原理"><a href="#6-1-页式存储管理的基本原理" class="headerlink" title="6.1. 页式存储管理的基本原理"></a>6.1. 页式存储管理的基本原理</h2><ol><li>页面：金层逻辑地址空间分成大小相等的区，每个区称为页面或页，页号从0开始编号。比如出版一本书，出版受到页大小影响，最后由若干页组成，一般大小为4KB</li><li>页框：又称页帧，把内存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区都是一个页框(物理块)，块号从0开始。</li><li>逻辑地址：分页存储器的逻辑地址由页号 + 页面偏移组成(地址总线32位)<ol><li>页号：32-12 &#x3D; 20位，则包含页$2^{20}$位</li><li>页面偏移：页面大小为4KB，则需要12位</li></ol></li><li>内存页框表：该表长度取决于内存划分的物理块数，表项中给出物理块使用情况，0为空闲，1为占用，有的系统还会添加保护位、脏位等等。</li><li>页表：将页装入到内存中，<strong>页未必连续</strong>，我们需要为每一个页面设立一个重定向寄存器，这个寄存器的集合就是页表。<ol><li>数学角度：$页面号 \rightarrow 页框号$</li><li>系统设置页表基址寄存器，存放当前运行进程的页表起始地址。</li><li>$物理地址 &#x3D; 页框号 * 块长 + 页内偏移$，实际转换时，我们将页内偏移作为低地址，根据页号从页表中查找到页框号并作为高地址即可。</li><li>页表不存储<strong>页号</strong>，只存储页框号和相应标志位</li></ol></li><li>页式存储产生的碎片是内部碎片<ol><li>可以类比固定分区</li><li>比如19KB的程序，加载到页大小为4KB中，会产生1KB的内存内零头。</li></ol></li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/81.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/15.png"></th></tr></thead></table><blockquote><ol><li>页号p</li><li>页内偏移d</li><li>页框号b</li></ol></blockquote><h2 id="6-2-页式存储管理中的地址"><a href="#6-2-页式存储管理中的地址" class="headerlink" title="6.2. 页式存储管理中的地址"></a>6.2. 页式存储管理中的地址</h2><ol><li>页式存储管理的逻辑地址由两部分组成，**页号和单元号(页内偏移)**，逻辑地址形式：</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/16.png"></p><ol start="2"><li>页式存储管理的物理地址也有两部分组成：**页架号(页框号)和单元号(页内偏移)**，物理地址形式：</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/17.png"></p><ol start="3"><li>地址转换可以通过查页表完成</li><li>用户不必关心页的具体存储，系统帮助用户完成从页号&#x2F;页架号映射到物理地址来完成。</li></ol><h2 id="6-3-页式存储管理的地址转换例子"><a href="#6-3-页式存储管理的地址转换例子" class="headerlink" title="6.3. 页式存储管理的地址转换例子"></a>6.3. 页式存储管理的地址转换例子</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/18.png"></p><ol><li>逻辑地址页号，作为偏移量到页表中进行偏移，得到页架号(页框号)。</li><li>对页架号(页框号)进行二进制移位操作(补充12个0)，映射到物理空间中本页的首地址，然后根据offset(单元号)在页内进行偏移，从而获取到绝对地址(物理地址：从处理器角度看到的物理内存单元)中的值。</li></ol><h2 id="6-4-页式存储管理的内存分配-x2F-去配"><a href="#6-4-页式存储管理的内存分配-x2F-去配" class="headerlink" title="6.4. 页式存储管理的内存分配&#x2F;去配"></a>6.4. 页式存储管理的内存分配&#x2F;去配</h2><ol><li>页式存储管理，系统要建立一张内存物理块表，用来记录页框状态，管理物理内存的而分配，所包含的信息包含内存总块数、哪些为空闲块、哪些已经分配以及分配给哪个进程等。</li><li>最简单方法是用一张<strong>位示图</strong>来记录主存分配情况，使用一位来标记一个页框的使用或空闲的状态(压缩的思想)<ol><li>如果够，则去查找一个标记为0的装入</li><li>如果不够，采用一定的策略</li></ol></li><li>建立进程页表维护主存逻辑完整性</li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/19.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/82.png"></th></tr></thead></table><ol><li>分页存储管理页框分配算法：<ol><li>进行内存分配时，先检查空闲块数是否满足用户进行要求<ol><li>若不能则使进程等待。</li><li>若能则查位示图，将位0置为占用标志，从空闲块数中减去本次占用快熟，找到对应的页框号，写入页表。</li></ol></li><li>归还时逆操作。</li></ol></li></ol><h2 id="6-5-页的共享"><a href="#6-5-页的共享" class="headerlink" title="6.5. 页的共享"></a>6.5. 页的共享</h2><ol><li>页式存储管理能够实现多个进程共享程序和数据</li><li><strong>数据共享</strong>：不同进程可以使用<strong>不同</strong>页号共享数据页，但是必须解决共享信息保护问题，常用的是在页表中添加标记位。</li><li><strong>程序共享</strong>：不同进程必须使用<strong>相同</strong>页号共享代码页，共享代码页中的(<strong>JMP &lt;页内地址&gt;</strong>)指令，使用不同页号是做不到，进程一和二都要跳转到页内的位置，程序共享要求页号相同。</li></ol><h2 id="6-6-页式存储管理的地址转换"><a href="#6-6-页式存储管理的地址转换" class="headerlink" title="6.6. 页式存储管理的地址转换"></a>6.6. 页式存储管理的地址转换</h2><blockquote><p>快表TLB，Translation Look_aside Buffer</p></blockquote><h3 id="6-6-1-页式存储管理的地址转换代价"><a href="#6-6-1-页式存储管理的地址转换代价" class="headerlink" title="6.6.1. 页式存储管理的地址转换代价"></a>6.6.1. 页式存储管理的地址转换代价</h3><ol><li><strong>页表放在主存</strong>: 每次地址转换必须访问两次主存<ol><li>按页号读出页表中的相应页架号</li><li>按计算出来的绝对地址进行读写</li></ol></li><li><strong>存在问题</strong>：降低了存取速度</li><li><strong>解决办法</strong>：利用Cache存放部分页表，即快表</li></ol><h3 id="6-6-2-页式存储管理的快表"><a href="#6-6-2-页式存储管理的快表" class="headerlink" title="6.6.2. 页式存储管理的快表"></a>6.6.2. 页式存储管理的快表</h3><ol><li>为提高地址转换速度，设置一个专用的高速存储器，用来存放页表的一部分</li><li><strong>快表</strong>：存放在高速存储器中的页表部分，快表表项：<strong>页号+页架号</strong></li><li>这种高速存储器是<strong>联想存储器(TLB)<strong>，即</strong>按照内容寻址</strong>，而非按照地址访问，根据页号进行寻址。</li></ol><h3 id="6-6-3-基于快表的地址转换流程"><a href="#6-6-3-基于快表的地址转换流程" class="headerlink" title="6.6.3. 基于快表的地址转换流程"></a>6.6.3. 基于快表的地址转换流程</h3><ol><li>按逻辑地址中的页号查快表<ol><li>若该页<strong>已在快表</strong>中，则由页架号和单元号形成绝对地址</li><li>若该页<strong>不在快表</strong>中，则再查主存页表形成绝对地址，同时将该页登记到快表中</li></ol></li><li>当<strong>快表填满</strong>后，又要登记新页时，则需在快表中按一定策略<strong>淘汰</strong>一个旧登记项</li><li>快表可以理解为一个简单的账本</li></ol><h3 id="6-6-4-引入快表后的地址转换代价"><a href="#6-6-4-引入快表后的地址转换代价" class="headerlink" title="6.6.4. 引入快表后的地址转换代价"></a>6.6.4. 引入快表后的地址转换代价</h3><ol><li>采用<strong>快表</strong>后，可以加快地址转换速度</li><li>假定主存访问时间为200毫微秒，快表访问时间为40毫微秒，查快表的命中率是90%，平均地址转换代价为$(200+40)*90%+(200+200+40)*10%&#x3D;260$毫微秒</li><li>比两次访问主存的时间(400毫微秒)下降了<strong>36%</strong></li></ol><h3 id="6-6-5-多道程序环境下的进程表"><a href="#6-6-5-多道程序环境下的进程表" class="headerlink" title="6.6.5. 多道程序环境下的进程表"></a>6.6.5. 多道程序环境下的进程表</h3><ol><li>进程表中登记了每个进程的页表</li><li>进程占有处理器运行时，其<strong>页表起始地址和长度</strong>送入<strong>页表控制寄存器</strong></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/20.png"></p><blockquote><p>页表长度就是页表项的数量</p></blockquote><h3 id="6-6-6-多道程序环境下的地址转换"><a href="#6-6-6-多道程序环境下的地址转换" class="headerlink" title="6.6.6. 多道程序环境下的地址转换"></a>6.6.6. 多道程序环境下的地址转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/21.png"></p><ol><li>页表控制寄存器存储了当前的页表的地址和长度</li><li>页表控制寄存器和进程表是有关联的，所有进程在进程表中都有一项，当这个进程占据CPU时，这个进程就占据页表控制寄存器。</li><li>不使用快表:首先从逻辑地址中，提取出页号，比较页号是否出现越界中断，如果没有越界，则根据页表向下偏移到对应的块号，提取出页表信息和页框号，页框号结合单元号，得到物理地址</li><li>快表:不是从页表中查找，而是优先从快表中查询块号。</li></ol><h2 id="6-7-多级页表"><a href="#6-7-多级页表" class="headerlink" title="6.7. 多级页表"></a>6.7. 多级页表</h2><h3 id="6-7-1-多级页表的概念"><a href="#6-7-1-多级页表的概念" class="headerlink" title="6.7.1. 多级页表的概念"></a>6.7.1. 多级页表的概念</h3><ol><li>现代计算机普遍支持$2^{32}-2^{64}$容量的逻辑地址空间，采用分页存储管理时，页表相当大，以Windows为例，其运行的Intel x86平台具有32位地址，规定页面4KB($2^{12}$)时，那么，4GB($2^{32}$)的逻辑地址空间由1MB($2^{20}$)个页组成，若每个页表项占用4个字节，则需要占用4MB($2^{22}$)连续主存空间存放页表。系统中有许多进程，因此页表存储开销很大。</li><li>做法：把整个页表分割成许多小页表，每个称为<strong>页表页</strong>，它的大小与页框长度相同，于是每个页表页含有若干页表表项。<ol><li>页表项从0开始编号，允许放到不连续的页框中，为了找到页表页，建立地质索引，称为<strong>页目录表</strong>。</li><li>系统为每一个进程建立一张页目录表，他的每一个表项指出一个页表页，而页表页的每个表项给出页面和页框的对应关系。</li></ol></li><li>逻辑地址结构有三部分组成：页目录、页表页和位移</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/83.png"></p><ol start="4"><li>解决页表页如何占用内存空间的问题，解决方法：进程运行设计到的页面的页表页放置在内存中，其他页表页使用时动态调入，因此需要添加标志位指示是否调入内存。</li></ol><h3 id="6-7-2-多级页表地址转换过程"><a href="#6-7-2-多级页表地址转换过程" class="headerlink" title="6.7.2. 多级页表地址转换过程"></a>6.7.2. 多级页表地址转换过程</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/71.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/72.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/73.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/74.png"></td></tr></tbody></table><h3 id="6-7-3-多级页表结构的本质"><a href="#6-7-3-多级页表结构的本质" class="headerlink" title="6.7.3. 多级页表结构的本质"></a>6.7.3. 多级页表结构的本质</h3><ol><li>多级不连续导致多级索引。</li><li>以二级页表为例，用户程序的页面不连续存放，要有页面地址索引，该索引是进程页表；进程页表又是不连续存放的多个页表页，故页表页也要页表页地址索引，该索引就是页目录。</li><li>页目录项是页表页的索引，而页表页项是进程程序的页面索引。</li></ol><h2 id="6-8-反置页表-IPT"><a href="#6-8-反置页表-IPT" class="headerlink" title="6.8. 反置页表(IPT)"></a>6.8. 反置页表(IPT)</h2><ol><li>页表设计的一个重要缺陷是页表的大小与虚拟地址空间的大小成正比</li><li>对于一个128MB的计算机，如果页面尺寸为4KB，页表项大小为4B，那么其反置页表只占有128KB的内存。</li><li>通过这个结构，哈希表和反向表中只有一项对应于一个实存页(面向实存)，而不是虚拟页(面向虚存)。因此，不论由多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分。</li><li>正向页表(名单)、反置页表(现场坐的是谁)<ol><li>正向页表:以<strong>页号</strong>为索引(隐含)，完整连续排列，页表项中不含页号，每个进程单独一个页表</li><li>反置页表:以<strong>页框号</strong>为索引(隐含)，完整连续排列，每个页框填入的是哪个进程的哪个页号，索引进程共用一个反置页表。其页表项不包含页框号</li></ol></li></ol><h3 id="6-8-1-反置页表的提出"><a href="#6-8-1-反置页表的提出" class="headerlink" title="6.8.1. 反置页表的提出"></a>6.8.1. 反置页表的提出</h3><ol><li>页表及相关硬件机制在地址转换、存储保护、虚拟地址访问中发挥了<strong>关键作用</strong>，为页式存储管理设置专门硬件机构</li><li>内存管理单元MMU：CPU管理虚拟&#x2F;物理存储器的控制线路，把虚拟地址映射为物理地址，并提供存储保护，必要时确定淘汰页面</li><li>反置页表IPT：<strong>MMU使用的数据结构</strong></li></ol><h3 id="6-8-2-反置页表的基本设计思想"><a href="#6-8-2-反置页表的基本设计思想" class="headerlink" title="6.8.2. 反置页表的基本设计思想"></a>6.8.2. 反置页表的基本设计思想</h3><ol><li><strong>针对内存中的每个页架建立一个页表</strong>，按照块号(页架号)排序</li><li>表项包含：正在访问该页框的进程标识、页号及特征位，和<strong>哈希链指针</strong>等</li><li>用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换</li></ol><h3 id="6-8-3-反置页表的页表项"><a href="#6-8-3-反置页表的页表项" class="headerlink" title="6.8.3. 反置页表的页表项"></a>6.8.3. 反置页表的页表项</h3><ol><li>页号：虚拟地址页号</li><li>进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)</li><li>标志位：有效、引用、修改、保护和锁定等标志信息</li><li>链指针：<strong>哈希链</strong>，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。</li></ol><h3 id="6-8-4-反置页表的逻辑地址"><a href="#6-8-4-反置页表的逻辑地址" class="headerlink" title="6.8.4. 反置页表的逻辑地址"></a>6.8.4. 反置页表的逻辑地址</h3><ol><li>进程标识符：使用该页的进程。</li><li>页号：虚拟地址页号部分，页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。</li><li>页内位移</li></ol><h3 id="6-8-5-反置页表的地址转换"><a href="#6-8-5-反置页表的地址转换" class="headerlink" title="6.8.5. 反置页表的地址转换"></a>6.8.5. 反置页表的地址转换</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/75.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/76.png"></th></tr></thead></table><blockquote><p>上图4-10中，以<strong>页框号</strong>为索引，记录当前页框中存储的是哪个进程的哪个页</p></blockquote><ol><li>反置页表地址转换过程如下:<ol><li>需要访问内存地址时，地址转换机制用进程标识符与页号作为输入，由哈希函数先映射到哈希表，哈希表项存放的是指向IPT表项的指针<ol><li>此指针可能就是指向匹配的IPT表项</li><li>如果不是则遍历哈希链直至找到进程标识符与页号均匹配的IPT表项：因为多个页号通过哈希值可能得到了相同的哈希值，所以我们选择使用哈希链。</li></ol></li><li>而此表项的**序号(索引)**就是页框号，通过拼接页内位移便可生成物理地址。</li><li>若在反置页表中未能找到匹配的IPT页表项，说明此页不在内存，触发缺页异常，请求操作系统通过页表调入：发生缺页中断时需要多访问一次磁盘，速度会比较慢。</li></ol></li><li>页框号是根据公式换算出来的:$x_i &#x3D; x_0 + 4 * i$</li></ol><h3 id="6-8-6-反置页表"><a href="#6-8-6-反置页表" class="headerlink" title="6.8.6. 反置页表"></a>6.8.6. 反置页表</h3><table><thead><tr><th>线性反置页表</th><th>反置页表</th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/77.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/78.png"></td></tr><tr><td>哈希线性反置页表</td><td>主存分配的位示图和链表方法</td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/79.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/80.png"></td></tr></tbody></table><h3 id="6-8-7-反置页表下的地址转换示意"><a href="#6-8-7-反置页表下的地址转换示意" class="headerlink" title="6.8.7. 反置页表下的地址转换示意"></a>6.8.7. 反置页表下的地址转换示意</h3><ol><li>未显示选择淘汰页面，同样由MMU完成</li><li>使用哈希提高性能-&gt;不必遍历</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/26.png"></p><h1 id="7-段式存储管理"><a href="#7-段式存储管理" class="headerlink" title="7. 段式存储管理"></a>7. 段式存储管理</h1><ol><li>段式存储管理基于可变分区存储管理原理。</li></ol><h2 id="7-1-程序分段结构"><a href="#7-1-程序分段结构" class="headerlink" title="7.1. 程序分段结构"></a>7.1. 程序分段结构</h2><ol><li>高级语言采用模块化程序设计方法。应用程序由若干程序段(模块)组成，如由主程序段(M)、子程序段(X)、数据段(D)和工作区段(W)组成，每一段都从0开始编制，各有各自名字和长度且实现不同功能。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/27.png"></p><ol start="2"><li>编译后段间地址是不连续的，段内地址是连续的。</li></ol><h2 id="7-2-段式存储逻辑地址"><a href="#7-2-段式存储逻辑地址" class="headerlink" title="7.2. 段式存储逻辑地址"></a>7.2. 段式存储逻辑地址</h2><ol><li>分段存储器的逻辑地址由两部分组成:段号+段内偏移</li><li>页式存储管理中页的划分对程序员不可见。</li><li>段式存储管理中段的划分对程序员可见。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/84.png"></p><h2 id="7-3-段式存储的段表"><a href="#7-3-段式存储的段表" class="headerlink" title="7.3. 段式存储的段表"></a>7.3. 段式存储的段表</h2><ol><li>存储分配时，应该为进入内存的作业建立段表，各段在内存中的情况有段表来记录，包含了段号、段起始长度和长度。</li><li>撤销进程时，回收所占用的内存空间，并清除此进程的段表。</li><li>段表表项实际上起到了基址&#x2F;限长寄存器的作用，设置段表控制寄存器</li></ol><h2 id="7-4-段式存储管理的基本思想"><a href="#7-4-段式存储管理的基本思想" class="headerlink" title="7.4. 段式存储管理的基本思想"></a>7.4. 段式存储管理的基本思想</h2><ol><li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区</li><li>硬件需要增加一组用户可见的段地址寄存器(代码段、数据段、堆栈段，附加段)，供地址转换使用</li><li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：段始址、段限长，以及存储保护、可移动、可扩充等标志位</li></ol><h2 id="7-5-段式存储管理的地址转换流程"><a href="#7-5-段式存储管理的地址转换流程" class="headerlink" title="7.5. 段式存储管理的地址转换流程"></a>7.5. 段式存储管理的地址转换流程</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/28.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/85.png"></th></tr></thead></table><blockquote><p>使用终端来完成</p></blockquote><h2 id="7-6-段的共享"><a href="#7-6-段的共享" class="headerlink" title="7.6. 段的共享"></a>7.6. 段的共享</h2><ol><li>如果多个进程段表中的某段指向内存相同的地址，内存中以该处为起始地址的某段就可以被共享。</li><li>对共享段的信息必须进行保护，如规定只能读出不能写入，不满足保护条件则产生保护中断</li><li>为了方便共享，系统中常常建立一张共享段表记录所有共享段，包含段名、共享计数、段长、段首址、保护位等。</li></ol><h1 id="8-分页和分段的寻址计算"><a href="#8-分页和分段的寻址计算" class="headerlink" title="8. 分页和分段的寻址计算"></a>8. 分页和分段的寻址计算</h1><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/37.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/38.png"></th></tr></thead></table><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/39.png"></p><h2 id="8-1-分段和分页的比较"><a href="#8-1-分段和分页的比较" class="headerlink" title="8.1. 分段和分页的比较"></a>8.1. 分段和分页的比较</h2><ol><li>分段是信息的<strong>逻辑单位</strong>，由源程序的逻辑结构所决定，<strong>用户可见</strong><ol><li>段长可根据<strong>用户需要</strong>来规定，段起始地址可从<strong>任何主存地址</strong>开始。</li><li>分段方式中，源程序(段号，段内位移)经连结装配后地址仍保持<strong>二维结构</strong>。</li></ol></li><li>分页是信息的物理单位，与源程序的逻辑结构无关，<strong>用户不可见</strong>，<ol><li>页长由<strong>系统</strong>确定，页面只能以<strong>页大小的整倍数地址</strong>开始</li><li>分页方式中，源程序(页号，页内位移)经连结装配后地址变成了<strong>一维结构</strong></li></ol></li></ol><h2 id="8-2-分页-逻辑地址到物理地址"><a href="#8-2-分页-逻辑地址到物理地址" class="headerlink" title="8.2. 分页:逻辑地址到物理地址"></a>8.2. 分页:逻辑地址到物理地址</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/65.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/66.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/67.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/68.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/69.png"></td><td></td></tr></tbody></table><h1 id="9-段页式存储管理"><a href="#9-段页式存储管理" class="headerlink" title="9. 段页式存储管理"></a>9. 段页式存储管理</h1><h2 id="9-1-段页式存储管理的基本思想"><a href="#9-1-段页式存储管理的基本思想" class="headerlink" title="9.1. 段页式存储管理的基本思想"></a>9.1. 段页式存储管理的基本思想</h2><ol><li><strong>段式存储管理</strong>可以基于<strong>页式存储管理</strong>实现</li><li>每一段不必占据连续的存储空间，可存放在不连续的主存页架中</li><li>能够扩充为段页式虚拟存储管理</li><li>装入部分段，或者装入段中部分页面</li></ol><h2 id="9-2-段页式存储管理的段表和页表"><a href="#9-2-段页式存储管理的段表和页表" class="headerlink" title="9.2. 段页式存储管理的段表和页表"></a>9.2. 段页式存储管理的段表和页表</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/31.png"></p><ol><li>既有段表，也有页表</li><li>段表中存储的是页表和页表始址</li></ol><h2 id="9-3-段页式存储管理的地址转换"><a href="#9-3-段页式存储管理的地址转换" class="headerlink" title="9.3. 段页式存储管理的地址转换"></a>9.3. 段页式存储管理的地址转换</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/32.png"></p><h1 id="10-页式虚拟存储管理"><a href="#10-页式虚拟存储管理" class="headerlink" title="10. 页式虚拟存储管理"></a>10. 页式虚拟存储管理</h1><h2 id="10-1-页式虚拟存储管理的基本原理"><a href="#10-1-页式虚拟存储管理的基本原理" class="headerlink" title="10.1. 页式虚拟存储管理的基本原理"></a>10.1. 页式虚拟存储管理的基本原理</h2><ol><li>将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装入内存，仅装入当前使用页面，进程执行过程中访问到不再内存的页面时，再由系统自动调入。</li><li>页式虚拟存储是现代OS的<strong>主流存储管理技术</strong></li><li>请求页式存储管理：由于页面在需要时是根据进程请求装入内存的</li><li>请求页式存储管理<ol><li>优点：进程的程序和数据可按页分散存储在内存中，有利于内存利用率和多道程序运行</li><li>缺点：需要硬件支持、处理缺页中断、机器成本增加、系统开销加大，页内存在碎片。</li></ol></li></ol><h3 id="10-1-1-页式虚拟存储管理的页表"><a href="#10-1-1-页式虚拟存储管理的页表" class="headerlink" title="10.1.1. 页式虚拟存储管理的页表"></a>10.1.1. 页式虚拟存储管理的页表</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/22.png"></p><ol><li>需要扩充页表项，至少包含如上信息，指出：<ol><li>主存驻留标志：指出页面是否已经装入内存。1表示在内存中可以被正常访问，0表示不能立即访问，产生缺页异常。</li><li>修改位：被设置后，该页被调出内存前必须先写回磁盘，保障数据一致性</li><li>保护位：限制页面访问权限</li><li>引用位：在页面被引用无论是读写时设置，用来帮助系统进行页面淘汰。</li><li>内存块号：页面对应的页框号，用来地址转换。</li></ol></li><li>32位操作系统:32bit标识一个页表项</li><li>页号是隐含信息，不是直接存储的信息。</li></ol><h2 id="10-2-页式虚拟存储管理的实现"><a href="#10-2-页式虚拟存储管理的实现" class="headerlink" title="10.2. 页式虚拟存储管理的实现"></a>10.2. 页式虚拟存储管理的实现</h2><ol><li>CPU处理地址<ol><li>若页驻留，则获得块号形成绝对地址</li><li>若页不在内存，则CPU发出缺页中断</li></ol></li><li>OS处理缺页中断<ol><li>若有空闲页架，则根据辅存地址(虚存)调入页，更新页表与快表等</li><li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li></ol></li></ol><h3 id="10-2-1-页式虚拟存储管理的地址转换"><a href="#10-2-1-页式虚拟存储管理的地址转换" class="headerlink" title="10.2.1. 页式虚拟存储管理的地址转换"></a>10.2.1. 页式虚拟存储管理的地址转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/23.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/24.png"></p><ol><li>本指令没有被处理完，是在查找地址的时候发生的中断，所以要回退指令执行。<br>缺页中断完成后要<strong>重新执行被中断指令</strong>。</li></ol><h3 id="10-2-2-页式虚拟存储管理的地址转换全过程"><a href="#10-2-2-页式虚拟存储管理的地址转换全过程" class="headerlink" title="10.2.2. 页式虚拟存储管理的地址转换全过程"></a>10.2.2. 页式虚拟存储管理的地址转换全过程</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/40.png"></p><ol><li>地址转换过程<ol><li>MMU接收CPU传送来的逻辑地址并自动按页面大小把它从某位起分解成两部分:页号和页内位移。</li><li>以页号为索引快速搜索快表TLB。</li><li>如果命中，立即送出页框号，并与贾内位移拼接成物理地址，然后进行访问权限检查，如获通过，进程就可以访问物理地址。</li><li>如果不命中，由硬件以页号为索引搜索页表，页表基址由硬件页表基址寄存器指出。</li><li>如果页表被命中，说明访问页面已在内存中，可送出页框号，并与页内位移拼接成物理地址，然后进行访问权限检查，如获通过，进程就可以访问物理地址，同时要把这个页面和页框信息装入快表TLB，以备再次访问。</li><li>如果发现页表中的对应页面失效，MMU发出缺页异常，请求操作系统进行处理，MMU工作到此结束。</li></ol></li><li>MMU发现缺页并发出缺页异常，存储管理接收控制，进行缺页异常处理的过程如下：<ol><li>挂起请求调页的进程。</li><li>根据页号搜索外页表，找到存放此页的磁盘物理地址。</li><li>查看内存是否有空闲页框，如有则分配一个，转(6)。</li><li>如果内存中无空闲页框，按照替换算法选择淘汰页面，检查其是否被写过或修改过，若否则转(6)，若是则转(5)。</li></ol></li></ol><h3 id="10-2-3-TLB-快表"><a href="#10-2-3-TLB-快表" class="headerlink" title="10.2.3. TLB(快表)"></a>10.2.3. TLB(快表)</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/35.png"></p><p>Note:快表存储正在进行的进程的若干(非连续)的页表项，其意义在于：快表访问速度高于内存，减少访问内存的次数，提高也是寻址效率</p><h1 id="11-页面调度"><a href="#11-页面调度" class="headerlink" title="11. 页面调度"></a>11. 页面调度</h1><ol><li>当主存空间已满而又需要装入新页时，页式虚拟存储管理必须按照一定的算法将已在主存的一些页调出去<ol><li>选择淘汰页的工作成为<strong>页面调度</strong></li><li>选择淘汰页的算法称为<strong>页面调度算法</strong></li></ol></li></ol><h2 id="11-1-交换区"><a href="#11-1-交换区" class="headerlink" title="11.1. 交换区"></a>11.1. 交换区</h2><ol><li>操作系统需要在磁盘上定义一个交换区用来保存临时换出的页面，交换区由磁盘上的一个或多个磁盘分区组成。</li><li>简单做法：进程启动时，留出大小和进程一样大的交换分区。</li><li>与进程对应的是其交换区的磁盘地址，即进程映像所保存的位置，这一信息记录在进程的外页表中。</li><li>问题：进程启动可能会在增大，解决：将正文、数据和堆栈分别保留交换区，并且多留几块。</li><li>交换区管理重点是维护交换区映射表，记录所有的呗换出内存的页面在交换区中的位置，以便需要时换入，第二次被换出内存时，当且仅当页面修改过才再次写入，否则直接抛弃。</li></ol><h2 id="11-2-页面装入策略和清除策略"><a href="#11-2-页面装入策略和清除策略" class="headerlink" title="11.2. 页面装入策略和清除策略"></a>11.2. 页面装入策略和清除策略</h2><ol><li>页面装入策略用来解决何时将页面装入内存</li><li>请页式：当产生缺页异常时调入页面<ol><li>在替换时只有发生了更改才写回。</li><li>优点：只有被访问页面才会被调入，节省内存</li><li>缺点：缺页异常处理次数多，系统开销大。</li></ol></li><li>预调式：在使用页面前预先调入内存，操作系统根据某种算法动态预测进程最可能访问的界面，每次调入若干页面。<ol><li>在替换前需要将他们都写回磁盘，可成批进行。</li><li>优点：减少磁盘I&#x2F;O的启动次数，节省寻道和搜索时间。</li><li>缺点：如果调入的大多数界面都没有被使用则效率很低。</li></ol></li></ol><h2 id="11-3-页面分配策略"><a href="#11-3-页面分配策略" class="headerlink" title="11.3. 页面分配策略"></a>11.3. 页面分配策略</h2><ol><li>请求分页虚存管理可能在缺页方面付出很大的代价，需要确定页面调度算法的作用范围是此进程的页面，还是内存中的所有进程的页面。<ol><li>全局替换：不考虑进程属主</li><li>局部替换：仅限于进程本身</li></ol></li><li>分配方式<ol><li>固定分配：进程生命周期中保持页框数固定不变，有平均分配、比例分配、优先权分配等方式。</li><li>可变分配：进程生命周期中所分得的页框数可变。<ol><li>缺页率较高，说明局部性较差，可以适度提高分配的页框数。</li><li>缺页率较低，可以适度降低分配的页框数</li></ol></li></ol></li><li>工作集(驻留集)：每个进程维护的一组页面。</li><li>可变分配配合局部替换可以克服全局替换的缺点。</li></ol><h3 id="11-3-1-固定分配，本地范围"><a href="#11-3-1-固定分配，本地范围" class="headerlink" title="11.3.1. 固定分配，本地范围"></a>11.3.1. 固定分配，本地范围</h3><ol><li>分配给进程的帧数是固定的</li><li>从分配给过程的框架中选择要替换的页面</li></ol><h3 id="11-3-2-变量分配，全局范围"><a href="#11-3-2-变量分配，全局范围" class="headerlink" title="11.3.2. 变量分配，全局范围"></a>11.3.2. 变量分配，全局范围</h3><ol><li>分配给进程的帧数是可变的</li><li>从所有框架中选择要替换的页面</li><li>最容易实现</li><li>被许多操作系统采用</li><li>操作系统保留空闲帧列表</li><li>发生页面错误时，将空闲帧添加到驻留的进程集</li><li>课本224全局页面替换策略和229局部页面替换策略</li></ol><h3 id="11-3-3-变量分配，本地范围"><a href="#11-3-3-变量分配，本地范围" class="headerlink" title="11.3.3. 变量分配，本地范围"></a>11.3.3. 变量分配，本地范围</h3><ol><li>分配给进程的帧数是可变的</li><li>从分配给过程的框架中选择要替换的页面</li><li>添加新流程后，请根据应用程序类型，程序请求或其他条件分配页框数量</li><li>发生页面错误时，请从发生故障的进程的常驻集中选择页面。</li><li>不时重新评估分配</li></ol><h2 id="11-4-缺页中断率"><a href="#11-4-缺页中断率" class="headerlink" title="11.4. 缺页中断率"></a>11.4. 缺页中断率</h2><ol><li>页面调度算法设计不当，会出现(刚淘汰的页面立即又要调入，并如此反复)，这种现象称为<strong>抖动</strong>或<strong>颠簸</strong>，主要原因是内存中同时运行的进程太多，而分配给每个进程的页框太少。</li><li>假定进程$P$共有$n$页，系统分配页架数$m$个</li><li>$P$运行中成功访问次数为$S$，不成功访问次数为$F$，总访问次数$A &#x3D; S + F$</li><li><strong>缺页中断率</strong>定义为: $f &#x3D; \frac{F}{A}$</li><li>缺页中断率是衡量存储管理性能和用户编程水平的重要依据</li></ol><h3 id="11-4-1-缺页中断率的影响因素"><a href="#11-4-1-缺页中断率的影响因素" class="headerlink" title="11.4.1. 缺页中断率的影响因素"></a>11.4.1. 缺页中断率的影响因素</h3><ol><li>分配给进程的页框数：可用页框数越多，则缺页中断率就越低</li><li>页面的大小：页面尺寸越大，则缺页中断率就越低</li><li>页面替换算法：算法的优劣影响缺页异常次数</li><li>程序特性：程序局部性要好，它对缺页中断率有很大影响。</li></ol><h3 id="11-4-2-用户编程的例子"><a href="#11-4-2-用户编程的例子" class="headerlink" title="11.4.2. 用户编程的例子"></a>11.4.2. 用户编程的例子</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/25.png"></p><blockquote><p>不同的访问方式会到导致出现缺页情况的。</p></blockquote><h2 id="11-5-全局页面替换策略"><a href="#11-5-全局页面替换策略" class="headerlink" title="11.5. 全局页面替换策略"></a>11.5. 全局页面替换策略</h2><h3 id="11-5-1-OPT页面调度算法-Belady算法"><a href="#11-5-1-OPT页面调度算法-Belady算法" class="headerlink" title="11.5.1. OPT页面调度算法(Belady算法)"></a>11.5.1. OPT页面调度算法(Belady算法)</h3><ol><li>算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择<strong>距现在最长时间后再访问</strong>的页。</li><li>该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)</li><li>OPT只可以<strong>模拟</strong>，不可以实现，因为永远无法预知之后的事情。</li><li>这种算法可以用作衡量其他各种算法的标准。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/41.png"></p><h3 id="11-5-2-先进先出页面调度算法-FIFO"><a href="#11-5-2-先进先出页面调度算法-FIFO" class="headerlink" title="11.5.2. 先进先出页面调度算法(FIFO)"></a>11.5.2. 先进先出页面调度算法(FIFO)</h3><ol><li>算法描述：首先淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)</li><li>模拟的是程序执行的顺序性，有一定合理性，并不能很好模拟程序的循环性。</li><li>根据估计，缺页中断率也是最佳算法的2-3倍。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/42.png"></p><ol start="4"><li><strong>FIFO算法的Belady异常</strong>：更多的页框导致了更高的缺页率，页框为3和4的时候</li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/47.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/48.png"></th></tr></thead></table><h3 id="11-5-3-页面缓冲算法"><a href="#11-5-3-页面缓冲算法" class="headerlink" title="11.5.3. 页面缓冲算法"></a>11.5.3. 页面缓冲算法</h3><p>页面缓冲算法是对FIFO替换算法的一种改进</p><blockquote><p>算法策略</p></blockquote><ol start="2"><li>系统维护两个FIFO队列，被替换的页面添加到如下两个队列中<ol><li>修改页面队列</li><li>非修改(空闲)页面队列</li></ol></li><li>替换的页面仍保留在内存中<ol><li>如果再次引用，则找回的费用很少</li><li>当修改页面队列中的页面到达一定数量后，页面以群集形式写回磁盘，并把空闲页框加入非修改页面队列尾部。</li></ol></li></ol><h3 id="11-5-4-最近最少用LRU页面调度算法"><a href="#11-5-4-最近最少用LRU页面调度算法" class="headerlink" title="11.5.4. 最近最少用LRU页面调度算法"></a>11.5.4. 最近最少用LRU页面调度算法</h3><ol><li>淘汰<strong>最近一段时间较久未被访问</strong>的那一页，即那些刚被使用过的页面，可以马上还要被使用到。</li><li>模拟了程序执行的局部属性，既考虑了<strong>循环性</strong>，又兼顾了<strong>顺序性</strong></li><li>严格实现的代价大(需要维持特殊队列——页面淘汰队列)，实现需要硬件支持。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/43.png"></p><ol start="4"><li>LRU算法得到模拟实现：模拟是相当的不严谨，非常粗粒度的一个模拟。<ol><li>引用位法：每页建立一个引用标志，供硬件使用，设置一个时间间隔中断，发生时将页引用标志置0，访问页面时将引用标志置为1，页面置换的时候选择标志为0的页面，在选中淘汰页时，将所有的页的引用为全部置为0</li><li>计数法：每页添加页面引用计数器，根据计数器选择最小的，定时清空页面引用计数器</li><li>计时法：每页添加计时单元，引用时，将绝对时间记录进入计时单元，定时清空计时单元。</li><li>老化算法：设置一个多位寄存器，被访问将最左侧设置为1，定时将寄存器右移，缺页中断时找到最小值的寄存器界面淘汰，被采用较多。</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/87.png"></p><ol><li>上图使用老化算法</li><li>T3时刻替换P2页面，因为和P1他们在3时刻都没有被访问，但是2时刻P1被访问了</li></ol><h3 id="11-5-5-第二次机会页面替换算法-SCR，Second-Chance-Replacement"><a href="#11-5-5-第二次机会页面替换算法-SCR，Second-Chance-Replacement" class="headerlink" title="11.5.5. 第二次机会页面替换算法(SCR，Second Chance Replacement)"></a>11.5.5. 第二次机会页面替换算法(SCR，Second Chance Replacement)</h3><ol><li>将FIFO算法和页表中引用位结合。</li><li>算法描述：<ol><li>首先检查FIFO页面队列队首<ol><li>引用位为0，则淘汰该页面</li><li>引用位为1，将引用位清0，并将该页面移到队列尾部</li></ol></li><li>如果第一遍全为1，则循环</li></ol></li></ol><h3 id="11-5-6-最不常用LFU的页面调度算法"><a href="#11-5-6-最不常用LFU的页面调度算法" class="headerlink" title="11.5.6. 最不常用LFU的页面调度算法"></a>11.5.6. 最不常用LFU的页面调度算法</h3><ol><li>淘汰最近一段时间内<strong>访问次数较少</strong>的页面，对OPT的模拟性比LRU更好</li><li>算法过程：基于时间间隔中断，并给每一页设置一个计数器，时间间隔中断发生后，所有计数器清0，每访问页1次就给计数器加1，选择计数最小的页面淘汰</li></ol><h3 id="11-5-7-时钟CLOCK页面调度算法"><a href="#11-5-7-时钟CLOCK页面调度算法" class="headerlink" title="11.5.7. 时钟CLOCK页面调度算法"></a>11.5.7. 时钟CLOCK页面调度算法</h3><ol><li>CLOCK就是SCR结合FIFO形成循环，使用页引用标志位。</li><li>算法描述：采用循环队列机制构造页面队列，形成了一个类似钟表面的环形表，队列指针则相当于钟表面上的表针，指向可能要淘汰的页面</li></ol><h4 id="11-5-7-1-CLOCK算法的工作流程"><a href="#11-5-7-1-CLOCK算法的工作流程" class="headerlink" title="11.5.7.1. CLOCK算法的工作流程"></a>11.5.7.1. CLOCK算法的工作流程</h4><ol><li>页面调入主存时，其引用标志位置为1</li><li>访问主存页面时，其引用标志位置为1</li><li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ol><li>把所遇到的引用标志位是1的页面的引用标志位清0并跳过</li><li>把所遇到的引用标志位是0的页面淘汰，<strong>指针推进一步</strong></li></ol></li></ol><h4 id="11-5-7-2-CLOCK算法的例子"><a href="#11-5-7-2-CLOCK算法的例子" class="headerlink" title="11.5.7.2. CLOCK算法的例子"></a>11.5.7.2. CLOCK算法的例子</h4><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/44.png"></p><blockquote><p>灰色和星号代表1，蓝色和无星号代表0</p><ol><li>发生命中，指针不动</li><li>指针运动是为了寻找替换的页</li><li>1-&gt;5其实是循环一轮，如果为1，指针不替换，但是会将标志位置为0</li></ol></blockquote><ol><li>当一页被替换时，指向下一帧。虽然早就进来，但是最近使用过，所以不急着替换</li><li>当需要替换一页时，扫描缓冲区，查找使用位被置为0的一帧。</li><li>每当遇到一个使用位为1的帧时，就将该位重新置为0；</li><li>如果在这个过程开始时，所有帧的使用位均为0，选择遇到的第一个帧替换；</li><li>如果所有帧的使用位为1，则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。</li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/45.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/46.png"></th></tr></thead></table><h4 id="11-5-7-3-第三次机会时钟替换算法：结合引用位和修改位"><a href="#11-5-7-3-第三次机会时钟替换算法：结合引用位和修改位" class="headerlink" title="11.5.7.3. 第三次机会时钟替换算法：结合引用位和修改位"></a>11.5.7.3. 第三次机会时钟替换算法：结合引用位和修改位</h4><ol><li>一共四种情况：r是引用位，m是修改位<ol><li>最近未被引用，未被修改：r&#x3D;0，m&#x3D;0</li><li>最近被引用，未被修改：r&#x3D;1，m&#x3D;0</li><li>最近未被引用，被修改：r&#x3D;0，m&#x3D;1</li><li>最近被引用，被修改：r&#x3D;1，m&#x3D;1</li></ol></li><li>算法描述<ol><li>扫描，不修改引用位，找到第一个r&#x3D;0，m&#x3D;0的页面替换</li><li>如果1没有找到，则从原位置开始，<strong>修改引用位</strong>，查找r&#x3D;0，m&#x3D;1的页面替换写回</li><li>如果2没有找到，重复1或2操作。</li></ol></li></ol><h3 id="11-5-8-不同算法性能比较"><a href="#11-5-8-不同算法性能比较" class="headerlink" title="11.5.8. 不同算法性能比较"></a>11.5.8. 不同算法性能比较</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/49.png"></p><p>整体上来讲FIFO &gt; CLOCK &gt; LRU &gt; OPT</p><h2 id="11-6-局部页面替换算法-不考"><a href="#11-6-局部页面替换算法-不考" class="headerlink" title="11.6. 局部页面替换算法(不考)"></a>11.6. 局部页面替换算法(不考)</h2><p>P229-233</p><h3 id="11-6-1-局部最佳页面替换算法-MIN"><a href="#11-6-1-局部最佳页面替换算法-MIN" class="headerlink" title="11.6.1. 局部最佳页面替换算法(MIN)"></a>11.6.1. 局部最佳页面替换算法(MIN)</h3><ol><li>实现思想：进程在时刻t访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框</li><li>不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</li><li>t为一个系统常量，间隔(t, t+τ)称作滑动窗口 。例子中τ&#x3D;3，双闭区间</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/50.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/51.png"></p><h3 id="11-6-2-工作集模型和工作集置换算法-WS"><a href="#11-6-2-工作集模型和工作集置换算法-WS" class="headerlink" title="11.6.2. 工作集模型和工作集置换算法(WS)"></a>11.6.2. 工作集模型和工作集置换算法(WS)</h3><ol><li>进程工作集指”在某一段时间间隔内进程运行所需访问的页面集合”</li><li>实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，<strong>不向前查看页面引用串，而是基于程序局部性原理向后看</strong></li><li>任何给定时刻，<strong>进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计</strong></li></ol><h4 id="11-6-2-1-进程工作集"><a href="#11-6-2-1-进程工作集" class="headerlink" title="11.6.2.1. 进程工作集"></a>11.6.2.1. 进程工作集</h4><ol><li>指”在某一段时间间隔内进程运行所需访问的页面集合”，W(t，Δ)表示在时刻t-Δ到时刻t之间( (t-Δ，t))所访问的页面集合，进程在时刻t的工作集</li><li>Δ是系统定义的一个常量。变量Δ称为”工作集窗口尺寸”，可通过窗口来观察进程行为，还把工作集中所包含的页面数目称为”工作集尺寸”</li><li>Δ&#x3D;3</li></ol><h4 id="11-6-2-2-示例"><a href="#11-6-2-2-示例" class="headerlink" title="11.6.2.2. 示例"></a>11.6.2.2. 示例</h4><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/52.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/53.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/54.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/55.png"></p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/56.png"></p><blockquote><p>工作集:程序在运行过程时，程序的局部性是变更的。有的部分是比较陡的，大量调入，然后平稳期，访问替换进来的页们。</p></blockquote><h3 id="11-6-3-模拟工作集替换算法"><a href="#11-6-3-模拟工作集替换算法" class="headerlink" title="11.6.3. 模拟工作集替换算法"></a>11.6.3. 模拟工作集替换算法</h3><h3 id="11-6-4-缺页频率替换算法"><a href="#11-6-4-缺页频率替换算法" class="headerlink" title="11.6.4. 缺页频率替换算法"></a>11.6.4. 缺页频率替换算法</h3><ol><li>定义页面错误率的上限U和下限L。</li><li>如果缺页率高于U，则为进程分配更多页框。</li><li>如果缺页率低于U，则为进程分配更少页框。</li><li>驻留集的大小应该和工作集大小W紧密相关的。</li><li>如果PFF(缺页率)&gt;U并且没有更多可用帧，我们将暂停该过程，ROI(Return On Investment)</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/58.png"></p><blockquote><p>页框的大小是需要根据程序动态调整的。</p></blockquote><h3 id="11-6-5-通过工作集确定驻留集大小"><a href="#11-6-5-通过工作集确定驻留集大小" class="headerlink" title="11.6.5. 通过工作集确定驻留集大小"></a>11.6.5. 通过工作集确定驻留集大小</h3><ol><li>监视每个进程的工作集，只有属于工作集的页面才能留在主存；</li><li>定期地从进程驻留集中删去那些不在工作集中的页面；</li><li>仅当一个进程的工作集在主存时，进程才能执行。</li></ol><h1 id="12-段式虚拟存储管理"><a href="#12-段式虚拟存储管理" class="headerlink" title="12. 段式虚拟存储管理"></a>12. 段式虚拟存储管理</h1><h2 id="12-1-段式虚拟存储管理的基本思想"><a href="#12-1-段式虚拟存储管理的基本思想" class="headerlink" title="12.1. 段式虚拟存储管理的基本思想"></a>12.1. 段式虚拟存储管理的基本思想</h2><ol><li>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入</li><li>段式虚拟存储管理中段的调进调出是由OS自动实现的，<strong>对用户透明</strong></li><li>与段覆盖技术不同，它是用户控制的主存扩充技术，OS不感知</li></ol><h2 id="12-2-段式虚拟存储管理的段表扩充"><a href="#12-2-段式虚拟存储管理的段表扩充" class="headerlink" title="12.2. 段式虚拟存储管理的段表扩充"></a>12.2. 段式虚拟存储管理的段表扩充</h2><ol><li>段表的扩充</li><li>特征位: 00(不在内存)01(在内存)11(共享段)</li><li>存取权限: 00(可执行)01(可读)11(可写)</li><li>扩充位: 0(固定长)1(可扩充)</li><li>标志位: 00(未修改)01(已修改)11(不可移动)</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/29.png"></p><h2 id="12-3-段式虚拟存储管理的地址转换"><a href="#12-3-段式虚拟存储管理的地址转换" class="headerlink" title="12.3. 段式虚拟存储管理的地址转换"></a>12.3. 段式虚拟存储管理的地址转换</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/30.png"></p><h1 id="13-段页式虚拟存储管理"><a href="#13-段页式虚拟存储管理" class="headerlink" title="13. 段页式虚拟存储管理"></a>13. 段页式虚拟存储管理</h1><h2 id="13-1-段页式虚拟存储基本原理"><a href="#13-1-段页式虚拟存储基本原理" class="headerlink" title="13.1. 段页式虚拟存储基本原理"></a>13.1. 段页式虚拟存储基本原理</h2><ol><li>虚地址以程序的逻辑结构划分为段，这是段页式的段式特征。</li><li>实地址划分层位置固定、大小相同的页框(块)，这是段页式的页式特征。</li><li>将每一段的线性地址空间划分成与页框大小相同的页面，段页式的特征</li><li>逻辑地址由段号s、段内页号p和页内偏移d组成<ol><li>对用户，虚拟地址由段号s和段内位移d’组成</li><li>系统内部将d’分解为p和d，d’ &#x3D; p * 块长 + d</li></ol></li><li>请求段页式虚拟存储管理的数据结构比较复杂，包含作业表、段表和页表三部分。<ol><li>作业表：进入系统的作业和作业段表的起始地址</li><li>段表：是否在内存、段页表起始地址</li><li>页表：是否在内存、对应内存块号</li></ol></li></ol><h2 id="13-2-段页式虚拟存储管理的地址转换"><a href="#13-2-段页式虚拟存储管理的地址转换" class="headerlink" title="13.2. 段页式虚拟存储管理的地址转换"></a>13.2. 段页式虚拟存储管理的地址转换</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/33.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/88.png"></th></tr></thead></table><h1 id="14-存储管理方案以及虚存页面替换算法小结"><a href="#14-存储管理方案以及虚存页面替换算法小结" class="headerlink" title="14. 存储管理方案以及虚存页面替换算法小结"></a>14. 存储管理方案以及虚存页面替换算法小结</h1><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/89.png"></p><h1 id="15-补充：关于快表问题"><a href="#15-补充：关于快表问题" class="headerlink" title="15. 补充：关于快表问题"></a>15. 补充：关于快表问题</h1><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/1.jpg"></p><blockquote><p>有效位为0，不指引</p></blockquote><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/2.jpg"></p><ol><li>Valid并不全表示页表项是否在主存中</li><li>发生页面替换的时候，被替换的页如果在快表中，则其的valid位置0或者将该页删除。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/3.jpg"></p><h1 id="16-Linux虚拟存储管理"><a href="#16-Linux虚拟存储管理" class="headerlink" title="16. Linux虚拟存储管理"></a>16. Linux虚拟存储管理</h1><h2 id="16-1-伙伴系统-一种算法"><a href="#16-1-伙伴系统-一种算法" class="headerlink" title="16.1. 伙伴系统(一种算法)"></a>16.1. 伙伴系统(一种算法)</h2><ol><li>伙伴系统(Knuth，1973)，又称buddy算法，是一种<strong>固定分区和可变分区</strong>折中的主存管理算法</li><li>基本原理是：任何尺寸为$2^i$的空闲块都可被分为两个尺寸为$2^{i-1}$的空闲块，这两个空闲块称作<strong>伙伴</strong>，它们可以被合并成尺寸为$2^i$的原先空闲块。</li><li>伙伴通过对大块的物理主存划分而获得<ol><li>假如从第0个页面开始到第3个页面结束的主存</li><li>每次都对半划分，那么第一次划分获得大小为2页的伙伴，如0、1和2、3</li><li>进一步划分，可以获得大小为1页的伙伴，例如0和1，2和3</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/60.png"></p><h3 id="16-1-1-例子：类似二叉树的形式进行分配"><a href="#16-1-1-例子：类似二叉树的形式进行分配" class="headerlink" title="16.1.1. 例子：类似二叉树的形式进行分配"></a>16.1.1. 例子：类似二叉树的形式进行分配</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/61.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/62.png"></th></tr></thead></table><h3 id="16-1-2-Linux伙伴系统"><a href="#16-1-2-Linux伙伴系统" class="headerlink" title="16.1.2. Linux伙伴系统"></a>16.1.2. Linux伙伴系统</h3><ol><li>以page结构为数组元素的<code>mem_map[]</code>数组</li><li>以free_area_struct结构为数组元素的free_area数组</li><li>位图数组(bitmap)</li></ol><h4 id="16-1-2-1-Linux基于伙伴的slab分配器"><a href="#16-1-2-1-Linux基于伙伴的slab分配器" class="headerlink" title="16.1.2.1. Linux基于伙伴的slab分配器"></a>16.1.2.1. Linux基于伙伴的slab分配器</h4><ol><li>为什么要使用slab分配器?<ol><li>伙伴系统以<strong>页框</strong>为基本分配单位，内核在很多情况下，<strong>需要的主存量远远小于页框大小</strong>，如inode、vma、task_struct等，为了更经济地使用内核主存资源，引入<strong>SunOS操作系统中首创的基于伙伴系统的slab分配器</strong>，其基本思想是：为经常使用的小对象建立缓存，小对象的申请与释放都通过slab分配器来管理，仅当缓存不够用时才向伙伴系统申请更多空间。&#x2F;&#x2F;页内可以按2的幂次拆分。</li><li>优点：<strong>充分利用主存，减少内部碎片</strong>，对象管理局部化，尽可能少地与伙伴系统打交道，从而提高效率。</li></ol></li><li>slab的结构</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span>&#123;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>;          <span class="hljs-comment">// slab满、半满或空闲链表</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> colouoff;    <span class="hljs-comment">//slab着色偏移量</span><br>   <span class="hljs-type">void</span> * s_mem;              <span class="hljs-comment">//slab的第一个对象</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;        <span class="hljs-comment">//已分配的对象数</span><br>   <span class="hljs-type">kmem_bufctl_t</span> free;        <span class="hljs-comment">//第一个空闲对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>slab的操作</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/63.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/64.png"></p><h4 id="16-1-2-2-slab分配器主要操作"><a href="#16-1-2-2-slab分配器主要操作" class="headerlink" title="16.1.2.2. slab分配器主要操作"></a>16.1.2.2. slab分配器主要操作</h4><ol><li>kmem_cache_create()函数：创建专用cache，规定对象的大小和slab的构成，并加入cache管理队列；</li><li>kmem_cache_alloc()与kmem_cache_free()函数：分别用于分配和释放一个拥有专用slab队列的对象；</li><li>kmem_cache_grow()与kmem_cache_reap()函数：<ol><li>kmem_cache_grow()它向伙伴系统申请向cache增加一个slab</li><li>kmem_cache_reap()用于定时回收空闲slab</li></ol></li><li>kmem_cache_destroy()与kmem_cache_shrink()：用于cache的销毁和收缩；</li><li>kmalloc()与kfree()函数：用来从通用的缓冲区队列中申请和释放空间；</li><li>kmem_getpages()与kmem_freepages()函数：slab与页框级分配器的接口，当slab分配器要创建新的slab或cache时，通过kmem_getpages()向内核提供的伙伴算法来获得一组连续页框。如果释放分配给slab分配器的页框，则调用kmem_freepages()函数。</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.处理器管理</title>
    <link href="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/"/>
    <url>/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/</url>
    
    <content type="html"><![CDATA[<h2 id="Lecture2-处理器管理"><a href="#Lecture2-处理器管理" class="headerlink" title="Lecture2-处理器管理"></a>Lecture2-处理器管理</h2><ol><li><strong>处理器管理</strong>是操作系统的重要组成部分<ol><li>处理器负责<strong>管理、调度和分配</strong>计算机系统的重要资源，并控制程序执行</li><li>处理器管理中最重要的是<strong>处理器调度</strong>，即进程调度，也就是控制、协调进程对处理器的竞争。</li></ol></li><li>进程与线程<ol><li>进程是资源分配和管理的单位</li><li>线程是处理器调度的基本单位。</li></ol></li><li>管态与目态<ol><li>管态又叫特权态(内核态、核心态)，可以执行特权指令，执行资源管理程序、为应用程序执行提供良好运行环境的各种原语等。</li><li>目态又叫用户态(普通态)，只能执行非特权指令</li></ol></li></ol><h1 id="1-处理器和寄存器"><a href="#1-处理器和寄存器" class="headerlink" title="1. 处理器和寄存器"></a>1. 处理器和寄存器</h1><h2 id="1-1-处理器"><a href="#1-1-处理器" class="headerlink" title="1.1. 处理器"></a>1.1. 处理器</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/1.png"></p><blockquote><p>部件简单示意图</p></blockquote><ol><li>上图各组件通过<strong>内部总线</strong>连接起来，构成一个<strong>不包含通用寄存器、I&#x2F;O相关寄存器、地址寄存器、数据寄存器和Cache</strong>的示意图。</li><li>CPU中的各组件描述<ol><li>算数逻辑单元：计算结束之后会将结果的标志放置到标志寄存器Flag中。</li><li>控制单元：包含重要的指令译码器ID，而指令是放置在指令暂存器IR中。</li><li>程序计数器PC：下一条指令的地址</li><li><strong>内存地址寄存器</strong>和<strong>内存数据寄存器</strong>：用来完成对内存数据的访问。</li></ol></li><li>通过<strong>系统总线</strong>来访问内存中的数据，首先设置地址和数据，然后通过控制来完成数据的读取和写回。</li><li>时钟等<strong>外部信号</strong>来反应到处理器线程中来。</li></ol><h2 id="1-2-寄存器"><a href="#1-2-寄存器" class="headerlink" title="1.2. 寄存器"></a>1.2. 寄存器</h2><h3 id="1-2-1-用户程序可见寄存器"><a href="#1-2-1-用户程序可见寄存器" class="headerlink" title="1.2.1. 用户程序可见寄存器"></a>1.2.1. 用户程序可见寄存器</h3><ol><li>可以使程序员减少访问主存储器的次数，提高指令执行的效率</li><li>所有程序可使用，包括应用程序和系统程序<ol><li>数据(通用)寄存器:AX、BX、CX、DX等</li><li>地址寄存器:索引(SI、DI)、栈指针(SP、BP)、段地址(CS、DS、SS、ES)、页表寄存器等</li></ol></li></ol><h3 id="1-2-2-控制和状态寄存器"><a href="#1-2-2-控制和状态寄存器" class="headerlink" title="1.2.2. 控制和状态寄存器"></a>1.2.2. 控制和状态寄存器</h3><ol><li>控制和状态寄存器用于控制处理器的操作，主要是被具有特权的操作系统程序使用，以控制程序的执行<ol><li>程序计数器PC：存储将取指令的地址</li><li>指令寄存器IR：存储最近使用的指令</li><li>条件码CC：CPU为指令操作结果设置的位，标志正&#x2F;负&#x2F;零&#x2F;溢出等结果</li></ol></li><li>标志位</li></ol><table><thead><tr><th>位</th><th>描述</th></tr></thead><tbody><tr><td>中断位</td><td>是否有中断发生了，中断源是什么</td></tr><tr><td>中断允许位</td><td>表示目前是否响应中断</td></tr><tr><td>中断屏蔽位</td><td>中断发生了，中断响应了，我们要不要屏蔽中断</td></tr><tr><td>处理器模式位</td><td>现在处理器是处于何种模式</td></tr><tr><td>内存保护位</td><td>对这段内存是只读还是读写还是不可操作</td></tr></tbody></table><h3 id="1-2-3-程序状态字PSW"><a href="#1-2-3-程序状态字PSW" class="headerlink" title="1.2.3. 程序状态字PSW"></a>1.2.3. 程序状态字PSW</h3><ol><li>PSW既是操作系统的概念，指记录当前程序运行的<strong>动态信息</strong>，通常包含：<ol><li>程序计数器、指令寄存器、条件码</li><li>中断字、中断允许&#x2F;禁止、中断屏蔽、处理器模式、内存保护、调试控制</li></ol></li><li>PSW也是计算机系统的<strong>寄存器</strong><ol><li>通常设置一组控制与状态寄存器</li><li>也可以专设一个PSW寄存器</li></ol></li><li>标志划分为三组:<strong>状态标志、控制标志和系统标志</strong>(更多见P58)<ol><li>状态标志：使得一条指令的执行结果影响其后指令的执行，比如溢出等标志</li><li>控制指令：控制操作系统行为，比如模式转换等。</li><li>系统标志：与进程管理有关，用于保护模式。</li></ol></li></ol><h1 id="2-指令与处理器模式"><a href="#2-指令与处理器模式" class="headerlink" title="2. 指令与处理器模式"></a>2. 指令与处理器模式</h1><h2 id="2-1-机器指令"><a href="#2-1-机器指令" class="headerlink" title="2.1. 机器指令"></a>2.1. 机器指令</h2><ol><li><strong>机器指令</strong>是计算机系统执行的基本命令，是中央处理器执行的基本单位。</li><li>指令由一个或多个字节组成，包括操作码字段、一个或多个操作数地址字段、以及一些表征机器状态的状态字以及特征码。</li><li>指令完成各种算术逻辑运算、数据传输、控制流跳转。</li></ol><h2 id="2-2-指令执行过程"><a href="#2-2-指令执行过程" class="headerlink" title="2.2. 指令执行过程"></a>2.2. 指令执行过程</h2><ol><li>CPU根据PC<strong>取出指令</strong>，放入IR，并对指令译码，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行</li><li><strong>一种</strong>指令执行步骤如下：(还有更加细分，这只是一种示例)<ol><li>取指：根据PC从存储器或高速缓冲存储器中取指令到IR</li><li>解码：解译IR中的指令来决定其执行行为</li><li>执行：连接到CPU部件，执行运算，产生结果并写回，同时在CC里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</li></ol></li></ol><h2 id="2-3-指令执行周期与指令流水线"><a href="#2-3-指令执行周期与指令流水线" class="headerlink" title="2.3. 指令执行周期与指令流水线"></a>2.3. 指令执行周期与指令流水线</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/4.png"></p><blockquote><p>现在的操作系统不是顺序地完成指令执行，而是选择使用指令流水线的方式来执行指令</p></blockquote><h2 id="2-4-特权指令与非特权指令"><a href="#2-4-特权指令与非特权指令" class="headerlink" title="2.4. 特权指令与非特权指令"></a>2.4. 特权指令与非特权指令</h2><blockquote><p>用户程序并非能够使用全部机器指令，那些与计算机核心资源相关的特殊指令会被保护</p></blockquote><ol><li>比如：启动I&#x2F;O指令(启动打印机，打印文件会细分成按照行打印，可能导致逻辑上的失败)、置PC指令(多道程序调用)等等</li><li>核心资源相关的指令只能被操作系统程序使用(作为特权指令，不允许在用户态使用这些命令)</li></ol><h3 id="2-4-1-特权指令"><a href="#2-4-1-特权指令" class="headerlink" title="2.4.1. 特权指令"></a>2.4.1. 特权指令</h3><ol><li>只有操作系统本身可以使用的指令，在内核态才能调用的命令，不仅仅影响运行程序本身，还会干扰其他程序及操作系统。</li><li>比如改变机器状态、修改寄存器值、置中断屏蔽位、加载程序状态字等。</li><li>如果应用程序执行特权指令则会导致非法执行而产生保护中断，进而转向操作系统的”用户非法执行特权指令”的异常处理程序处理。</li></ol><h3 id="2-4-2-非特权指令"><a href="#2-4-2-非特权指令" class="headerlink" title="2.4.2. 非特权指令"></a>2.4.2. 非特权指令</h3><ol><li>所有的用户程序都能够使用的指令，在用户态和内核态都可以调用的命令。</li><li>非特权命令在目态和管态的情况下都能工作。</li></ol><h2 id="2-5-处理器模式"><a href="#2-5-处理器模式" class="headerlink" title="2.5. 处理器模式"></a>2.5. 处理器模式</h2><ol><li>计算机通过设置处理器模式实现特权指令管理</li><li>计算器一般设置0、1、2、3等四种运行模式(保护级别)<ul><li>0:内核级，操作系统内核，可以执行全部指令，包括中断处理、处理I&#x2F;O操作等命令</li><li>1:系统调用级，执行系统调用，获得特定的和受保护的程序服务</li><li>2:共享库级，可以多个运行进程共享，允许调用库函数，读取但不修改相关数据。</li><li>3:用户程序，只能执行非特权指令，收到的保护最少</li></ul></li><li>0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集</li><li>一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式</li><li>处理器模式是由处理器模式位决定的。</li></ol><h2 id="2-6-处理器模式切换"><a href="#2-6-处理器模式切换" class="headerlink" title="2.6. 处理器模式切换"></a>2.6. 处理器模式切换</h2><ol><li>简称模式切换，包括<code>用户模式-&gt;内核模式</code>和<code>内核模式-&gt;用户模式</code>的两种切换。</li><li><strong>中断、异常或系统异常</strong>等事件导致用户程序向OS内核切换，触发：<code>用户模式-&gt;内核模式</code>，以下三种方式是唯一能触发的方式:<ol><li>程序请求操作系统服务，执行系统调用</li><li>程序运行时发生异常(如发生程序性中断，或者目态执行特权指令)</li><li>程序运行时发生并响应中断(一般是I&#x2F;O中断)</li></ol></li><li>我们可以认为中断和异常是用户态到内核态转换的仅有途径。</li><li>OS内核处理完成后，调用中断返回指令(如Intel的iret)触发：<code>内核模式-&gt;用户模式</code>，操作系统将控制权转交给应用进程。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/31.png"></p><h2 id="2-7-系统调用示例"><a href="#2-7-系统调用示例" class="headerlink" title="2.7. 系统调用示例"></a>2.7. 系统调用示例</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/29.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/30.png"></th></tr></thead></table><h1 id="3-栈空间"><a href="#3-栈空间" class="headerlink" title="3. 栈空间"></a>3. 栈空间</h1><h2 id="3-1-用户栈"><a href="#3-1-用户栈" class="headerlink" title="3.1. 用户栈"></a>3.1. 用户栈</h2><ol><li>用户栈是<strong>用户进程</strong>空间中开辟的一块区域，用于保存应用程序的子程序(函数)间相互调用的参数、返回值、返回点以及子程序的局部变量。</li><li>如果只有用户栈，没有核心栈，那么操作系统则很难对核心栈的数据提供相应的保护措施。</li></ol><h2 id="3-2-核心栈"><a href="#3-2-核心栈" class="headerlink" title="3.2. 核心栈"></a>3.2. 核心栈</h2><ol><li>核心栈也叫系统栈或内核栈，是内存中属于操作系统空间的一块区域，其用途包含以下两种:<ol><li>保存中断现场，嵌套中断</li><li>保存操作系统程序(函数)间相互调用的参数、返回值、返回点以及程序局部变量。</li></ol></li><li><strong>每个进程</strong>有一个核心栈:可读可写不可执行，大小有限</li><li>硬件栈指针只有一个</li></ol><h1 id="4-中断"><a href="#4-中断" class="headerlink" title="4. 中断"></a>4. 中断</h1><p><a href="https://blog.csdn.net/yusiguyuan/article/details/23517819">(21条消息) linux内核分析–中断的分类_鱼思故渊的博客-CSDN博客</a></p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/image-20230313103109912-1680145370392.png" alt="image-20230313103109912"></p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/image-20230313103143600-1680145370393.png" alt="image-20230313103143600"></p><h2 id="4-1-中断、异常和系统异常"><a href="#4-1-中断、异常和系统异常" class="headerlink" title="4.1. 中断、异常和系统异常"></a>4.1. 中断、异常和系统异常</h2><ol><li><strong>广义的中断</strong>是指程序执行过程中，遇到急需处理的事件时，暂时<strong>中止CPU</strong>上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程</li><li><strong>狭义的中断</strong>指来源于<strong>处理器之外的中断事件</strong>，即与当前运行指令无关的中断事件，如I&#x2F;O中断(为打印机结束后进行善后)、时钟中断(计算机系统计时，多一段时间就要更新系统时间)、外部信号中断(关机)等</li><li><strong>异常</strong>指<strong>当前运行指令引起的中断事件</strong>，如地址异常(访问其他程序的内存、读写没有权利读写的内存、虚拟地址的异常)、算术异常(数字溢出、对0除法)、处理器硬件故障(奇偶校验位错误)等</li><li><strong>来自于CPU内部的广义中断事件</strong>我们称之为<strong>异常</strong>，和狭义的中断构成了广义的中断。</li><li><strong>系统异常</strong>指<strong>执行陷入指令而触发系统调用引起的中断事件</strong>，如请求设备、请求I&#x2F;O、创建进程等，与硬件无关(通过系统异常请求服务)，系统异常可以被认为是异常中的一类</li></ol><h2 id="4-2-操作系统与中断"><a href="#4-2-操作系统与中断" class="headerlink" title="4.2. 操作系统与中断"></a>4.2. 操作系统与中断</h2><ol><li>操作系统是<strong>中断驱动</strong>的；换言之，<strong>中断是激活操作系统的唯一方式</strong>。</li><li>操作系统要求计算机硬件系统为其设置相应的<strong>中断激活的硬件机制</strong>，再配合操作系统的内核程序共同完成中断驱动方式，这个是操作系统实现的<strong>最根本的基础</strong>，中断处理需要借助硬件电路</li></ol><h2 id="4-3-中断源分类"><a href="#4-3-中断源分类" class="headerlink" title="4.3. 中断源分类"></a>4.3. 中断源分类</h2><p>由硬件发出或产生的中断称为硬中断，按硬中断事件的来源和实现手段可将终端划分为外中断和内中断。</p><h3 id="4-3-1-外中断"><a href="#4-3-1-外中断" class="headerlink" title="4.3.1. 外中断"></a>4.3.1. 外中断</h3><ol><li>外中断又称中断或异步中断，是指来自处理器之外的中断信号，包括时钟中断、键盘中断、它机中断和外部设备等、</li><li>外中断又可以分为可屏蔽中断和不可屏蔽中断，各个中断具有不同中断优先级。</li></ol><h3 id="4-3-2-内中断"><a href="#4-3-2-内中断" class="headerlink" title="4.3.2. 内中断"></a>4.3.2. 内中断</h3><ol><li>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于程序执行过程中，发现与当前指令相关的、不正常或错误的时间，内中断可分为:<ol><li>访管中断，由执行系统调用而引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点溢出等。</li></ol></li></ol><h2 id="4-4-中断和异常区别-P60"><a href="#4-4-中断和异常区别-P60" class="headerlink" title="4.4. 中断和异常区别(P60)"></a>4.4. 中断和异常区别(P60)</h2><table><thead><tr><th>中断</th><th>异常</th></tr></thead><tbody><tr><td>CPU异步</td><td>CPU同步</td></tr><tr><td>内核态、用户态</td><td>大部分在用户态，内核态唯一的异常是”缺页异常”</td></tr><tr><td>一般中断处理程序提供的服务不是当前进程需要的</td><td>是当前的进程需要的</td></tr><tr><td>快速处理，不可以被打断</td><td>可以被阻塞</td></tr><tr><td>允许嵌套</td><td>大多为一重等</td></tr><tr><td>不可以被异常打断</td><td>可以被中断中断</td></tr></tbody></table><h1 id="5-中断事件处理原则"><a href="#5-中断事件处理原则" class="headerlink" title="5. 中断事件处理原则"></a>5. 中断事件处理原则</h1><h2 id="5-1-中断源-处理器硬件故障中断事件-硬中断"><a href="#5-1-中断源-处理器硬件故障中断事件-硬中断" class="headerlink" title="5.1. 中断源:处理器硬件故障中断事件(硬中断)"></a>5.1. 中断源:处理器硬件故障中断事件(硬中断)</h2><ol><li>由处理器、内存储器、总线等硬件故障引起，除了极少类的校验错误可以恢复以外，是<strong>非常严重</strong>的中断。</li><li>处理原则为：保护现场，停止设备，停止CPU，向操作员报告，等待人工干预</li><li>电脑会配置一个小电容保证尽可能较少硬件损伤</li></ol><h2 id="5-2-中断源-程序性中断事件"><a href="#5-2-中断源-程序性中断事件" class="headerlink" title="5.2. 中断源:程序性中断事件"></a>5.2. 中断源:程序性中断事件</h2><blockquote><p>处理器执行机器指令引起</p></blockquote><ol><li>语法错误：由编译程序发现</li><li>逻辑错误：由测试程序发现</li><li>程序运行过程中产生异常<ol><li>除数为零、操作数溢出等算术异常：简单处理，报告用户；也可以由用户编写中断续元程序处理</li><li>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程</li><li>终止进程指令：终止进程</li><li>虚拟地址异常：指令和数据不在内存当中，调整内存后重新执行指令</li></ol></li></ol><h2 id="5-3-中断源-I-x2F-O中断事件"><a href="#5-3-中断源-I-x2F-O中断事件" class="headerlink" title="5.3. 中断源:I&#x2F;O中断事件"></a>5.3. 中断源:I&#x2F;O中断事件</h2><ol><li>来源于外围设备报告I&#x2F;O状态的中断事件<ol><li>I&#x2F;O完成：调整进程状态，释放等待进程</li><li>I&#x2F;O出错：先向设备发命令索取状态字，分析产生故障的确切原因，再执行复执或请求人工干预，</li><li>I&#x2F;O异常：等待人工干预，缺纸，人工加纸</li><li>设备报道或设备结束:表示有设备接入可供使用或设备断开暂停使用</li></ol></li><li>狭义中断事件</li></ol><h2 id="5-4-中断源-自愿性中断事件-访管中断"><a href="#5-4-中断源-自愿性中断事件-访管中断" class="headerlink" title="5.4. 中断源:自愿性中断事件(访管中断)"></a>5.4. 中断源:自愿性中断事件(访管中断)</h2><ol><li>处理器执行陷入指令请求OS服务引起；在操作系统中，它一般又被称作系统调用，比如请求分配外设、请求I&#x2F;O等等</li><li>处理流程是：<ol><li>程序执行访管指令，并通过适当方式指明系统调用号。</li><li>通过中断机制进入访管中断处理程序，现场信息被保护到<strong>核心栈</strong>，按功能号实现跳转。</li><li>通过系统调用入口地址表找到对应中断服务历程的入口地址</li><li>执行终端服务例程</li></ol></li></ol><h2 id="5-5-中断源-外部中断事件"><a href="#5-5-中断源-外部中断事件" class="headerlink" title="5.5. 中断源:外部中断事件"></a>5.5. 中断源:外部中断事件</h2><ol><li>由外围设备发出的信号引起的中断事件<ol><li>时钟中断、间隔时钟中断：记时与时间片处理，最常见</li><li>设备报到与结束中断：调整设备表</li><li>键盘&#x2F;鼠标信号中断：根据信号作出相应反应</li><li>关机&#x2F;重启动中断：写回文件，停止设备与CPU</li></ol></li><li>时钟可以分为绝对时钟和间隔时钟<ol><li>绝对时钟:固定周期发出中断请求</li><li>间隔时钟:每个时间切换点,将间隔时钟的内容减1，其值为0的时候，产生间隔时钟中断。</li></ol></li><li>时钟间隔定时器<ol><li>real:按照实际经过的时间计时</li><li>virtual:仅在用户态下执行才计时</li><li>profile:进程执行用户态或用户态时都计时，当计时到达发送信号</li></ol></li></ol><h1 id="6-中断系统"><a href="#6-中断系统" class="headerlink" title="6. 中断系统"></a>6. 中断系统</h1><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/image-20230313104119877-1680145370393.png" alt="image-20230313104119877"></p><ol><li>中断系统是计算机系统中响应和处理中断的系统，包括硬件子系统和软件子系统两部分<ol><li><strong>中断响应</strong>由硬件子系统完成</li><li><strong>中断处理</strong>由软件子系统完成</li></ol></li><li>中断系统是操作系统的基础，中断系统也是软硬件协同系统的典型例子</li></ol><h2 id="6-1-中断响应处理与指令执行周期"><a href="#6-1-中断响应处理与指令执行周期" class="headerlink" title="6.1. 中断响应处理与指令执行周期"></a>6.1. 中断响应处理与指令执行周期</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/11.png"></p><blockquote><p>在指令执行周期最后增加一个微操作，以响应中断，CPU在完成执行阶段后，如果允许中断，则进入中断阶段</p><p>注意是指令周期的最后检查中断</p></blockquote><h2 id="6-2-中断装置"><a href="#6-2-中断装置" class="headerlink" title="6.2. 中断装置"></a>6.2. 中断装置</h2><ol><li>计算机系统中<strong>发现并响应中断&#x2F;异常</strong>的硬件装置称为中断装置</li><li>由于中断源的多样性，硬件实现的中断装置有多种，分别处理不同类型的中断</li><li>这些中断装置因计算机而异，通常有：<ol><li>处理器外的中断：由<strong>中断控制器</strong>发现和响应</li><li>处理器内的异常：由<strong>指令的控制逻辑和实现线路</strong>发现和响应，相应机制称为<strong>陷阱</strong></li><li>请求OS服务的系统异常：处理器执行<strong>陷入指令</strong>时直接触发，相应机制称为<strong>系统陷阱</strong></li></ol></li></ol><h2 id="6-3-中断控制器"><a href="#6-3-中断控制器" class="headerlink" title="6.3. 中断控制器"></a>6.3. 中断控制器</h2><ol><li><strong>中断控制器</strong>：CPU中的一个控制部件，包括中断控制逻辑线路和中断寄存器，中断控制器会记录中断是<strong>来自哪里</strong><ol><li>狭义中断:(异步过程)外部设备向其发出中断请求IRQ，在中断寄存器中设置已发生的中断</li><li>(同步过程)指令处理结束前，会检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作的顺序，引出操作系统中的中断处理程序</li></ol></li><li>狭义中断是异步进程，CPU正在做的事情和中断可能是两个不同部分</li></ol><h2 id="6-4-陷阱与系统陷阱"><a href="#6-4-陷阱与系统陷阱" class="headerlink" title="6.4. 陷阱与系统陷阱"></a>6.4. 陷阱与系统陷阱</h2><blockquote><p>陷阱与系统陷阱：指令的逻辑和实现线路的一部分</p></blockquote><ol><li>执行指令出现异常后，会根据异常情况转向操作系统的异常处理程序</li><li>出现虚拟地址异常后，需要重新执行指令，往往越过陷阱独立设置页面异常处理程序</li><li>执行陷入指令后，越过陷阱处理，触发系统陷阱，激活系统调用处理程序</li></ol><h2 id="6-5-中断程序的处理-amp-中断-x2F-异常响应过程"><a href="#6-5-中断程序的处理-amp-中断-x2F-异常响应过程" class="headerlink" title="6.5. 中断程序的处理&amp;中断&#x2F;异常响应过程"></a>6.5. 中断程序的处理&amp;中断&#x2F;异常响应过程</h2><ol><li>中断处理程序：操作系统处理中断事件的控制程序, 主要任务是处理<strong>中断事件和恢复正常</strong>操作。</li><li>是一个软件过程</li><li>中断&#x2F;异常响应过程<ol><li>发现中断源，提出中断请求(选择响应哪一个程序)<ol><li>发现中断寄存器中记录的中断</li><li>决定这些中断是否被屏蔽</li><li>当有多个要响应的中断源时，根据规定的优先级选择一个</li></ol></li><li>中断当前程序的执行(保护现场):保存当前程序的PSW(程序状态字)&#x2F;PC到核心栈</li><li>转向操作系统的中断处理程序:处理器状态已从用户态转换至内核态。</li><li>恢复现场:恢复原运行程序的PSW，重新返回中断点，以便执行后续指令。</li></ol></li></ol><h2 id="6-6-恢复正常操作"><a href="#6-6-恢复正常操作" class="headerlink" title="6.6. 恢复正常操作"></a>6.6. 恢复正常操作</h2><ol><li>情况一：对于某些中断，在处理完毕后，直接返回刚刚被中断的进程，比如计时中断。</li><li>情况二：对于其他一些中断，需要中断当前进程的运行，调整进程队列，启动进程调度，选择下一个执行的进程并恢复其执行，比如请求输入输出。</li><li>无论是哪个都是从内核态到用户态。</li></ol><h2 id="6-7-中断系统处理流程"><a href="#6-7-中断系统处理流程" class="headerlink" title="6.7. 中断系统处理流程"></a>6.7. 中断系统处理流程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/12.png"></p><ol><li>硬件设计受到操作系统的要求。</li><li>操作系统:大型软件系统，大型紧密结合软硬件设备的系统。</li></ol><h1 id="7-多中断的响应与处理"><a href="#7-多中断的响应与处理" class="headerlink" title="7. 多中断的响应与处理"></a>7. 多中断的响应与处理</h1><h2 id="7-1-中断优先级"><a href="#7-1-中断优先级" class="headerlink" title="7.1. 中断优先级"></a>7.1. 中断优先级</h2><ol><li>当计算机同时检测到多个中断时, 中断装置响应中断的顺序。</li><li>有优先度的响应中断：将紧迫程度相当的中断源归为同一级别，将紧迫程度差距较大的中断源归为不同级别。</li><li>一种可能的处理次序：(对几十个人使用的大型计算机系统很合理)，可以借助软硬件分别来完成实现。<ol><li>处理机硬件故障中断事件。</li><li>自愿性中断事件。</li><li>程序性中断事件。</li><li>时钟中断等外部中断事件。</li><li>输入输出中断事件。</li><li>重启动和关机中断事件。</li></ol></li><li>不同类型的操作系统有不同的中断优先级:PC做出关机操作表示放弃当前的所有的操作，所以重启动和关机中断是优先级最高的中断。</li></ol><h2 id="7-2-中断屏蔽"><a href="#7-2-中断屏蔽" class="headerlink" title="7.2. 中断屏蔽"></a>7.2. 中断屏蔽</h2><ol><li>当计算机检测到中断时, 中断装置通过中断屏蔽位决定是否响应已发生的中断。</li><li>有选择的响应中断：由计算机决定。<ol><li>延迟或禁止某些中断的响应以避免共享数据结构受到破坏。</li><li>协调中断响应与终端处理的关系，保证优先级顺序。</li><li>防止同级中断互相干扰。</li></ol></li><li>计算机均配置可编程中断控制器。</li></ol><h2 id="7-3-中断的嵌套处理"><a href="#7-3-中断的嵌套处理" class="headerlink" title="7.3. 中断的嵌套处理"></a>7.3. 中断的嵌套处理</h2><ol><li>当计算机响应中断后，在中断处理过程中，可以再响应其他中断</li><li>操作系统是性能攸关的程序系统，且中断响应处理有硬件要求，考虑系统效率和实现代价问题，中断的嵌套处理应限制在一定层数内，如3层</li><li>中断的嵌套处理改变中断处理次序，<strong>先响应的有可能后处理</strong></li></ol><h2 id="7-4-多中断的响应与处理"><a href="#7-4-多中断的响应与处理" class="headerlink" title="7.4. 多中断的响应与处理"></a>7.4. 多中断的响应与处理</h2><blockquote><p>决定了中断处理次序的因素</p></blockquote><ol><li>中断<strong>屏蔽</strong>可以使中断装置不响应某些中断</li><li>中断<strong>优先级</strong>决定了中断装置响应中断的次序</li><li>中断可以<strong>嵌套</strong>处理, 但嵌套的层数应有限制</li><li>中断的嵌套处理改变了中断处理的次序</li></ol><h2 id="7-5-多重中断处理"><a href="#7-5-多重中断处理" class="headerlink" title="7.5. 多重中断处理"></a>7.5. 多重中断处理</h2><h3 id="7-5-1-顺序中断处理-串行处理"><a href="#7-5-1-顺序中断处理-串行处理" class="headerlink" title="7.5.1. 顺序中断处理(串行处理)"></a>7.5.1. 顺序中断处理(串行处理)</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/2.png"></p><blockquote><p>X、Y两个中断同时发生，如下图所以，系统先响应X，屏蔽Y，待X响应完成后，系统再响应并处理Y</p></blockquote><h3 id="7-5-2-嵌套中断处理-嵌套处理"><a href="#7-5-2-嵌套中断处理-嵌套处理" class="headerlink" title="7.5.2. 嵌套中断处理(嵌套处理)"></a>7.5.2. 嵌套中断处理(嵌套处理)</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/3.png"></p><blockquote><p>X、Y两个中断同时发生，根据中断有限级，先响应中断X，因为没有屏蔽Y，则响应并处理Y，处理Y完成后，再处理X。</p></blockquote><h3 id="7-5-3-即时处理"><a href="#7-5-3-即时处理" class="headerlink" title="7.5.3. 即时处理"></a>7.5.3. 即时处理</h3><ol><li>在运行中断处理程序时，如果出现程序性中断事件，在一般情况下，表明此时中断程序有异常，应对其立即响应并处理。</li></ol><h2 id="7-6-中断处理的例子：Linux内核处理流程"><a href="#7-6-中断处理的例子：Linux内核处理流程" class="headerlink" title="7.6. 中断处理的例子：Linux内核处理流程"></a>7.6. 中断处理的例子：Linux内核处理流程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/25.png"></p><ol><li>中断信号源:中断向量<ol><li>中断，分为所有外部设备产生的屏蔽中断请求，和硬件故障等紧迫时间引发的非屏蔽中断。</li><li>异常:CPU发出的中断信号，主要有故障、陷阱、终止和编程异常等</li></ol></li><li>更多见P66-71页</li></ol><h1 id="8-进程及其状态"><a href="#8-进程及其状态" class="headerlink" title="8. 进程及其状态"></a>8. 进程及其状态</h1><h2 id="8-1-进程的提出"><a href="#8-1-进程的提出" class="headerlink" title="8.1. 进程的提出"></a>8.1. 进程的提出</h2><ol><li>操作系统必须全方位地管理计算机系统中运行的程序。因此，操作系统为正在运行程序建立一个管理实体:<strong>进程</strong></li></ol><h2 id="8-2-进程的概念"><a href="#8-2-进程的概念" class="headerlink" title="8.2. 进程的概念"></a>8.2. 进程的概念</h2><ol><li><strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。<ol><li>具有一定独立功能的程序:进程是相对独立的</li><li>关于某个数据集合:对于不同数据集合的操作不是同一个进程。</li><li>一次运行活动:有生命周期</li></ol></li><li><strong>进程是操作系统进行资源分配和调度的一个独立单位</strong>:这只限于单线程单进程的情况下<ol><li>资源分配:除了CPU之外的资源的分配，比如内存和外设等</li><li>单线程情况下，进程的资源分配和调度就是处理器的。</li><li>调度特指处理器的调度</li></ol></li><li>有的将进程叫做process，Linux以及一些企业中，把进程称为Task。</li><li>进程可以看为可运行程序加载到内存，配合相应的数据集，在操作系统中的一个实例，程序可以多次被加载进入成为进程。</li></ol><h2 id="8-3-进程的属性"><a href="#8-3-进程的属性" class="headerlink" title="8.3. 进程的属性"></a>8.3. 进程的属性</h2><ol><li><strong>动态性</strong>:进程是程序在数据结合上的一次执行过程，是动态概念，同时它有声明周期，而程序是一组有序指令序列，是静态概念，所以程序作为系统中的一种资源是永久存在的。</li><li><strong>共享性</strong>:同一程序同时运行于不同数据集合上时都是不同的进程，即不同的进程可以运行相同的程序。</li><li><strong>独立性</strong>:每个进程是操作系统中的一个独立实体。有自己的虚存空间、程序计数器和内部状态.</li><li><strong>制约性</strong>:进程因共享资源或协同工作产生相互制约关系，造成进程执行速度的不可预测性，必须对进程的执行次序或相对执行速度予以协调。</li><li><strong>并发性</strong>:多个进程的执行在时间上可以重叠。</li></ol><h2 id="8-4-进程的组成"><a href="#8-4-进程的组成" class="headerlink" title="8.4. 进程的组成"></a>8.4. 进程的组成</h2><blockquote><p>一个进程包括五个实体部分，分别是：</p></blockquote><ol><li>(OS管理运行程序的)数据结构P</li><li>(运行程序的)内存代码C</li><li>(运行程序的)内存数据D</li><li>(运行程序的)通用寄存器信息R</li><li>(OS控制程序执行的)程序状态字信息PSW</li></ol><h2 id="8-5-单线程结构进程和多线程结构进程"><a href="#8-5-单线程结构进程和多线程结构进程" class="headerlink" title="8.5. 单线程结构进程和多线程结构进程"></a>8.5. 单线程结构进程和多线程结构进程</h2><ol><li>单线程结构进程:进程级别，负责完成资源分配和CPU调度。</li><li>多线程结构进程:线程级别，负责完成资源分配(进程完成)和CPU调度(代表一个执行流)，并且一个进程中可以包含很多线程。</li><li>操作系统最开始设计的时候并没有设计多线程。</li></ol><h2 id="8-6-进程举例"><a href="#8-6-进程举例" class="headerlink" title="8.6. 进程举例"></a>8.6. 进程举例</h2><ol><li>以下的程序与数据集都是内存级的。</li><li>不同时段针对同一个外存数据文件运行同一个外存程序文件意味着完全不同的(P, C, D, R, Psw)</li></ol><h3 id="8-6-1-无关进程"><a href="#8-6-1-无关进程" class="headerlink" title="8.6.1. 无关进程"></a>8.6.1. 无关进程</h3><p>不同程序在不同数据集上运行：构成两个无关进程</p><h3 id="8-6-2-共享数据的交往进程"><a href="#8-6-2-共享数据的交往进程" class="headerlink" title="8.6.2. 共享数据的交往进程"></a>8.6.2. 共享数据的交往进程</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/5.png"></p><blockquote><p>不同程序在相同数据集上运行：构成两个共享数据的交往进程</p></blockquote><h3 id="8-6-3-共享代码的无关进程"><a href="#8-6-3-共享代码的无关进程" class="headerlink" title="8.6.3. 共享代码的无关进程"></a>8.6.3. 共享代码的无关进程</h3><ol><li>相同代码在不同数据集上运行：构成两个共享代码的无关进程</li><li>共享的代码称为<strong>可再入</strong>程序，如编辑器<strong>可再入程序</strong>是<strong>纯代码</strong>的，可再入程序必须是纯代码的</li></ol><h3 id="8-6-4-共享代码和数据的进程"><a href="#8-6-4-共享代码和数据的进程" class="headerlink" title="8.6.4. 共享代码和数据的进程"></a>8.6.4. 共享代码和数据的进程</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/6.png"></p><blockquote><p>可以共享代码或者共享数据</p></blockquote><h1 id="9-进程状态和转换"><a href="#9-进程状态和转换" class="headerlink" title="9. 进程状态和转换"></a>9. 进程状态和转换</h1><h2 id="9-1-进程三态模型"><a href="#9-1-进程三态模型" class="headerlink" title="9.1. 进程三态模型"></a>9.1. 进程三态模型</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/7.png"></p><ol><li>只要操作系统支持多道程序设计，就必须要设计进程转换模型来管理，必须实现<strong>三个进程状态和四个跳转关系</strong>，进程状态转换一定有<strong>内核</strong>的参与。</li><li>运行被中断进程时需要找到被中断时的信息并恢复。</li></ol><h3 id="9-1-1-三种状态"><a href="#9-1-1-三种状态" class="headerlink" title="9.1.1. 三种状态"></a>9.1.1. 三种状态</h3><ol><li><strong>运行态</strong>:进程占有处理器正在运行的状态。</li><li><strong>就绪态</strong>:进程具备运行条件，等待系统分配处理器以便运行的状态，面向调度的，处理器只会挑选就绪态进程(就绪队列进程)</li><li><strong>等待态</strong>:又称阻塞态或睡眠态，指进程不具备运行条件，正在等待某个事件完成的状态，暂时被剥夺处理机会。</li><li>处于运行态个数不能大于处理器个数。</li><li>进程创建后一般是处于就绪态</li><li>单线程， 处理器的调度体现在(3)</li></ol><h3 id="9-1-2-四种状态转换"><a href="#9-1-2-四种状态转换" class="headerlink" title="9.1.2. 四种状态转换"></a>9.1.2. 四种状态转换</h3><ol><li>运行态$\rightarrow$等待态：等待资源、I&#x2F;O、信号量</li><li>等待态$\rightarrow$就绪态：资源满足、I&#x2F;O结束、信号量完成</li><li>运行态$\rightarrow$就绪态：运行时间片到(倒计时到，不缺少其他东西，只缺少CPU，退回就绪态)、有更高优先权进程，低级调度问题</li><li>以上四个状态转换，一个不能少，一个也不能多，其他的转换不存在的原因如下：<ol><li>没有就绪态到等待态:到等待态需要内核参与。</li><li>没有等待态到运行态:等待的资源还没有就绪，无法进入运行态。</li></ol></li></ol><h3 id="9-1-3-时间片与进程转换"><a href="#9-1-3-时间片与进程转换" class="headerlink" title="9.1.3. 时间片与进程转换"></a>9.1.3. 时间片与进程转换</h3><ol><li>时间片用完，计算没有做完，被抢占的进程<code>运行态-&gt;就绪态</code>：启动内核的处理器调度算法.</li><li>时间片内，用户进程发生中断或系统调用，<code>运行态-&gt;等待态</code></li><li>时间片内，用户进程完成全部计算完成退出系统，<code>运行态-&gt;终止态</code>，激活内核，时间片被撤销。</li></ol><h3 id="9-1-4-进程三态模型总结与扩展"><a href="#9-1-4-进程三态模型总结与扩展" class="headerlink" title="9.1.4. 进程三态模型总结与扩展"></a>9.1.4. 进程三态模型总结与扩展</h3><ol><li>进程映像定义其数据结构和存储结构</li><li>状态转化模型(队列模型)定义其生命周期和状态转换</li><li>然后围绕以上两部分开发出相应的操作和算法</li><li>进程状态和模型与信号量同样相关，后续深入讨论。</li></ol><h2 id="9-2-进程七态模型-P74"><a href="#9-2-进程七态模型-P74" class="headerlink" title="9.2. 进程七态模型(P74)"></a>9.2. 进程七态模型(P74)</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/26.png"></p><h3 id="9-2-1-新添加的状态"><a href="#9-2-1-新添加的状态" class="headerlink" title="9.2.1. 新添加的状态"></a>9.2.1. 新添加的状态</h3><ol><li><strong>新建态</strong>:对应于进程被创建的状态，尚未进入就绪队列，创建进程的两个步骤<ol><li>为新进程分配所需资源和建立必要的管理信息</li><li>设置进程为就绪态，等待被调度执行</li></ol></li><li>终止态:<ol><li>进程完成认为到达正常结束点</li><li>出现无法克服的错误而异常终止</li><li>操作系统及有终止权的进程所终止时所处的状态，处于终止态的进程不再被调度执行</li><li>下一步就将被系统撤销，最终从系统中消失。</li></ol></li><li>挂起就绪态:表明进程具备运行条件，但目前在外存中，只有它被对换到内存才能调度执行。</li><li>挂起等待态:表明进程正在等待某一个事件发生且在外存中。</li></ol><h3 id="9-2-2-进程挂起的源头"><a href="#9-2-2-进程挂起的源头" class="headerlink" title="9.2.2. 进程挂起的源头"></a>9.2.2. 进程挂起的源头</h3><ol><li>到目前为止:随着不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起，对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度，起到平滑系统负荷的目的；也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再接触挂起并恢复进程运行。</li><li>进程挂起的原因是多种多样的。</li></ol><h2 id="9-3-进程挂起"><a href="#9-3-进程挂起" class="headerlink" title="9.3. 进程挂起"></a>9.3. 进程挂起</h2><h3 id="9-3-1-进程挂起的概念"><a href="#9-3-1-进程挂起的概念" class="headerlink" title="9.3.1. 进程挂起的概念"></a>9.3.1. 进程挂起的概念</h3><ol><li>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况</li><li>运行资源不足表现为<strong>性能低</strong>和<strong>死锁</strong>两种情况。</li><li>解决办法：剥夺某些进程的<strong>内存及其他资源</strong>，调入OS管理的<strong>对换区</strong>，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行，这就是<strong>进程挂起</strong></li><li>挂起态与等待态有着本质区别<ol><li>进程挂起:<strong>没有任何资源</strong></li><li>进程等待:<strong>占有已申请到的资源处于等待</strong></li></ol></li><li>结束挂起状态的命令只能由<strong>操作系统和父进程</strong>发出。</li></ol><h3 id="9-3-2-进程挂起的选择与恢复"><a href="#9-3-2-进程挂起的选择与恢复" class="headerlink" title="9.3.2. 进程挂起的选择与恢复"></a>9.3.2. 进程挂起的选择与恢复</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/8.png"></p><ol><li>挂起的选择：<ol><li>一般选择<strong>等待态</strong>进程进入<strong>挂起等待态</strong></li><li>也可选择<strong>就绪态</strong>进程进入<strong>挂起就绪态</strong></li><li><strong>运行态</strong>进程还可以挂起自己</li></ol></li><li>挂起的恢复<ol><li>等待事件结束后，<strong>挂起等待态</strong>进入<strong>挂起就绪态</strong></li><li>一般选择<strong>挂起就绪态</strong>进程予以恢复</li><li>操作系统极其空闲才会选择调入<strong>挂起等待态</strong>的进程</li></ol></li></ol><h3 id="9-3-3-挂起进程的特点"><a href="#9-3-3-挂起进程的特点" class="headerlink" title="9.3.3. 挂起进程的特点"></a>9.3.3. 挂起进程的特点</h3><ol><li>进程不能被立即执行</li><li>进程可能会有等待事件，但是等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li><li>由于操作系统、父进程或进程自身阻止其运行</li></ol><h2 id="9-4-补充：SVR4-进程状态模型"><a href="#9-4-补充：SVR4-进程状态模型" class="headerlink" title="9.4. 补充：SVR4 进程状态模型"></a>9.4. 补充：SVR4 进程状态模型</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/33.png"></p><blockquote><p>preempted:抢占，虚线表示合为一体。</p></blockquote><h1 id="10-进程的描述与组成"><a href="#10-进程的描述与组成" class="headerlink" title="10. 进程的描述与组成"></a>10. 进程的描述与组成</h1><p>进程的设计时要考虑进程的声明周期，从而引入三态模型</p><h2 id="10-1-进程映像，Process-Image"><a href="#10-1-进程映像，Process-Image" class="headerlink" title="10.1. 进程映像，Process Image"></a>10.1. 进程映像，Process Image</h2><ol><li>某一时刻进程的内容及其执行状态集合：<ol><li>进程控制块: 每个进程捆绑一个，保存进程的标识信息、现场信息和控制信息。进程创建时创建进程控制块，进程撤销时回收进程控制块，与进程一一对应。</li><li>进程程序块: 进程执行的程序空间，规定进程一次运行所应完成的功能。</li><li>进程数据块: 进程处理的数据空间，是进程的私有地址空间，包括各类私有数据、处理函数的用户栈和可修改的程序</li><li>进程核心栈: 每个进程捆绑一个，进程在<strong>内核模式</strong>下运行时使用的堆栈，中断或系统过程使用，保存函数调用的参数、局部变量和返回地址等。</li></ol></li><li>进程运行时如果遇到要执行操作系统内核函数，此时则保存应用程序的全部现场信息及其用户栈，使其不被内核程序破坏。而内核函数运行时使用进程的核心栈来放置工作信息。</li><li>进程映像是<strong>内存级</strong>的物理实体，又称为进程的内存映像</li><li>进程的内存映像示意图</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/14.png"></p><h2 id="10-2-进程控制块，Process-Control-Block，PCB，又称进程描述符"><a href="#10-2-进程控制块，Process-Control-Block，PCB，又称进程描述符" class="headerlink" title="10.2. 进程控制块，Process Control Block，PCB，又称进程描述符"></a>10.2. 进程控制块，Process Control Block，PCB，又称进程描述符</h2><ol><li>进程控制块PCB是OS用于记录和刻画<strong>进程状态及环境信息</strong>的数据结构，是进程存在的唯一标识，是操作系统刻画进程的执行状态及环境信息的数据结构，是进程动态特征的汇集，是操作系统掌握进程的唯一资料结构和进程调度的主要依据</li><li>包括标识信息、现场信息和控制信息。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/13.png"></p><h3 id="10-2-1-标识信息"><a href="#10-2-1-标识信息" class="headerlink" title="10.2.1. 标识信息"></a>10.2.1. 标识信息</h3><blockquote><p>用于存放唯一标识该进程的信息</p></blockquote><ol><li>系统分配的标识号</li><li>系统分配的进程组标识号</li><li>用户定义的进程名</li><li>用户定义的进程组名</li></ol><h3 id="10-2-2-现场信息"><a href="#10-2-2-现场信息" class="headerlink" title="10.2.2. 现场信息"></a>10.2.2. 现场信息</h3><blockquote><p>用于存放该进程运行时的处理器现场信息</p></blockquote><ol><li>用户可见寄存器内容：数据寄存器、地址寄存器</li><li>控制与状态寄存器内容：PC、IR、PSW</li><li>栈指针内容：核心栈与用户栈指针</li></ol><h3 id="10-2-3-控制信息"><a href="#10-2-3-控制信息" class="headerlink" title="10.2.3. 控制信息"></a>10.2.3. 控制信息</h3><blockquote><p>用于存放与管理、调度进程相关的信息</p></blockquote><ol><li>调度相关信息：状态、等待事件&#x2F;原因、优先级</li><li>进程组成信息：代码&#x2F;数据地址、外存映像地址</li><li>队列指引元：进程队列指针、父子兄弟进程指针</li><li>通信相关信息：消息队列、信号量、锁</li><li>进程特权信息：如内存访问权限、处理器特权</li><li>处理器使用信息：占用的处理器、时间片、处理器使用时间&#x2F;已执行总时间、记账信息</li><li>资源清单信息：如正占有的资源、已使用的资源</li></ol><h2 id="10-3-进程上下文，Process-context"><a href="#10-3-进程上下文，Process-context" class="headerlink" title="10.3. 进程上下文，Process context"></a>10.3. 进程上下文，Process context</h2><ol><li>进程的执行需要环境支持，包括CPU现场和Cache中的执行信息。</li><li>在操作系统中，进程物理实体和支持进程运行的环境合称<strong>进程上下文</strong>。</li><li>OS中的进程物理实体和支持进程运行的环境合成进程上下文，包括以下：<ol><li>用户级上下文：<ol><li>用户程序块(可执行的机器指令序列)</li><li>用户数据区(进程可访问的信息)</li><li>用户栈(存放函数调用过程中的信息)</li><li>用户共享内存(进程通信使用的内存区)</li><li>对换至磁盘的分段或页面仍然是用户级上下文的组成部分。</li></ol></li><li>寄存器上下文(存储在进程控制块中)：<ol><li>处理器状态寄存器(进程当前状态)</li><li>指令计数器(下一条该执行的指令地址)</li><li>PSW&#x2F;栈指针(指向用户栈或核心栈当前地址)</li><li>通用寄存器等</li></ol></li><li>系统级上下文<ol><li>PCB(Process Control Block，进程的状态)</li><li>内存区管理信息(进程页表或段表)</li><li>核心栈(进程内核态运行时的工作区)</li></ol></li></ol></li><li>进程上下文刻画了进程的执行情况</li></ol><h2 id="10-4-进程队列及其管理"><a href="#10-4-进程队列及其管理" class="headerlink" title="10.4. 进程队列及其管理"></a>10.4. 进程队列及其管理</h2><ol><li>进程队列分类<ol><li>运行队列：通常只有一个进程</li><li>等待(阻塞)队列:也是有机会被调入，他等待的资源或事件完成后，调入就绪队列。</li><li>就绪队列:从就绪队列中挑选进程调入运行，按照优先级或FCFS的原则排队</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/9.png"></p><blockquote><p>最后通过系统调用结束处理，进程实现的队列模型不适合使用堆栈(堆栈是先进后出的)</p></blockquote><ol start="2"><li>进程队列组织方式<ol><li>链接方式：采用单向链接或双向链接。</li><li>索引方式：利用索引表记录不同状态进程的PCB地址或在PCB表中的编号</li><li>核心是完成入队和出队操作</li><li>进程与资源调度围绕进程队列展开</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/32.png"></p><h1 id="11-进程的管理"><a href="#11-进程的管理" class="headerlink" title="11. 进程的管理"></a>11. 进程的管理</h1><h2 id="11-1-概念级的OS进程管理软件"><a href="#11-1-概念级的OS进程管理软件" class="headerlink" title="11.1. 概念级的OS进程管理软件"></a>11.1. 概念级的OS进程管理软件</h2><blockquote><p>关键的进程管理软件包括：</p></blockquote><ol><li>系统调用&#x2F;中断&#x2F;异常处理程序:</li><li>队列管理模块:操作系统用来管理进程控制块的信息，核心程序包，是操作系统实现进程管理的核心模块</li><li>进程控制程序:操作系统用于控制进程状态转换用到的程序包</li><li>进程调度程序(独立进程居多)</li><li>进程通信程序(多个程序包)</li><li>终端登录与作业控制程序、性能监控程序、审计程序等外围程序</li></ol><h2 id="11-2-部分进程管理原语-P81"><a href="#11-2-部分进程管理原语-P81" class="headerlink" title="11.2. 部分进程管理原语(P81)"></a>11.2. 部分进程管理原语(P81)</h2><ol><li><strong>进程创建</strong>：<ol><li>操作系统初始启动时会创建承担系统资源分配和控制管理的一些系统进程，同时会创建一个所有用户集成的祖先，其他用户进程实在用户程序被提价与选中运行时被创建的。</li><li>操作系统通常将创建关系通过父子进程的关系来表示。</li><li>创建原语：进程表加一项、申请PCB(进程控制块)并初始化、生成唯一进程标识、建立进程映像、分配各种资源、移入就绪队列、通知操作系统某些模块</li></ol></li><li><strong>进程撤销</strong>：<ol><li>完成特定工作或出现严重错误后需要撤销，分为正常撤销和非正常撤销。</li><li>产生原因：运行结束、执行非法指令、用户态执行特权指令、时间配额到、等待时间超时、越界错误、共享内存区非法使用、程序性故障等。</li><li>撤销原语：从队列中移除、归还资源、撤销标识、回收PCB、移除进程表项</li></ol></li><li><strong>进程阻塞</strong>：<ol><li>使得进程让出处理器转而等待一个事件，比如等待资源等，阻塞是同步时间。</li><li>阻塞原语：保存现场信息、修改PCB、移入等待队列、调度其他进程执行</li></ol></li><li><strong>进程唤醒</strong>：<ol><li>等待时间完成时产生一个中断，激活操作系统，在系统的控制下将被阻塞进程唤醒</li><li>唤醒原语：等待队列中移出、修改PCB、移入就绪队列(该进程优先级高于运行进程触发抢占)</li></ol></li><li><strong>进程挂起</strong>：<ol><li>出现引起挂起的事件时，系统或进程会利用挂起原语把指定进程或处于等待态的进程挂起。</li><li>挂起原语：修改状态并出入相关队列、收回内存等资源送至对换区。</li><li>挂起原语可以由进程自己或其他进程调起。</li></ol></li><li><strong>进程激活</strong>：<ol><li>当系统资源尤其是内存资源充裕或请求激活进程时，系统或相关进程会调用激活原语将指定进车行激活。</li><li>激活原语：分配内存，修改状态并出入相关队列。</li><li>激活原语只能由其他进程调用。</li></ol></li><li>其他：如修改进程特权，以上是一个进程控制的流程</li></ol><h2 id="11-3-原语与进程控制原语-Primitive"><a href="#11-3-原语与进程控制原语-Primitive" class="headerlink" title="11.3. 原语与进程控制原语(Primitive)"></a>11.3. 原语与进程控制原语(Primitive)</h2><ol><li>进程控制过程中<strong>涉及对OS核心数据结构</strong>(进程表&#x2F;PCB池&#x2F;队列&#x2F;资源表)的修改，不是进程处理的所有指令都是。</li><li>为防止与时间有关的错误，应使用<strong>原语</strong></li><li><strong>原语是由若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性</strong>(保证对核心资源的访问是正确的，原语涉及到的资源都是共享核心资源，只能是唯一的)，进入原语区间，立刻关闭中断完成，然后再开中断响应。</li><li>原语的执行可以通过<strong>关中断实现</strong>，进程控制使用的原语被称为<strong>进程控制原语</strong>，另一类常用原语是<strong>进程通信原语</strong></li></ol><h2 id="11-4-进程切换与模式切换-状态转换"><a href="#11-4-进程切换与模式切换-状态转换" class="headerlink" title="11.4. 进程切换与模式切换(状态转换)"></a>11.4. 进程切换与模式切换(状态转换)</h2><h3 id="11-4-1-进程切换"><a href="#11-4-1-进程切换" class="headerlink" title="11.4.1. 进程切换"></a>11.4.1. 进程切换</h3><ol><li>进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行</li><li>进程切换实质上就是被中断运行进程与待运行进程的上下文切换。</li><li>进程切换必然发生在内核态而非用户态。</li></ol><h3 id="11-4-2-进程切换的工作过程"><a href="#11-4-2-进程切换的工作过程" class="headerlink" title="11.4.2. 进程切换的工作过程"></a>11.4.2. 进程切换的工作过程</h3><ol><li>(中断&#x2F;异常等触发)正向模式切换并压入PSW&#x2F;PC</li><li>保存被中断进程的现场信息</li><li>处理具体中断&#x2F;异常</li><li>把被<strong>中断进程</strong>的系统堆栈指针SP值保存到PCB</li><li>调整被中断进程的PCB信息，如进程状态</li><li>把被中断进程的<strong>PCB</strong>加入相关队列</li><li>选择下一个占用CPU运行的进程</li><li>修改被选中进程的PCB信息，如进程状态</li><li>设置被选中进程的地址空间，恢复存储管理信息</li><li>恢复被选中进程的SP值到处理器寄存器SP</li><li>恢复被选中进程的现场信息进入处理器</li><li>(中断返回指令触发)逆向模式转换并弹出PSW&#x2F;PC</li></ol><h3 id="11-4-3-进程切换的发生时机"><a href="#11-4-3-进程切换的发生时机" class="headerlink" title="11.4.3. 进程切换的发生时机"></a>11.4.3. 进程切换的发生时机</h3><blockquote><p>进程切换一定发生在<strong>中断&#x2F;异常&#x2F;系统调用处理</strong>过程中，常见的情况是：</p></blockquote><ol><li>阻塞式系统调用、虚拟地址异常导致被中断进程进入等待态</li><li>时间片中断、I&#x2F;O中断后发现更高优先级进程，导致被中断进程转入就绪态</li><li>终止用系统调用、不能继续执行的异常导致被中断进程进入终止态</li></ol><h3 id="11-4-4-内核不能执行调度和切换的情况"><a href="#11-4-4-内核不能执行调度和切换的情况" class="headerlink" title="11.4.4. 内核不能执行调度和切换的情况"></a>11.4.4. 内核不能执行调度和切换的情况</h3><ol><li>内核正在处理中断的过程中</li><li>进程运行在内核临界区</li><li>内核处在需要屏蔽中断的原子操作过程中。</li></ol><h3 id="11-4-5-模式切换-状态转换"><a href="#11-4-5-模式切换-状态转换" class="headerlink" title="11.4.5. 模式切换(状态转换)"></a>11.4.5. 模式切换(状态转换)</h3><ol><li>进程切换必须在操作系统内核模式下完成，这就需要用到模式切换。</li><li>模式切换又称处理器状态切换，包括：<ol><li>用户模式到内核模式由<strong>中断&#x2F;异常&#x2F;系统调用</strong>中断用户进程执行而触发</li><li>内核模式到用户模式OS执行<strong>中断返回指令</strong>将控制权交还用户进程而触发</li></ol></li></ol><h3 id="11-4-6-模式切换-状态转换-的基本工作任务"><a href="#11-4-6-模式切换-状态转换-的基本工作任务" class="headerlink" title="11.4.6. 模式切换(状态转换)的基本工作任务"></a>11.4.6. 模式切换(状态转换)的基本工作任务</h3><ol><li>中断装置完成正向模式切换，包括：<ol><li>处理器模式转为内核模式</li><li>保存当前进程的PC&#x2F;PSW值到核心栈</li><li>转向中断&#x2F;异常&#x2F;系统调用处理程序</li></ol></li><li>中断返回指令完成逆向模式转换，包括：<ol><li>从<strong>待运行进程核心栈</strong>中弹出PSW&#x2F;PC值</li><li>处理器模式转为用户模式</li></ol></li></ol><h3 id="11-4-7-模式切换-状态转换-的处理器情况"><a href="#11-4-7-模式切换-状态转换-的处理器情况" class="headerlink" title="11.4.7. 模式切换(状态转换)的处理器情况"></a>11.4.7. 模式切换(状态转换)的处理器情况</h3><ol><li>用户空间中，处于进程上下文，应用进程在用户态下运行，使用用户栈。</li><li>内核空间中，处于进程上下文，内核代表进程在内核态下运行，使用核心栈。</li><li>内核空间中，处于中断上下文，与任何进程无关，中断服务例程在内核态下处理特定中断。</li><li>内核空间中，内核线程(无用户地址空间的进程)运行于内核态。</li></ol><h3 id="11-4-8-进程切换与模式切换-状态转换"><a href="#11-4-8-进程切换与模式切换-状态转换" class="headerlink" title="11.4.8. 进程切换与模式切换(状态转换)"></a>11.4.8. 进程切换与模式切换(状态转换)</h3><ol><li>一些中断&#x2F;异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：<ol><li>(中断&#x2F;异常触发)正向模式切换压入PSW&#x2F;PC</li><li>保存被中断进程的现场信息</li><li>处理中断&#x2F;异常</li><li>恢复被中断进程的现场信息</li><li>(中断返回指令触发)逆向模式转换弹出PSW&#x2F;PC</li></ol></li><li>比如计时中断，中断处理完成后直接恢复</li><li>模式切换是进程仍在自己的上下文进行处理，仅仅是处理器状态发生了变化，内核仍然被中断进程的上下文中进行处理。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/80.png"></p><h1 id="12-多线程技术概述"><a href="#12-多线程技术概述" class="headerlink" title="12. 多线程技术概述"></a>12. 多线程技术概述</h1><ol><li>最开始设计进程的时候并没有体现线程的概念</li></ol><h2 id="12-1-单线程结构"><a href="#12-1-单线程结构" class="headerlink" title="12.1. 单线程结构"></a>12.1. 单线程结构</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/10.png"></p><blockquote><p>传统进程是单线程结构进程</p></blockquote><h3 id="12-1-1-单线程结构进程的问题"><a href="#12-1-1-单线程结构进程的问题" class="headerlink" title="12.1.1. 单线程结构进程的问题"></a>12.1.1. 单线程结构进程的问题</h3><blockquote><p>单线程结构进程在并发程序设计上存在的问题</p></blockquote><ol><li>进程<strong>切换</strong>开销大:10个人干100天的活动-&gt;开会等活动产生的开销，进程切换要进行模式切换，然后再启动进程调度，选择一个就绪进程占用处理器，恢复现场，然后再反向进行。</li><li>进程<strong>通信</strong>开销大:指令流如果分布在不同进程中，那么每次交互都需要由内核完成。</li><li>限制了进程<strong>并发的粒度</strong>:如果没有线程概念，那么进程中本身不可以并发，粒度比较高</li><li>降低了<strong>并行计算的效率</strong></li></ol><h3 id="12-1-2-解决问题的思路"><a href="#12-1-2-解决问题的思路" class="headerlink" title="12.1.2. 解决问题的思路"></a>12.1.2. 解决问题的思路</h3><ol><li>把进程的两项功能分离开来<ol><li>独立分配资源(进程概念上)，进程作为系统资源分配和保护的<strong>独立单位</strong>，不需要频繁地切换</li><li>被调度分派执行(线程概念上)，线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换</li></ol></li><li>线程的出现会减少进程并发执行所付出的时空开销，使得并发粒度更细、并发性更好</li><li>两项功能绑定就是单线程进程，两项功能分离就是多线程进程。</li></ol><h2 id="12-2-多线程结构进程"><a href="#12-2-多线程结构进程" class="headerlink" title="12.2. 多线程结构进程"></a>12.2. 多线程结构进程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/15.png"></p><h3 id="12-2-1-多线程环境下进程的概念"><a href="#12-2-1-多线程环境下进程的概念" class="headerlink" title="12.2.1. 多线程环境下进程的概念"></a>12.2.1. 多线程环境下进程的概念</h3><ol><li>在多线程环境中，进程是操作系统中除处理器以外的资源分配和保护的<strong>独立单位</strong>。具有:<ol><li>用来容纳进程映像的虚拟地址空间</li><li>对进程、文件和设备的存取保护机制</li></ol></li></ol><h3 id="12-2-2-多线程环境下线程的概念"><a href="#12-2-2-多线程环境下线程的概念" class="headerlink" title="12.2.2. 多线程环境下线程的概念"></a>12.2.2. 多线程环境下线程的概念</h3><ol><li>线程是进程能够并发执行的实体，是进程的组成单位，也是处理器调度和分派的基本单位。</li><li>进程是一条执行路径，有独立的程序计数器，未运行时保护线程上下文。</li><li>同一个进程中的所有线程共享进程获得的主存空间和资源。它具有：<ol><li>线程执行状态</li><li>受保护的线程上下文，当线程不运行时，用于存储现场信息</li><li>独立的程序指令计数器</li><li>执行堆栈</li><li>容纳局部变量的静态存储器</li><li>线程控制块</li></ol></li></ol><h3 id="12-2-3-多线程结构进程中的进程与线程"><a href="#12-2-3-多线程结构进程中的进程与线程" class="headerlink" title="12.2.3. 多线程结构进程中的进程与线程"></a>12.2.3. 多线程结构进程中的进程与线程</h3><ol><li>于是，进程可以分为两部分:<ol><li>资源集合</li><li>线程集合。</li></ol></li><li>进程要支撑线程运行，为线程提供虚拟地址空间和各种资源。</li><li>进程封装管理信息，包括对指令代码、全局数据、打开的文件和信号量等共享部分的管理。</li><li>线程封装执行信息，包括状态信息、寄存器、执行栈（用户栈指针与核心栈指针）和局部变量、过程调用参数、返回值等私有部分的管理。</li><li>由于线程具有传统进程的许多特征，所以也把线程称为轻量级进程(Light Weight Process,LWP)</li></ol><h3 id="12-2-4-多线程环境下线程的状态与调度"><a href="#12-2-4-多线程环境下线程的状态与调度" class="headerlink" title="12.2.4. 多线程环境下线程的状态与调度"></a>12.2.4. 多线程环境下线程的状态与调度</h3><ol><li>线程状态有运行、就绪和等待和终止，(没有挂起状态时因为挂起和资源有关，而进程是资源管理的单位，与线程无关)</li><li>与线程状态变化有关的线程操作有：孵化、封锁、活化、剥夺、指派、结束</li><li>OS感知线程环境下：<ol><li>处理器调度的对象是线程</li><li>线程的存在、状态等都需要被操作系统内核感知到，进程没有三状态，或者说只有挂起状态。</li></ol></li><li>OS不感知线程环境下：<ol><li>处理器调度的单位仍然是进程</li><li>用户空间中的用户调度程序调度线程，内核不参加线程调度。</li></ol></li><li>状态转换模型<ol><li>运行态-&gt;终止态(撤销Return)</li><li>运行态-&gt;就绪态(中断系统)</li><li>运行态-&gt;就绪态(时间片用完)</li><li>就绪态-&gt;运行态</li></ol></li><li>DBMS:Client(请求方，Request)和Server(应答，Response)，Client频繁请求，Server频繁响应，Jacketing避免阻塞</li></ol><h2 id="12-3-并发多线程程序设计的优点"><a href="#12-3-并发多线程程序设计的优点" class="headerlink" title="12.3. 并发多线程程序设计的优点"></a>12.3. 并发多线程程序设计的优点</h2><ol><li>快速线程切换：改变堆栈和寄存器，不需要改变地址空间</li><li>减少(系统)管理开销：线程的创建和撤销要简单很多</li><li>(线程)通信易于实现：自动共享进程的内存和文件</li><li>并行程度提高</li><li>节省内存空间</li></ol><h2 id="12-4-多线程技术的应用"><a href="#12-4-多线程技术的应用" class="headerlink" title="12.4. 多线程技术的应用"></a>12.4. 多线程技术的应用</h2><ol><li>前台和后台工作:word的输入和拼写检查</li><li>C&#x2F;S应用模式:用户和服务器，其他线程调用</li><li>加快执行速度</li><li>设计用户接口</li></ol><h1 id="13-KLT与ULT"><a href="#13-KLT与ULT" class="headerlink" title="13. KLT与ULT"></a>13. KLT与ULT</h1><h2 id="13-1-内核级线程-KLT-Kernel-Level-Threads"><a href="#13-1-内核级线程-KLT-Kernel-Level-Threads" class="headerlink" title="13.1. 内核级线程 KLT, Kernel-Level Threads"></a>13.1. 内核级线程 KLT, Kernel-Level Threads</h2><ol><li>线程管理的所有工作由<strong>OS内核</strong>来做，并提供了一个应用程序设计接口API，供开发者使用KLT，</li><li>创建时：内核为其创建进程和一个基线程，线程实行过程中通过内核的创建线程原语来创建其他线程。</li><li>OS直接调度KLT，KLT用于解决物理并行性问题，内核可以感知到所有的内核级线程，可以控制器其数据结构，内核调度在线程的基础上进行。</li></ol><h3 id="13-1-1-内核级线程示意图"><a href="#13-1-1-内核级线程示意图" class="headerlink" title="13.1.1. 内核级线程示意图"></a>13.1.1. 内核级线程示意图</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/16.png"></p><h3 id="13-1-2-内核级线程的特点"><a href="#13-1-2-内核级线程的特点" class="headerlink" title="13.1.2. 内核级线程的特点"></a>13.1.2. 内核级线程的特点</h3><ol><li>优点：<ol><li>在多处理器上内核可以同时调度统一进程的多个线程运行。</li><li>进程中的某一线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行，也可以运行其他进程。</li><li>由于内核比较小，内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率。</li></ol></li><li>缺陷：<ol><li>应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大。</li><li>线程调度开销大，线程通信开销小。</li></ol></li></ol><h2 id="13-2-用户级线程ULT-User-Level-Threads"><a href="#13-2-用户级线程ULT-User-Level-Threads" class="headerlink" title="13.2. 用户级线程ULT, User-Level Threads"></a>13.2. 用户级线程ULT, User-Level Threads</h2><ol><li>用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境。任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行</li><li>线程管理的所有工作都由<strong>应用程序</strong>完成，<strong>内核没有</strong>感知到线程的存在，内核感知到的单位是进程。</li></ol><h3 id="13-2-1-用户级线程示意图"><a href="#13-2-1-用户级线程示意图" class="headerlink" title="13.2.1. 用户级线程示意图"></a>13.2.1. 用户级线程示意图</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/17.png"></p><h3 id="13-2-2-用户级线程的特点"><a href="#13-2-2-用户级线程的特点" class="headerlink" title="13.2.2. 用户级线程的特点"></a>13.2.2. 用户级线程的特点</h3><ol><li>优点：<ol><li>节省开销和内核资源:所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能<strong>节省模式切换开销和内核的宝贵资源</strong>。</li><li>允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法。</li><li>可移植性好:能运行在任何OS上，内核在支持ULT方面不需要做任何工作。</li><li>ULT可以解决逻辑并行性问题。</li></ol></li><li>缺点：<ol><li>不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行。</li><li>一个ULT的阻塞，将引起整个进程的阻塞:不能完成切换线程，因为内核感知不到进程中的线程的存在。</li></ol></li><li>ULT可以解决逻辑并行性问题。</li></ol><h2 id="13-3-Jacketing技术"><a href="#13-3-Jacketing技术" class="headerlink" title="13.3. Jacketing技术"></a>13.3. Jacketing技术</h2><ol><li>把阻塞式系统调用改造成非阻塞式的:解决一个ULT的阻塞导致整个进程阻塞，避免进程因此从运行态$\rightarrow$阻塞态，如此的频繁切换会带来比较大的开销。</li><li>当线程陷入系统调用时，执行Jacketing程序。</li><li>由Jacketing程序来检查资源使用情况，以决定是否执行<strong>进程切换</strong>或<strong>传递控制权给另一个线程</strong></li></ol><h2 id="13-4-用户级线程-vs-内核级线程"><a href="#13-4-用户级线程-vs-内核级线程" class="headerlink" title="13.4. 用户级线程 vs. 内核级线程"></a>13.4. 用户级线程 vs. 内核级线程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/18.png"></p><ol><li>受限条件下的并行:受限条件是同步关系(等待)</li><li>ULT适用于解决逻辑并行性问题</li><li>KLT适用于解决物理并行性问题</li></ol><h2 id="13-5-多线程实现的混合式策略"><a href="#13-5-多线程实现的混合式策略" class="headerlink" title="13.5. 多线程实现的混合式策略"></a>13.5. 多线程实现的混合式策略</h2><ol><li>在用户空间完成所有的线程的创建工作。</li><li>单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果。</li><li>在混合式线程中，内核必须支持内核级多线程的建立、调度和管理，同时也允许应用程序建立、调度和管理用户级线程。</li><li>用户级线程的切换仅在用户空间中且仅需要少量机器指令，而内核级线程需要用户态到内核态到用户态的完整上下文切换，修改内存映像，使得高速缓存失效，导致数量级的延迟。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/19.png"></p><h3 id="13-5-1-多线程实现混合式策略的特点"><a href="#13-5-1-多线程实现混合式策略的特点" class="headerlink" title="13.5.1. 多线程实现混合式策略的特点"></a>13.5.1. 多线程实现混合式策略的特点</h3><ol><li>合并了用户级线程&#x2F;内核级线程设施</li><li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li><li>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上</li><li>程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果</li><li>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点</li></ol><h3 id="13-5-2-线程混合式策略下的线程状态"><a href="#13-5-2-线程混合式策略下的线程状态" class="headerlink" title="13.5.2. 线程混合式策略下的线程状态"></a>13.5.2. 线程混合式策略下的线程状态</h3><ol><li>KLT的三态模型，由系统调度负责</li><li>ULT的三态模型，由用户调度负责</li><li>活跃态的ULT代表绑定KLT的三态</li><li>活跃态的ULT运行时可激活用户调度，非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/20.png"></p><ol><li>为什么是活跃态绑定KLT的三态？</li><li>因为如果绑定的KLT不再运行，则也不再运行。活跃态代表了KLT，可能是运行态、可运行态、阻塞态</li></ol><h3 id="13-5-3-多线程实现的各种策略总结"><a href="#13-5-3-多线程实现的各种策略总结" class="headerlink" title="13.5.3. 多线程实现的各种策略总结"></a>13.5.3. 多线程实现的各种策略总结</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/21.png"></p><blockquote><p>混合式多线程合并了内核级多线程和用户级多线程的优势，甚至可以指派到CPU，或由操作系统绑定。</p></blockquote><h3 id="13-5-4-Solris-多线程技术"><a href="#13-5-4-Solris-多线程技术" class="headerlink" title="13.5.4. Solris 多线程技术"></a>13.5.4. Solris 多线程技术</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/28.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/34.png"></th></tr></thead></table><blockquote><p>包含了多种情况，上图引入了轻量级线程，将轻量级线程与内核级线程映射，原来的多线程设计是Process2，只有一个处理进程，允许给一个进程配置超过一个处理器。</p></blockquote><ol><li>进程一:单进程单线程，内核级多线程</li><li>进程二:单进程双线程，进程映射到两个轻量级线程，相当于用户级多线程</li><li>进程三:两进程三线程，内核级多线程</li><li>进程四:两进程两线程，内核级多线程</li><li>进程五:三进程四线程，混合级线程，直接做指派意味着线程非常重要，需要单独指派。</li></ol><blockquote><p>一个进程的线程可以被分发到各个位置上并行完成，处理器只能感知进程，不能感知线程，并且只会将一个处理器分配给线程，然后用户空间将得到的处理器分配给线程。</p></blockquote><h1 id="14-处理器调用"><a href="#14-处理器调用" class="headerlink" title="14. 处理器调用"></a>14. 处理器调用</h1><h2 id="14-1-处理器调度层次"><a href="#14-1-处理器调度层次" class="headerlink" title="14.1. 处理器调度层次"></a>14.1. 处理器调度层次</h2><ol><li>高级调度：又称长程调度、作业调度，决定能否加入到执行的进程池中，管理从创建进程到调度运行再到结束阶段后的善后部分的全过程。</li><li>中级调度，又称平衡调度、中程调度，根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作。</li><li>低级调度：又称短程调度、进程调度&#x2F;线程调度，根据某种原则决定就绪队列中哪个进程&#x2F;线程获得处理器，并将处理器让出给它使用。</li></ol><h3 id="14-1-1-处理器调度层次与进程状态转换"><a href="#14-1-1-处理器调度层次与进程状态转换" class="headerlink" title="14.1.1. 处理器调度层次与进程状态转换"></a>14.1.1. 处理器调度层次与进程状态转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/22.png"></p><blockquote><p>这个说明录入各级调度和七态模型的情况，三个框分别表明不同调度层次，如上图所示。资源紧张时挂起，资源空闲时解挂</p></blockquote><h3 id="14-1-2-处理器调度层次与关键状态转换"><a href="#14-1-2-处理器调度层次与关键状态转换" class="headerlink" title="14.1.2. 处理器调度层次与关键状态转换"></a>14.1.2. 处理器调度层次与关键状态转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/23.png"></p><h3 id="14-1-3-高级调度"><a href="#14-1-3-高级调度" class="headerlink" title="14.1.3. 高级调度"></a>14.1.3. 高级调度</h3><ol><li>在分时操作系统中，高级调度决定：<ol><li>是否接受一个终端用户的连接</li><li>命令能否被系统接纳并构成进程</li><li>新建态进程是否加入就绪进程队列</li></ol></li><li>批处理OS中，高级调度又称为作业调度，功能是按照某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备工作和完成后的善后工作</li></ol><h3 id="14-1-4-中级调度"><a href="#14-1-4-中级调度" class="headerlink" title="14.1.4. 中级调度"></a>14.1.4. 中级调度</h3><ol><li>引进中级调度是为了提高内存利用率和作业吞吐量</li><li>中级调度决定那些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用</li><li>中级调度把一些进程换出主存，从而使之进入”挂起”状态，不参与进程调度，以平顺系统的负载</li></ol><h3 id="14-1-5-低级调度"><a href="#14-1-5-低级调度" class="headerlink" title="14.1.5. 低级调度"></a>14.1.5. 低级调度</h3><ol><li>低级调度：又称处理器调度、进程调度、短程调度，按照某种原则把处理器分配给就绪态进程或内核级线程</li><li>进程调度程序：又称分派程序，操作系统中实现处理器调度的程序，是操作系统的最<strong>核心部分</strong></li><li>处理器<strong>调度策略</strong>的优劣直接影响到整个系统的性能，这个进程被很多操作系统称为0号进程，所有进程的<strong>父进程</strong></li><li>低级调度主要是负责记录进程或内核级线程的状态、决定某个进程或内核级线程什么时候获得处理器以及占用时间、将处理器分配给进程或内核级线程、回收处理器。</li></ol><h3 id="14-1-6-综述三级调度"><a href="#14-1-6-综述三级调度" class="headerlink" title="14.1.6. 综述三级调度"></a>14.1.6. 综述三级调度</h3><ol><li>一般操作系统都配置了高级调度和低级调度，而功能完善的操作系统为了提高内存利用率和作业吞吐率引进了中级调度。</li><li>因此，从处理器调度的层次来讲，可以划分为三级调度模型和两级调度模型。</li></ol><h2 id="14-2-CPU从进程到进程的切换"><a href="#14-2-CPU从进程到进程的切换" class="headerlink" title="14.2. CPU从进程到进程的切换"></a>14.2. CPU从进程到进程的切换</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/35.png"></p><ul><li>内核态进程占用时间不应该过多，应当尽量避免频繁的模式切换<ol><li>正向切换(从用户态转换到内核态):Trap、系统调用、中断</li><li>反向切换(从内核态转换到用户态):ret</li></ol></li></ul><h2 id="14-3-进程抽象"><a href="#14-3-进程抽象" class="headerlink" title="14.3. 进程抽象"></a>14.3. 进程抽象</h2><p>我们需要不断完善中断处理子系统，内核态是将特权指令和非特权指令混搭使用。</p><h1 id="15-处理器调度算法"><a href="#15-处理器调度算法" class="headerlink" title="15. 处理器调度算法"></a>15. 处理器调度算法</h1><h2 id="15-1-选择处理器调度算法的原则"><a href="#15-1-选择处理器调度算法的原则" class="headerlink" title="15.1. 选择处理器调度算法的原则"></a>15.1. 选择处理器调度算法的原则</h2><blockquote><p>在以下的五个方面进行巧妙的平衡来完成操作系统的设计。</p></blockquote><ol><li>资源利用率：使得CPU或其他资源的使用率尽可能高且能够并行工作</li></ol><p>$$<br>\begin{aligned}<br>   &amp;CPU利用率 &#x3D; \frac{CPU有效工作时间}{CPU总运行时间} \<br>   &amp;CPU总运行时间 &#x3D; CPU有效工作时间 + CPU空闲等待时间 \<br>\end{aligned}<br>$$</p><ol start="2"><li>吞吐量：单位事假内CPU处理作业的个数，服务器的TPS，例如12306或淘宝</li><li>公平性：确保每个用户每个进程获得合理的CPU份额或其他资源份额</li><li>响应时间：<ol><li>使交互式用户的响应时间尽可能小，或尽快处理实时任务</li><li>细分包含输入的程序命令传送到CPU时间、CPU处理请求命令的时间、处理所形成的响应回送到终端显示器的时间。</li></ol></li><li>周转时间：提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短。</li></ol><p>$$<br>\begin{aligned}<br>   &amp;作业i周转时间t_i &#x3D; 完成时刻t_f - 提交时刻t_s \<br>   &amp;平均作业周转时间T &#x3D; \frac{\sum\limits_{i&#x3D;1}\limits^nt_i}{n}\<br>   &amp;作业带权周转时间w_i &#x3D; \frac{周转时间t_i}{运行时间t_k} \<br>   &amp;平均带权做作业周转时间W &#x3D;\frac{\sum\limits_{i&#x3D;1}\limits^nw_i}{n}<br>\end{aligned}<br>$$</p><h2 id="15-2-短程调度准则"><a href="#15-2-短程调度准则" class="headerlink" title="15.2. 短程调度准则"></a>15.2. 短程调度准则</h2><ol><li>与性能相关<ol><li>面向用户：周转时间、响应时间、最后期限</li><li>面向系统：吞吐量、处理器利用率</li></ol></li><li>与性能无关<ol><li>面向用户：可预测性</li><li>面向系统：公平、强制优先级、平衡资源</li></ol></li></ol><h2 id="15-3-低级调度的主要功能"><a href="#15-3-低级调度的主要功能" class="headerlink" title="15.3. 低级调度的主要功能"></a>15.3. 低级调度的主要功能</h2><ol><li>调度：实现调度策略，确定就绪态进程&#x2F;线程竞争使用处理器的次序的裁决原则。</li><li>分派：实现调度机制，确定如何时分复用CPU，处理上下文切换，完成进程&#x2F;线程同CPU的绑定以及放弃的实际工作</li></ol><h2 id="15-4-调度的模式"><a href="#15-4-调度的模式" class="headerlink" title="15.4. 调度的模式"></a>15.4. 调度的模式</h2><ol><li>抢占式(剥夺式)调度：当前正在运行的进程可能被操作系统中断，并转移到就绪态。处理器剥夺原则：<ol><li>高优先级进程&#x2F;线程可剥夺低优先级进程&#x2F;线程。</li><li>运行进程&#x2F;线程时间片用完后被剥夺。</li></ol></li><li>非抢占式(非剥夺式)调度：一个进程一旦处于运行态，它就不断执行直到终止，或者为等待I&#x2F;O或请求某些操作系统服务而阻塞自己。</li><li>与非抢占式调度相比，抢占式调度可能会导致较大的开销，但是可能对所有进程提供更好的服务，可以避免任何一个进程独占处理器太长时间</li></ol><h2 id="15-5-优先数调度算法"><a href="#15-5-优先数调度算法" class="headerlink" title="15.5. 优先数调度算法"></a>15.5. 优先数调度算法</h2><ol><li>操作系统往往无法判断进程会使用CPU多久，所以现代操作系统一般会使用时间片轮转来完成调度。</li><li>排列论:随机过程(Stochastic Process，Markor)</li></ol><h3 id="15-5-1-根据分配给进程的优先数决定运行进程"><a href="#15-5-1-根据分配给进程的优先数决定运行进程" class="headerlink" title="15.5.1. 根据分配给进程的优先数决定运行进程"></a>15.5.1. 根据分配给进程的优先数决定运行进程</h3><ol><li>抢占式(Preemptive)优先数调度算法，出现高优先级则中断，抢占一定是从运行态到就绪态的转换，抢占点的安排可能不一样，在实时系统中将抢占点提前，不等一个进程使用完时间片，而是新进程到达就发生抢占，或者时间片用完抢占。</li><li>非抢占式(non-preemptive)优先数调度算法，出现CPU空闲再选择。</li></ol><h3 id="15-5-2-优先数的确定准则"><a href="#15-5-2-优先数的确定准则" class="headerlink" title="15.5.2. 优先数的确定准则"></a>15.5.2. 优先数的确定准则</h3><ol><li>进程负担任务的紧迫程度</li><li>进程的交互性</li><li>进程使用外设的频度:使用外设的优先</li><li>进程进入系统的时间长短:公平性和周转的问题</li></ol><h3 id="15-5-3-调度算法分类"><a href="#15-5-3-调度算法分类" class="headerlink" title="15.5.3. 调度算法分类"></a>15.5.3. 调度算法分类</h3><ol><li>FCFS (先来先服务) 非抢占</li><li>RR (时间片轮转) 抢占</li><li>SPN (最短进程优先) 非抢占，真正操作系统没有办法使用</li><li>SRT (最短剩余时间优先) 抢占，真正操作系统没有办法使用</li><li>HRRF (最高响应比优先) 非抢占，真正操作系统没有办法使用</li><li>Feedback (多级反馈调度) 抢占</li></ol><h2 id="15-6-与进入系统时间相关的优先数"><a href="#15-6-与进入系统时间相关的优先数" class="headerlink" title="15.6. 与进入系统时间相关的优先数"></a>15.6. 与进入系统时间相关的优先数</h2><ol><li>计算时间短(作业&#x2F;进程)优先</li><li>剩余计算时间短进程优先：商业操作系统可以这么处理，但是别的可能有一定的问题。</li><li>响应比高者(作业&#x2F;进程)优先：</li></ol><p>$$<br>\begin{aligned}<br>   &amp;响应比 &#x3D; \frac{等待时间 + 期待服务时间}{期待服务时间}\<br>   &amp;\qquad\qquad &#x3D; 1 + \frac{等待时间}{期待服务时间} \<br>\end{aligned}<br>$$</p><ol start="4"><li>先来先服务：先进队先被选择：多用于高级调度；低级调度中，以<strong>计算</strong>为主的进程过于优越</li></ol><h1 id="16-具体调度算法"><a href="#16-具体调度算法" class="headerlink" title="16. 具体调度算法"></a>16. 具体调度算法</h1><h2 id="16-1-FCFS-先来先服务"><a href="#16-1-FCFS-先来先服务" class="headerlink" title="16.1. FCFS (先来先服务)"></a>16.1. FCFS (先来先服务)</h2><ol><li>当某个进程就绪时，就加入就绪队列(ready queue)，当前正在运行的进程停止执行时，选择在就绪队列到达时间最长的进程运行</li><li>平均作业周转时间与作业提交和调度顺序有关。</li><li>两个弊端<ol><li>一个短进程可能不得不等待很长时间才能获得执行，导致吞吐率很难提高，加权中转时间会上升，最差的情况就是计算型死循环，导致完全无法调度。</li><li>偏袒计算为主的进程:I&#x2F;O多的进程不得不等待计算为主的进程做完，因为需要等待资源，离开后需要重新排队。</li></ol></li><li>性能会非常差，不被现在的操作系统使用。</li><li>先来先服务算法示例：</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/38.png"></p><ol start="6"><li>平均作业周转时间$T + \frac{3 + 7 + 9 + 12 + 12}{5} &#x3D; 8.6$</li><li>平均带权作业周转时间$T + \frac{\frac{3}{3} + \frac{7}{6} + \frac{9}{4} + \frac{12}{5} + \frac{12}{2}}{5} \approx 2.563$</li></ol><h2 id="16-2-SPN-最短进程优先"><a href="#16-2-SPN-最短进程优先" class="headerlink" title="16.2. SPN (最短进程优先)"></a>16.2. SPN (最短进程优先)</h2><ol><li>SPN是一种<strong>非抢占式</strong>调度，会选择处理时间最短的进程，短进程将会越过长进程，优先获得调度，又称为SJF。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/47.png"></p><ol start="2"><li>平均作业周转时间$T &#x3D; \frac{3 + 7 + 11 + 14 + 3}{5} &#x3D; 7.6$</li><li>平均带权作业周转时间$W &#x3D; \frac{\frac{3}{3} + \frac{7}{6} + \frac{11}{4} + \frac{14}{5} + \frac{3}{2}}{5} \approx 1.843$</li><li>问题:<ol><li>需要预知作业所需的CPU运行时间</li><li>忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。</li><li>分时、实时处理仍然不理想。</li></ol></li></ol><h2 id="16-3-SRT，Shortest-Remaining-Time，最短剩余时间优先"><a href="#16-3-SRT，Shortest-Remaining-Time，最短剩余时间优先" class="headerlink" title="16.3. SRT，Shortest Remaining Time，最短剩余时间优先"></a>16.3. SRT，Shortest Remaining Time，最短剩余时间优先</h2><ol><li>SRT是一种<strong>抢占式</strong>调度，调度器总是选择预期剩余时间更短的进程</li><li>当一个新进程加入就绪队列，他可能比当前运行的进程具有更短的剩余时间，只要新进程进入就绪队列，调度器就可能抢占当前正在运行的进程</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/48.png"></p><ol start="3"><li>平均等待时间$&#x3D;\frac{(3 - 3 - 0) + (15 - 6 - 2) + (8 - 4 - 4) + (20 - 5 - 6) + (10 - 2 - 8)}{5} &#x3D; 3.2$</li><li>平均周转时间$&#x3D;\frac{(3 - 0) + (15 - 2) + (8 - 4) + (20 - 6) + (10 - 8)}{5} &#x3D; 7.2$</li></ol><h2 id="16-4-HRRN-最高响应比优先-Highest-Response-Ratio-Next"><a href="#16-4-HRRN-最高响应比优先-Highest-Response-Ratio-Next" class="headerlink" title="16.4. HRRN (最高响应比优先)Highest Response Ratio Next"></a>16.4. HRRN (最高响应比优先)Highest Response Ratio Next</h2><ol><li>非抢占式算法，性能略差与SPN(SJF)</li><li>选择响应比最高的进程：出发点是兼顾公平，对于短进程有利</li><li>每当需要调度时，计算出所有的响应比，选择最高的。</li></ol><p>$$<br>\begin{aligned}<br>   &amp;响应比 &#x3D; \frac{等待时间 + 期待服务时间}{期待服务时间}\<br>   &amp;\qquad\qquad &#x3D; 1 + \frac{等待时间}{期待服务时间} \<br>\end{aligned}<br>$$</p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/49.png"></p><table><thead><tr><th>时刻</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>0时刻</td><td>$1$</td><td>未到</td><td>未到</td><td>未到</td><td>未到</td></tr><tr><td>3时刻</td><td>完成</td><td>$1 + \frac{1}{6} \approx 1.17$</td><td>未到</td><td>未到</td><td>未到</td></tr><tr><td>9时刻</td><td>完成</td><td>完成</td><td>$1 + \frac{5}{4} &#x3D; 2.25$</td><td>$1 + \frac{3}{5} &#x3D; 1.6$</td><td>$1 + \frac{1}{2} &#x3D; 1.5$</td></tr><tr><td>13时刻</td><td>完成</td><td>完成</td><td>完成</td><td>$1 + \frac{7}{5} &#x3D; 2.6$</td><td>$1 + \frac{5}{2} &#x3D; 3.5$</td></tr><tr><td>15时刻</td><td>完成</td><td>完成</td><td>完成</td><td>$1 + \frac{12}{5} &#x3D; 3.4$</td><td>万&#x3D;完成</td></tr></tbody></table><h2 id="16-5-优先级调度"><a href="#16-5-优先级调度" class="headerlink" title="16.5. 优先级调度"></a>16.5. 优先级调度</h2><ol><li>调度器总是选择优先级较高的进程，提供多个就绪队列(一组就绪队列)，代表各个级别的优先级。</li><li>低优先级的进程可能很难被执行到？一个进程的优先级应该随着它的时间或执行的历史而变化。</li><li>如果就绪队列中出现优先级高的进程&#x2F;线程，系统可以预先规定策略为非剥夺式和剥夺式策略。</li><li>优先级的确定<ol><li>用户给出优先级</li><li>系统综合考虑各因素，包括打开文件数、资源申请情况等等</li></ol></li><li>优先级确定方式<ol><li>静态：生命周期内不改变，容易造成饥饿问题。</li><li>动态：生命周期内可能会发生改变，正在运行的进程逐渐降低优先级，正在等待的进程逐渐提高优先级。</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/36.png"></p><h2 id="16-6-RR-时间片轮转调度算法"><a href="#16-6-RR-时间片轮转调度算法" class="headerlink" title="16.6. RR(时间片轮转调度算法)"></a>16.6. RR(时间片轮转调度算法)</h2><p>以时间片轮转为基本策略的调度算法不需要预知就绪进程所需cpu时长</p><ol><li>本质也是<strong>先来先服务</strong>，但是要按照时间片来进行调度。</li><li>根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片，基于时钟做抢占式调度。</li><li>时间片中断：以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列队尾，然后基于FCFS策略选择下一个就绪进程运行</li><li>时间片的确定：选择长短合适的时间片，一般为10ms到200ms<ol><li>过长则退化为先来先服务算法</li><li>过短则调度开销显著增大</li></ol></li><li>时间片分为单时间片、多时间片和动态时间片三种</li><li>使用时间片轮转调度算法，在给一个进程分配处理器的时候，不需要知道进程需要多长时间</li><li>很多的调度都会结合时间片轮转调度算法来实现</li><li>如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。</li></ol><h3 id="16-6-1-使用情况"><a href="#16-6-1-使用情况" class="headerlink" title="16.6.1. 使用情况"></a>16.6.1. 使用情况</h3><ol><li>先进先出&#x2F;最短时间&#x2F;剩余时间&#x2F;响应比优先算法，无法判断进程需要占用多长时间的CPU</li><li>有预估时间的调度，用在作业调度、云计算调度中比较合适，在低级调度中不合适</li></ol><h3 id="16-6-2-进程分类"><a href="#16-6-2-进程分类" class="headerlink" title="16.6.2. 进程分类"></a>16.6.2. 进程分类</h3><ol><li>以计算为主的进程：不需要内核参与，没有从运行态到阻塞态的情况，如果出现死循环进程也必须要遵循时间片轮换，如果进程比较多，就可以淡化死循环的影响</li><li>I&#x2F;O(外设)频繁的进程：发生运行态到阻塞态的可能性比较大，根据各个进程进入就绪队列的时间先后轮流占用CPU一个时间片，时间片到即发生时间片中断。</li></ol><h3 id="16-6-3-时间片轮转调度算法示例"><a href="#16-6-3-时间片轮转调度算法示例" class="headerlink" title="16.6.3. 时间片轮转调度算法示例"></a>16.6.3. 时间片轮转调度算法示例</h3><table><thead><tr><th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/39.png"></th><th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/39.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/40.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/41.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/42.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/43.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/44.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/45.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/46.png"></td><td></td></tr></tbody></table><blockquote><p>务必关注就绪队列</p></blockquote><h2 id="16-7-多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度"><a href="#16-7-多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度" class="headerlink" title="16.7. 多级反馈调度 (Multi-level Feedback Queue，MLFQ)，又称分级调度"></a>16.7. 多级反馈调度 (Multi-level Feedback Queue，MLFQ)，又称分级调度</h2><ol><li>基本思想<ol><li>建立多个不同优先级的就绪进程队列</li><li>多个就绪进程队列之间按照优先数调度</li><li>高优先级的就绪进程, 分配的时间片短</li><li>单个就绪进程队列中的进程的优先数和时间片相同,按照先来先服务算法调度</li></ol></li><li>分级原则：外设访问、交互性、时间紧迫程度、系统效率、用户立场</li><li>现代操作系统的实现模型<ol><li>多个高优先级的实时进程队列，如：硬实时、网络、软实时</li><li>多个分时任务的进程队列，根据基准优先数和执行行为调整</li><li>队列数可能多达32-128个</li></ol></li><li>如果没做完会惩罚降级，做题目要至少画一下前几个RQ。如果进程掉出去的同时，有新的进程进入，那么新的进程优先进入就绪队列</li><li>对以计算为主的长进程不友好，就绪队列越深获得调度的机会越小</li><li>不同的进程可以设置不同的时间片长度:$q &#x3D; 2^i$，i是层数，所以第一层时间片长为1，第二层长为2</li><li>多级队列更能够发现先到达的，时间片比较短的处理完。</li><li>除了极少数的硬实时操作系统使用抢占式调度算法，绝大多数操作系统有效地组合时间片调度算法和优先数调度算法，采用分级调度算法的策略加以实现</li><li>如果没有竞争不掉下去，时刻1(根据考试具体情况决定)</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/50.png"></p><h3 id="16-7-1-q-x3D-1-时的多级反馈调度的示例"><a href="#16-7-1-q-x3D-1-时的多级反馈调度的示例" class="headerlink" title="16.7.1. q &#x3D; 1 时的多级反馈调度的示例"></a>16.7.1. q &#x3D; 1 时的多级反馈调度的示例</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/51.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/52.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/53.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/54.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/55.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/56.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/57.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/58.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/59.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/60.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/61.png"></td><td></td></tr></tbody></table><h3 id="16-7-2-q-x3D-2-i-时的多级反馈调度的示例"><a href="#16-7-2-q-x3D-2-i-时的多级反馈调度的示例" class="headerlink" title="16.7.2. q &#x3D; $2^i$时的多级反馈调度的示例"></a>16.7.2. q &#x3D; $2^i$时的多级反馈调度的示例</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/62.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/63.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/64.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/65.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/66.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/67.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/68.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/69.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/70.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/71.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/72.png"></td><td></td></tr></tbody></table><h3 id="16-7-3-多级反馈调度的示意图"><a href="#16-7-3-多级反馈调度的示意图" class="headerlink" title="16.7.3. 多级反馈调度的示意图"></a>16.7.3. 多级反馈调度的示意图</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/24.png"></p><ol><li>如果没有进程竞争，那么会不会导致进程掉下去，根据具体情况分析，可能掉下去也可能没有掉下去。</li><li>此时RQ0是A，RQ2是C，当前A在做，那么A掉下来后是运行A还是C，可以考虑运行A进程：因为掉到了RQ1，也可以考虑运行C进程，具体情况要看操作系统时间中的细节</li><li>刚好做完的时刻，B同步进入也需要细规则来完善。</li></ol><h2 id="16-8-彩票调度算法"><a href="#16-8-彩票调度算法" class="headerlink" title="16.8. 彩票调度算法"></a>16.8. 彩票调度算法</h2><ol><li>基本思想：为进程发放针对<strong>系统各种资源</strong>(如CPU时间)的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源</li><li>功能比保证调度好的多，服务器和客户：客户需要调用服务器服务，则将彩票交给服务器</li><li>合作进程之间的彩票交换</li><li>一般不会在实时操作系统中使用，但是可以在服务器端进行使用，特别是视频点播服务器</li></ol><h2 id="16-9-传统Unix系统的调度-例"><a href="#16-9-传统Unix系统的调度-例" class="headerlink" title="16.9. 传统Unix系统的调度(例)"></a>16.9. 传统Unix系统的调度(例)</h2><ol><li>多级反馈队列，每个优先级队列使用时间片轮转</li><li>每秒重新计算每个进程的优先级</li><li>给每个进程赋予基本优先级的目的是把所有进程划分成固定的优先级区</li><li>可控调节因子</li></ol><h2 id="16-10-Unix-SVR4调度算法-例"><a href="#16-10-Unix-SVR4调度算法-例" class="headerlink" title="16.10. Unix SVR4调度算法(例)"></a>16.10. Unix SVR4调度算法(例)</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/74.png"></p><ol><li><p>100-159是实时部分任务</p></li><li><p>60-99是内核部分任务</p></li><li><p>0-59是分时部分任务</p></li><li><p>多级反馈队列，每一个优先数都对应于一个就绪进程队列</p><ol><li>实时优先级层次：优先数和时间片都是固定的，在抢占点执行抢占</li><li>分时优先级层次：优先数和时间片是可变的，从0优先数的100ms到59优先数的10ms</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/75.png"></p><h2 id="16-11-Bands"><a href="#16-11-Bands" class="headerlink" title="16.11. Bands"></a>16.11. Bands</h2><blockquote><p>优先级递减：对换、块I&#x2F;O设备控制、文件操作、字符I&#x2F;O设备控制、用户进程</p></blockquote><h2 id="16-12-Windows调度算法-例"><a href="#16-12-Windows调度算法-例" class="headerlink" title="16.12. Windows调度算法(例)"></a>16.12. Windows调度算法(例)</h2><ol><li>主要设计目标：基于内核级线程的可抢占式调度，向单个用户提供交互式的计算环境，并支持各种服务器程序</li><li>优先级和优先数</li><li>实时优先级层次(优先数为31-16)：用于通信任务和实时任务，优先数不可变</li><li>可变优先级层次(优先数为15-0)：用于用户提交的交互式任务，优先数可动态调整</li><li>多级反馈队列，每一个优先数都对应于一个就绪进程队列</li><li>优先数可动态调整原则<ol><li>线程所属的进程对象有一个进程基本优先数，取值范围从0到15</li><li>线程对象有一个线程基本优先数，取值范围从-2到2</li><li>线程的初始优先数为进程基本优先数加上线程基本优先数，但必须在0到15的范围内</li><li>线程的动态优先数必须在初始优先数到15的范围</li></ol></li><li>当存在N个处理器时，N-1个处理器上将运行N-1个最高<br>先级的线程，其他线程将共享剩下的一个处理器</li></ol><h1 id="17-批处理作业的调度"><a href="#17-批处理作业的调度" class="headerlink" title="17. 批处理作业的调度"></a>17. 批处理作业的调度</h1><h2 id="17-1-批处理作业的管理"><a href="#17-1-批处理作业的管理" class="headerlink" title="17.1. 批处理作业的管理"></a>17.1. 批处理作业的管理</h2><ol><li>作业说明语言和作业说明书</li><li>脱机控制方式(批处理控制方式)</li><li>作业控制块JCB</li><li>作业状态<ol><li>输入状态：作业正在从输入设备上预输入信息</li><li>后备状态：作业预输入结束但尚未被选中执行</li><li>执行状态：作业已经被选中并构成进程去竞争处理器资源以获得运行</li><li>完成状态：作业运行结束，正在等待缓输出</li></ol></li><li>作业默认所有的资源调度都是静态调度(静态分配)完成的，输出井来完成。</li></ol><h2 id="17-2-批处理作业的状态作业调度与进程调度"><a href="#17-2-批处理作业的状态作业调度与进程调度" class="headerlink" title="17.2. 批处理作业的状态作业调度与进程调度"></a>17.2. 批处理作业的状态作业调度与进程调度</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/78.png"></p><ol><li>作业调度：按一定的策略选取若干个作业让它们进入内存、构成进程去竞争处理器以获得运行机会</li><li>用户立场：自己作业的周转时间尽可能的小</li><li>系统立场：希望进入系统的作业的平均周转时间尽可能的小</li><li>适当的作业调度算法必须既考虑用户的要求又有利于系统效率的提高</li></ol><h1 id="18-补充"><a href="#18-补充" class="headerlink" title="18. 补充"></a>18. 补充</h1><h2 id="18-1-习题-进程管理的fork系统调用"><a href="#18-1-习题-进程管理的fork系统调用" class="headerlink" title="18.1. 习题(进程管理的fork系统调用)"></a>18.1. 习题(进程管理的fork系统调用)</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/76.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/77.png"></th></tr></thead></table><ol><li>fork会克隆出一个新的进程，但是是同一个PC，也就是从父进程的当前步骤开始往下做</li><li>第一次fork A -&gt; B</li><li>第二次fork A -&gt; C, B -&gt; D</li><li>到三次fork A -&gt; E, B -&gt; F, C -&gt; G, D -&gt; H</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/78.png"></p><h2 id="18-2-阿里云平台"><a href="#18-2-阿里云平台" class="headerlink" title="18.2. 阿里云平台"></a>18.2. 阿里云平台</h2><ol><li>章文嵩:Linux集群，LVS，尽量节能</li><li>使用了灵动处理器</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.计算机系统概述</title>
    <link href="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/"/>
    <url>/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1. 计算机系统概述"></a>1. 计算机系统概述</h1><ol><li>电子数字计算机，是一种能够自行<strong>按照已设定的程序</strong>进行<strong>数据处理</strong>的电子设备；是软件与硬件相结合、面向系统、侧重应用的<strong>自动化求解</strong>工具</li><li>1946年，首台计算机ENIAC诞生于美国。</li><li>短短70年，计算机技术迅猛发展，从<strong>科学计算、数据处理</strong>等应用领域，迅速扩展到<strong>实时控制、辅助设计、智能模拟</strong>等诸多领域</li><li>今天计算机无所不在，深入社会生活的各个领域，深深改变了当今人类社会的组织行为</li><li>计算机系统包括<strong>计算机硬件系统和计算机软件系统</strong></li></ol><h2 id="1-1-计算机历史"><a href="#1-1-计算机历史" class="headerlink" title="1.1. 计算机历史"></a>1.1. 计算机历史</h2><ol><li>1945：电子真空管、机器语言，应用于科学计算</li><li>1956：晶体管、批处理控制、Fortran(科学计算的高级语言)&#x2F;COBOL(数据处理的高级语言)，扩展到数据处理领域</li><li>1959：集成电路、多道程序、操作系统&#x2F;数据库&#x2F;高级语言，应用领域继续扩展</li><li>1976：大规模&#x2F;超大规模集成电路，向快速化&#x2F;小型化&#x2F;系统化&#x2F;网络化&#x2F;智能化等方面发展</li><li>1980：微机出现，廉价化促使应用领域快速膨胀</li><li>1990：图形化人机交互技术，友善化推动了应用人群的快速扩展</li><li>2003：移动计算的出现，计算无处不在</li></ol><h2 id="1-2-计算机系统的组成"><a href="#1-2-计算机系统的组成" class="headerlink" title="1.2. 计算机系统的组成"></a>1.2. 计算机系统的组成</h2><blockquote><p>计算机系统：包括硬件子系统和软件子系统</p></blockquote><ol><li><strong>硬件</strong>：借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统工作的实体，包括CPU，主存储器，I&#x2F;O控制系统，外围设备等</li><li><strong>软件</strong>：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作<ol><li>包括系统软件、支撑软件和应用软件</li><li>关键系统软件是操作系统与语言处理程序</li></ol></li><li>系统软件(操作系统)层是最靠近硬件的一层软件。</li><li>操作系统和支撑软件、应用软件之间的主要区别<ol><li>操作系统有权利分配资源，支撑软件以及应用软件只能通过操作系统使用资源，两者为控制和被控制的关系。</li><li>操作系统直接作用在硬件上，隔离其他上层软件，并为其提供接口和服务。</li></ol></li></ol><h2 id="1-3-计算机系统的用户视图"><a href="#1-3-计算机系统的用户视图" class="headerlink" title="1.3. 计算机系统的用户视图"></a>1.3. 计算机系统的用户视图</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/10.png"></p><blockquote><p>系统程序员:面向硬件编程的程序员</p></blockquote><h1 id="2-计算机硬件系统"><a href="#2-计算机硬件系统" class="headerlink" title="2. 计算机硬件系统"></a>2. 计算机硬件系统</h1><h2 id="2-1-计算机硬件系统的组成"><a href="#2-1-计算机硬件系统的组成" class="headerlink" title="2.1. 计算机硬件系统的组成"></a>2.1. 计算机硬件系统的组成</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/11.png"></p><ol><li>中央处理器<ol><li>运算单元</li><li>控制单元</li></ol></li><li>主存储器</li><li>外围设备<ol><li>输出设备:显示器</li><li>输入设备:键盘、鼠标</li><li>存储设备:硬盘</li><li>网络通信设备:机机通信</li></ol></li><li>总线:连接硬件系统的部件</li></ol><h2 id="2-2-冯·诺依曼计算机特点"><a href="#2-2-冯·诺依曼计算机特点" class="headerlink" title="2.2. 冯·诺依曼计算机特点"></a>2.2. 冯·诺依曼计算机特点</h2><blockquote><p>冯·诺伊曼等人在1946年总结并明确提出，被称为冯·诺伊曼计算机模型</p></blockquote><ol><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h2 id="2-3-存储程序计算机的结构"><a href="#2-3-存储程序计算机的结构" class="headerlink" title="2.3. 存储程序计算机的结构"></a>2.3. 存储程序计算机的结构</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/12.png"></p><ol><li>当前计算机硬件的<strong>经典结构和主流组织</strong>方式</li><li><strong>存储器</strong>是这个模型的核心部分</li></ol><h2 id="2-4-总线及其组成"><a href="#2-4-总线及其组成" class="headerlink" title="2.4. 总线及其组成"></a>2.4. 总线及其组成</h2><h3 id="2-4-1-总线定义"><a href="#2-4-1-总线定义" class="headerlink" title="2.4.1. 总线定义"></a>2.4.1. 总线定义</h3><ol><li><strong>总线</strong>是计算机各种功能部件之间发送信息的<strong>公共通信干线</strong>，它是CPU、内存、输入输出设备传递信息的<strong>公用通道</strong></li><li>计算机的各个部件通过<strong>总线</strong>相连接，<strong>外围设备</strong>通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</li><li>按照所传输的信息种类，总线包括<ol><li>控制线</li><li>数据线</li><li>地址线</li></ol></li></ol><h3 id="2-4-2-总线分类"><a href="#2-4-2-总线分类" class="headerlink" title="2.4.2. 总线分类"></a>2.4.2. 总线分类</h3><p>各部件的速度差异很大</p><ol><li>内部总线:用于CPU芯片内部连接各元件</li><li>系统总线:用于连接CPU、存储器和各种I&#x2F;O模块等主要部件<ol><li>PCI总线用来连接块设备</li><li>E(ISA)主要是用来处理字符型输入设备，输入速度较慢</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/13.png"></p><ol start="3"><li>通信总线:用于计算机系统之间通信</li></ol><h3 id="2-4-3-补充知识"><a href="#2-4-3-补充知识" class="headerlink" title="2.4.3 补充知识"></a>2.4.3 补充知识</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/image-20230227104516179.png" alt="image-20230227104516179"></p><h2 id="2-5-中央处理器-CPU"><a href="#2-5-中央处理器-CPU" class="headerlink" title="2.5. 中央处理器 CPU"></a>2.5. 中央处理器 CPU</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1. 定义"></a>2.5.1. 定义</h3><p>中央处理器是计算机的<strong>运算核心</strong>(Core)和<strong>控制单元</strong>(Control Unit)</p><h3 id="2-5-2-CPU的组成"><a href="#2-5-2-CPU的组成" class="headerlink" title="2.5.2. CPU的组成"></a>2.5.2. CPU的组成</h3><ol><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：<ol><li>通用寄存器</li><li>控制与状态寄存器</li><li>高速缓冲存储器(Cache)</li></ol></li><li>控制部件<ol><li>实现各部件间联系的数据、控制及状态的内部总线</li><li>负责对指令译码、发出为完成每条指令所要执行操作的控制信号、实现数据传输等功能的部件</li></ol></li></ol><h2 id="2-6-处理器和寄存器"><a href="#2-6-处理器和寄存器" class="headerlink" title="2.6. 处理器和寄存器"></a>2.6. 处理器和寄存器</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/14.png"></p><ol><li>运算单元:算术逻辑单元</li><li>控制单元:包括指令译码和中断的处理，以及一些重要的控制寄存器</li><li>内部总线</li><li>PC&#x2F;IR&#x2F;Flag:重要的控制寄存器</li><li>MAR&#x2F;MDR:和主存进行沟通的存储器</li><li>不包括的部分<ol><li>通用寄存器</li><li>Cache</li><li>IOAR&#x2F;IODR</li></ol></li></ol><h2 id="2-7-存储器的组织层次"><a href="#2-7-存储器的组织层次" class="headerlink" title="2.7. 存储器的组织层次"></a>2.7. 存储器的组织层次</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/15.png"></p><blockquote><p>主存及以上都是易失型设备</p></blockquote><h2 id="2-8-外围设备"><a href="#2-8-外围设备" class="headerlink" title="2.8. 外围设备"></a>2.8. 外围设备</h2><h3 id="2-8-1-设备类型"><a href="#2-8-1-设备类型" class="headerlink" title="2.8.1. 设备类型"></a>2.8.1. 设备类型</h3><ol><li>输入设备</li><li>输出设备</li><li>存储设备</li><li>网络设备:机机通信</li></ol><h3 id="2-8-2-控制方式"><a href="#2-8-2-控制方式" class="headerlink" title="2.8.2. 控制方式"></a>2.8.2. 控制方式</h3><ol><li>轮询方式:CPU忙式控制，CPU执行内存数据交换</li><li>中断方式:CPU启动外设，外设中断CPU，CPU执行内存数据交换</li><li>DMA方式:CPU启动DMA，DMA执行输入输出与内存数据交换，处理完成后，DMA中断CPU</li></ol><h3 id="2-8-3-SoC片上系统"><a href="#2-8-3-SoC片上系统" class="headerlink" title="2.8.3. SoC片上系统"></a>2.8.3. SoC片上系统</h3><ol><li>片上系统(SoC, System ona Chip)</li><li>在单个芯片上集成一个完整的系统，对所有或部分必要的电子电路进行包分组的技术</li><li>所谓完整的系统一般包括中央处理器(CPU)、存储器、以及外围电路等</li><li>SoC是与其它技术并行发展的，如绝缘硅(SOI)，它可以提供增强的时钟频率，从而降低微芯片的功耗</li></ol><h2 id="2-9-用户态和内核态"><a href="#2-9-用户态和内核态" class="headerlink" title="2.9. 用户态和内核态"></a>2.9. 用户态和内核态</h2><ol><li>用户态和内核态之间可以相互转化</li><li>内核态可以进行系统调用，完成中断处理</li></ol><h1 id="3-计算机软件系统"><a href="#3-计算机软件系统" class="headerlink" title="3. 计算机软件系统"></a>3. 计算机软件系统</h1><p>计算机系统三个抽象：进程抽象，虚存抽象，文件抽象</p><h2 id="3-1-计算机软件系统组成"><a href="#3-1-计算机软件系统组成" class="headerlink" title="3.1. 计算机软件系统组成"></a>3.1. 计算机软件系统组成</h2><ol><li>系统软件<ol><li>操作系统：实施对各种软硬件资源的管理控制（文件系统，进程的管理）</li><li>应用程序：为方便用户所设，如文本编辑等</li><li>语言处理程序：把用汇编语言&#x2F;高级语言编写的程序，翻译成可执行的机器语言程序</li><li>数据库管理系统</li></ol></li><li>支撑软件：支持用户使用计算机的环境，提供开发工具，也可以认为是系统软件的一部分。<ol><li>接口软件</li><li>工具软件</li><li>环境数据库等</li></ol></li><li>应用软件：是用户按其需要自行编写的专用程序</li></ol><h2 id="3-2-程序员的计算机系统视图"><a href="#3-2-程序员的计算机系统视图" class="headerlink" title="3.2. 程序员的计算机系统视图"></a>3.2. 程序员的计算机系统视图</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/16.png"></p><ol><li>计算机硬件系统:机器指令</li><li>操作系统与实用软件:扩展机器指令,系统调用、操作系统与应用软件</li><li>数据库语言:数据库管理系统，可以不再对流进行处理，而是处理对象式和关系式</li><li>语言处理系统:高级语言，变向对目标进行解决</li><li>支撑软件:使用软件工程工具</li></ol><h2 id="3-3-软件开发的不同层次"><a href="#3-3-软件开发的不同层次" class="headerlink" title="3.3. 软件开发的不同层次"></a>3.3. 软件开发的不同层次</h2><ol><li>计算机硬件系统：机器语言</li><li>操作系统之资源管理：机器语言+广义指令(扩充了硬件资源管理)</li><li>操作系统之文件系统：机器语言+系统调用(扩充了信息资源管理)</li><li>数据库管理系统：+数据库语言(扩充了功能更强的信息资源管理)</li><li>语言处理程序：面向问题的语言</li></ol><h2 id="3-4-计算机程序执行过程"><a href="#3-4-计算机程序执行过程" class="headerlink" title="3.4. 计算机程序执行过程"></a>3.4. 计算机程序执行过程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/1.png"></p><blockquote><p>源程序是如何在硬件平台上进行处理如上图进行描述</p></blockquote><h1 id="4-计算机操作技术的发展"><a href="#4-计算机操作技术的发展" class="headerlink" title="4. 计算机操作技术的发展"></a>4. 计算机操作技术的发展</h1><h2 id="4-1-操作平台与操作系统"><a href="#4-1-操作平台与操作系统" class="headerlink" title="4.1. 操作平台与操作系统"></a>4.1. 操作平台与操作系统</h2><ol><li>任意一台机器都有其操作平台与操作系统<ol><li>例子: 洗衣机<ol><li>确定水量、洗衣时间、洗涤强度、洗衣粉</li><li>启动按钮</li><li>指示灯显示工作状态</li></ol></li><li>这一方式可以总结为:开关表示，按钮控制，亮灯显示操作平台的精细化和系统化，产生了操作系统</li></ol></li><li>计算机也不例外，由此产生了极为系统的计算机操作平台——计算机操作 系统</li><li>使用汇编语言的程序的编译运行程序为：汇编、执行</li><li>使用高级语言的程序的编译运行程序为：编译、链接、执行</li></ol><h2 id="4-2-计算机的手工操作"><a href="#4-2-计算机的手工操作" class="headerlink" title="4.2. 计算机的手工操作"></a>4.2. 计算机的手工操作</h2><ol><li>开关表示，按钮控制，亮灯显示</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/18.png"></p><ol start="2"><li>问题：手工操作速度与电子计算速度不匹配</li><li>最简单的操作系统的操作，非常复杂并且容易出错。</li></ol><h2 id="4-3-装入程序的引进"><a href="#4-3-装入程序的引进" class="headerlink" title="4.3. 装入程序的引进"></a>4.3. 装入程序的引进</h2><ol><li>引入卡片和纸带描述程序指令与数据</li><li>引入装入程序(Loader)<ol><li>自动化执行程序装入，必要时进行地址转换</li><li>通常存放在ROM中</li></ol></li><li>一般执行顺序是从机器语言程序到装入程序，再到内存储器。</li><li>装入程序的数据是非常麻烦的</li></ol><h2 id="4-4-引入汇编语言后的计算机控制"><a href="#4-4-引入汇编语言后的计算机控制" class="headerlink" title="4.4. 引入汇编语言后的计算机控制"></a>4.4. 引入汇编语言后的计算机控制</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/20.png"></p><blockquote><p>添加进入高级语言之后，连接程序时非常重要的，将一些共有的操作进行封装</p></blockquote><h2 id="4-5-引入高级语言后的计算机控制"><a href="#4-5-引入高级语言后的计算机控制" class="headerlink" title="4.5. 引入高级语言后的计算机控制"></a>4.5. 引入高级语言后的计算机控制</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/21.png"></p><blockquote><p>磁带相对更加不容易断裂</p></blockquote><h2 id="4-6-简单批处理系统的操作控制"><a href="#4-6-简单批处理系统的操作控制" class="headerlink" title="4.6. 简单批处理系统的操作控制"></a>4.6. 简单批处理系统的操作控制</h2><ol><li>简单批处理系统的处理过程<ol><li>引入作业控制语言，用户编写作业说明书，描述对一次计算机求解(作业)的控制</li><li>操作员控制计算机成批输入作业，成批执行作业</li></ol></li><li>这一方式明显<strong>缩短</strong>了手工操作的时间，提高了<strong>计算机系统利用率</strong></li><li>这一阶段，磁带的出现，使得卡片与纸带等机械输入方式得以进一步提高</li><li>简单批处理系统本质上是一种<strong>半自动化</strong>的操作方式，不算操作系统<ol><li>解决了<strong>手工操作和计算机机械操作</strong>不匹配的矛盾</li><li>没有解决了<strong>手工操作与中央处理器电子操作速度</strong>不匹配的矛盾</li><li>进一步减少了慢速外设的影响</li></ol></li><li>简单批处理系统的解决方案是允许多道程序同时运行，但是没有达到真正的多道程序设计</li></ol><h2 id="4-7-操作系统与自动化操作控制"><a href="#4-7-操作系统与自动化操作控制" class="headerlink" title="4.7. 操作系统与自动化操作控制"></a>4.7. 操作系统与自动化操作控制</h2><ol><li>电子计算速度与机械I&#x2F;O速度的矛盾：你在输，我在等</li><li>在程序执行过程中能否同时输入作业重叠时间<ol><li>需要多道程序同时执行</li><li>程序切换需要高速的外存储设备</li></ol></li><li>磁盘设备出现：计算机操作系统浓墨登场，实现了计算机系统的自动化控制</li><li>机械I&#x2F;O速度是难以显著提升的。</li><li>为什么随机存储可以成为计算机操作系统出现的基础?(课本267页)<ol><li>随机存储</li><li>线性存储:线性存储</li></ol></li><li>为什么随机存取很重要呢？<ol><li>因为操作系统引入了虚拟存储，虚拟分页，虚拟的地址空间需要1000个页框，但是我只给了100个页框进行使用，命中即为是这100个。</li><li>如果没有命中，则缺页，启动缺页中断处理，然后到磁盘中查找对应的页调入，寻找相对于磁带的形式而言非常大。让用户感觉不到有磁带的延时。</li></ol></li></ol><h1 id="5-计算机操作系统-OS"><a href="#5-计算机操作系统-OS" class="headerlink" title="5. 计算机操作系统 OS"></a>5. 计算机操作系统 OS</h1><h2 id="5-1-计算机操作系统-OS-Operating-System-的定义"><a href="#5-1-计算机操作系统-OS-Operating-System-的定义" class="headerlink" title="5.1. 计算机操作系统(OS, Operating System)的定义 *"></a>5.1. 计算机操作系统(OS, Operating System)的定义 *</h2><ol><li>OS是计算机系统<strong>最基础</strong>的系统软件，管理软硬件资源、控制程序执行，改善人机界面，提供各种服务，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。<ol><li>定位(<strong>计算机系统最基础的系统软件</strong>):处于硬件之上(最接近硬件)的系统软件</li><li>用途(<strong>管理软硬件资源</strong>):<ol><li>管理硬件资源，首先进行抽象，提供系统调用和中断等服务给上层资源使用。</li><li>管理软件资源，管理文件抽象的数据资源以及在操作系统环境下可能被启动运行的应用程序，并创建成进程，然后再为进程分配相应的资源，包括CPU资源、处理器资源、外设资源和程序运行中的文件系统需要的资源。也可以映射为三个基本抽象。</li></ol></li><li>用途(<strong>控制程序的执行</strong>):在操作系统环境下，加入的软件系统的实体，要被创建成一些进程，并由操作系统来统管所有的进程。</li><li>用途(<strong>改善人机界面</strong>):操作系统最终是呈现给终端用户使用，必须改善用户界面，方便人群使用。由于操作系统定位的人群不同，则风格不同，比如服务器的命令行控制。</li><li>用途(<strong>合理组织计算机工作流程</strong>):体现资源调度和管理</li><li>总结(<strong>为用户使用计算机提供良好运行环境</strong>)</li></ol></li><li>简而言之，操作系统是方便用户、管理和控制计算机软硬件资源的系统程序集合<ol><li>从<strong>用户角度</strong>看，OS管理计算机系统的各种资源，扩充硬件的功能，控制程序的执行</li><li>从<strong>人机交互</strong>看，OS是用户与机器的接口，提供良好的人机界面，方便用户使用计算机，在整个计算机系统中具有承上启下的地位</li><li>从<strong>系统结构</strong>看，OS是一个大型软件系统，其功能复杂，体系庞大，采用层次式、模块化的程序结构</li></ol></li><li>操作系统是软件系统的核心，与硬件一同构成了各种软件的基础服务平台。</li><li>操作系统在计算机系统中的作用(P11)：<ol><li>服务用户：操作系统作为用户接口和公共服务程序。</li><li>进程交互：操作系统作为进程执行的控制者和协调者。</li><li>系统实现：操作系统作为扩展机或虚拟机。</li><li>资源管理：操作系统作为资源你的管理者和控制者。</li></ol></li></ol><h2 id="5-2-操作系统的组成"><a href="#5-2-操作系统的组成" class="headerlink" title="5.2. 操作系统的组成"></a>5.2. 操作系统的组成</h2><blockquote><p>文件系统的核心目标是实现按名存取</p></blockquote><table><thead><tr><th>操作系统组成的子系统</th><th>描述</th></tr></thead><tbody><tr><td>进程调度子系统</td><td>负责管理调度进程</td></tr><tr><td>进程通信子系统</td><td>负责进程间的通信解决方案</td></tr><tr><td>内存管理子系统</td><td>负责管理内存与虚存</td></tr><tr><td>设备管理子系统</td><td>负责管理我们的外围设备</td></tr><tr><td>文件管理子系统</td><td>负责管理文件信息，提供系统调用，Linux需要考虑如何在线性的地址空间，如何建立非线性的层次式目录结构以实现按名存储</td></tr><tr><td>网络通信子系统</td><td>实现网络操作系统，涉及到分布式等</td></tr><tr><td>作业控制子系统</td><td>提供用户操作控制计算机系统，在服务器、云计算等资源虚拟化环境下</td></tr></tbody></table><h2 id="5-3-操作系统的类型"><a href="#5-3-操作系统的类型" class="headerlink" title="5.3. 操作系统的类型"></a>5.3. 操作系统的类型</h2><h3 id="5-3-1-从控制方式来看"><a href="#5-3-1-从控制方式来看" class="headerlink" title="5.3.1. 从控制方式来看"></a>5.3.1. 从控制方式来看</h3><ol><li>多道批处理操作系统<ol><li>采用<strong>脱机控制</strong>方式</li><li>程序员通过作业说明来描述对作业的控制方式</li><li>操作员根据说明书来成批加载作业和控制计算机系统</li><li>优点：资源利用率高，作业吞吐量大</li><li>缺点：作业周转周期长、不具备交互式计算能力，不利于程序的开发和测试</li></ol></li><li>分时(Time Sharing)操作系统:交互控制，核心是划分CPU的时间<ol><li>时间片调度思想:CPU的时间等分</li><li>在终端上进行交互式会话，具有同时性、独立性、及时性和交互性的特点。</li><li>和批处理操作系统区别：追求目标、适应作业、资源利用率不同。</li><li>Eg:100MHz的CPU，如果有10个终端用户使用，那么一个终端用户大概使用10MHz的CPU来使用</li></ol></li><li>实时(Real Timing)操作系统:支持分时交互，又有大量的进程处理突发任务<ol><li>硬实时:最严格的实时操作系统</li><li>软实时:可以在某些地方不严格</li></ol></li><li>如果某个操作系统兼具批处理、分时和实时处理的全部或两种功能，则可以被称为通用操作系统。</li></ol><h3 id="5-3-2-从应用领域领域来看"><a href="#5-3-2-从应用领域领域来看" class="headerlink" title="5.3.2. 从应用领域领域来看"></a>5.3.2. 从应用领域领域来看</h3><ol><li>服务器操作系统:并行操作系统</li><li>网络操作系统:分布式操作系统</li><li>个人机操作系统:手机操作系统</li><li>嵌入式操作系统:传感器操作系统</li></ol><h2 id="5-4-操作系统功能和特性"><a href="#5-4-操作系统功能和特性" class="headerlink" title="5.4. 操作系统功能和特性"></a>5.4. 操作系统功能和特性</h2><h3 id="5-4-1-操作系统功能"><a href="#5-4-1-操作系统功能" class="headerlink" title="5.4.1. 操作系统功能"></a>5.4.1. 操作系统功能</h3><ol><li>处理器管理：对处理器的管理和调度最终归结为对进程和线程的管理和调度，最大限度提高处理器利用率。</li><li>存储管理：管理内存资源，提供存储空间利用率。</li><li>设备管理：管理各种外部设备，完成用户提出的I&#x2F;O请求;加快数据传输速度，发挥设备的并行性，提高设备的利用率;提供设备驱动程序和中断处理程序,为用户隐蔽硬件操作细节，提供简单的设备使用方法</li><li>文件管理：针对信息资源的管理。</li><li>联网与通信管理：<ol><li>网络资源管理</li><li>数据通信管理</li><li>应用服务</li><li>网络管理</li></ol></li></ol><h3 id="5-4-2-操作系统特性"><a href="#5-4-2-操作系统特性" class="headerlink" title="5.4.2. 操作系统特性"></a>5.4.2. 操作系统特性</h3><ol><li>并发性：<ol><li>并发性指两个或两个以上的活动或事件在同一时间间隔内发生。</li><li>采用并发技术的系统又称多任务处理系统</li><li>并行性指两个或两个以上的活动或事件在同一时刻发生，存在于多CPU系统中。</li><li>并行一定并发，并发不一定并行</li><li>并发的关键技术是对系统的多个运行程序(进程)进行切换的技术。</li></ol></li><li>共享性：<ol><li>计算机系统中的资源可以被多个并发执行的程序共同使用，而不是被某个程序独占</li><li>划分：<ol><li>透明资源共享：必须处理好资源隔离和授权访问问题</li><li>独占资源共享：排他性地使用一类资源</li></ol></li></ol></li><li>并发性和共享性互相依存，没有并发就不必讨论共享，做不到共享也就导致做不到并发。</li><li>异步性(随机性)：并发活动导致随机事件的产生。操作系统需要保证只要运行环境相同，多次运行同一程序，都会获得完全相同的计算结果。</li></ol><h2 id="5-5-操作系统的形成"><a href="#5-5-操作系统的形成" class="headerlink" title="5.5. 操作系统的形成"></a>5.5. 操作系统的形成</h2><ol><li>中断和通道技术的出现使得硬件具备并行工作的能力。</li></ol><h1 id="6-操作系统资源管理"><a href="#6-操作系统资源管理" class="headerlink" title="6. 操作系统资源管理"></a>6. 操作系统资源管理</h1><blockquote><ol><li>解决物理资源数量不足的问题</li><li>合理分配资源</li><li>实现资源的易用性</li></ol></blockquote><ol><li>硬件资源：处理器、内存和外设(字符型设备等)</li><li>信息资源(可以理解为软件资源)：数据和程序</li></ol><h2 id="6-1-管理计算机系统的软硬件资源"><a href="#6-1-管理计算机系统的软硬件资源" class="headerlink" title="6.1. 管理计算机系统的软硬件资源"></a>6.1. 管理计算机系统的软硬件资源</h2><ol><li>处理器资源：哪个程序占有处理器运行？</li><li>内存资源：程序&#x2F;数据在内存中如何分布？</li><li>设备管理：如何分配、去配和使用设备？</li><li>信息资源管理：如何访问文件信息？</li><li>信号量资源：如何管理进程之间的通信？信号量(-&gt;数据结构)与PV原理(-&gt;原语操作):重要</li></ol><h2 id="6-2-资源管理最重要的是：屏蔽资源使用的底层细节"><a href="#6-2-资源管理最重要的是：屏蔽资源使用的底层细节" class="headerlink" title="6.2. 资源管理最重要的是：屏蔽资源使用的底层细节"></a>6.2. 资源管理最重要的是：屏蔽资源使用的底层细节</h2><ol><li>驱动程序：最底层的、直接控制和监视各类硬件(或文件)资源的部分</li><li>职责是<strong>隐藏底层硬件的具体细节</strong>，并向<strong>其他部分提供一个抽象的、通用的接口</strong></li><li>比如说：打印一段文字或一个文件，既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节</li></ol><h2 id="6-3-资源管理技术"><a href="#6-3-资源管理技术" class="headerlink" title="6.3. 资源管理技术"></a>6.3. 资源管理技术</h2><ol><li>复用<ol><li>空分复用共享，例如内存和外存资源是空分复用的关系、磁盘上进行空分复用</li><li>时分复用共享<ol><li>按照资源物理特性分为<ol><li>独占式</li><li>时分共享式</li></ol></li><li>例如：磁带机与磁盘机</li></ol></li></ol></li><li>虚拟(虚拟性)<ol><li>本质：对资源进行转化、模拟或整合，将一个物理资源变成多个逻辑上的对应物，也可以将多个物理资源编程单个逻辑上的对应物，达到多个用户共享一套计算机物理资源的目的。</li><li>复用划分实际存在的物理资源，虚拟则实现假想的虚拟同类资源。</li><li>例子：虚拟内存、虚拟文件系统(VFS)。</li></ol></li><li>抽象：<ol><li>目的：为了处理系统复杂性，重点解决资源易用性。</li><li>资源抽象：不考虑物理细节而对资源执行操作的技术。</li><li>抽象层次越高，使用越方便。</li></ol></li><li>组合使用多种资源管理技术</li></ol><h2 id="6-4-重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象"><a href="#6-4-重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象" class="headerlink" title="6.4. 重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象"></a>6.4. 重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象</h2><ol><li>计算机物理资源划分：<ol><li>计算及存储类：包含处理器和内存等</li><li>接口类：包含外存和外部处理器等</li></ol></li><li>为方便对物理资源的管理和控制，现代操作系统引入了：进程、虚拟和文件，形成了三种最基础的抽象。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/3.png"></p><h3 id="6-4-1-进程抽象"><a href="#6-4-1-进程抽象" class="headerlink" title="6.4.1. 进程抽象"></a>6.4.1. 进程抽象</h3><ol><li>进程是对进入内存的执行程序在处理器上操作的状态集的一个抽象。</li><li>进程是并发和并行操作的基础。</li><li>进程可以使用fork()、wait()、exec()等系统调用。</li><li>进程的执行依赖于内存和设备上的信息资源。</li></ol><h3 id="6-4-2-虚存抽象"><a href="#6-4-2-虚存抽象" class="headerlink" title="6.4.2. 虚存抽象"></a>6.4.2. 虚存抽象</h3><ol><li>虚拟内存的本质是在物理内存的基础上创建一个新的抽象概念。</li><li>虚存抽象保证了安全性</li><li>进程的执行还依赖于存放在内存中的程序和数据，而他们往往存储在设备上，所以我们需要对设备进行抽象。</li></ol><h3 id="6-4-3-文件抽象"><a href="#6-4-3-文件抽象" class="headerlink" title="6.4.3. 文件抽象"></a>6.4.3. 文件抽象</h3><ol><li>文件是设备的一种抽象，通过将文件的字节映射到存储设备的物理块中来实现文件抽象。</li><li>提供了open()、read()和write()等方法来控制和使用文件。</li><li>磁盘、光盘等外存设备都有极其复杂的物理接口，通常我们将其抽象，使得所存放柜的信息可以表示为一个命名的逻辑字节流，称其为文件，这是资源抽象的一个特例。</li><li>为了管理方便，操作系统将除处理器和内存以外，将磁盘和其他外部设备资源都抽象为文件，减少系统开销，复用系统调用。</li></ol><h3 id="6-4-4-三种抽象综述"><a href="#6-4-4-三种抽象综述" class="headerlink" title="6.4.4. 三种抽象综述"></a>6.4.4. 三种抽象综述</h3><ol><li>操作系统基本任务<ol><li>防止硬件资源被失控的应用程序滥用。</li><li>屏蔽复杂的硬件操作细节。</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/2.png"></p><h3 id="6-4-5-其他资源抽象"><a href="#6-4-5-其他资源抽象" class="headerlink" title="6.4.5. 其他资源抽象"></a>6.4.5. 其他资源抽象</h3><ol><li>与设备抽象相似，操作系统还对其他底层硬件资源进行了抽象。</li><li>资源抽象也可以用于没有特定基础硬件的软甲资源，如信息、信号量和共享数据结构。</li><li>对象和抽象数据类型是常用于创建抽象资源的软件机制。</li></ol><h2 id="6-5-操作系统虚拟机"><a href="#6-5-操作系统虚拟机" class="headerlink" title="6.5. 操作系统虚拟机"></a>6.5. 操作系统虚拟机</h2><ol><li>物理CPU：时分共享复用，实现虚处理器</li><li>物理内存：虚拟存储技术，实现虚内存</li><li>独占型I&#x2F;O设备：SPOOLing技术，实现虚设备</li><li>磁盘设备：通过文件抽象，实现虚外存</li></ol><h2 id="6-6-资源的共享与分配方式"><a href="#6-6-资源的共享与分配方式" class="headerlink" title="6.6. 资源的共享与分配方式"></a>6.6. 资源的共享与分配方式</h2><ol><li>资源共享方式<ol><li><strong>独占</strong>使用方式:只能被一个程序使用</li><li><strong>并发</strong>使用方式:在同一时段可以被多个程序使用，虚拟共享Spooling</li></ol></li><li>资源分配策略:对于独占使用方式的分配方式<ol><li><strong>静态</strong>分配方式，运行程序进入内存前已经将所有的内存完成分配，好处是不会死锁，坏处是效率低，使用效率低</li><li><strong>动态</strong>分配方式，随用随分配，可能导致死锁</li><li><strong>资源抢占</strong>方式，如果你在使用，我的优先级高，我可以抢过来使用，但是涉及到保存状态的问题</li></ol></li></ol><h1 id="7-程序控制角度"><a href="#7-程序控制角度" class="headerlink" title="7. 程序控制角度"></a>7. 程序控制角度</h1><h2 id="7-1-多道程序同时计算"><a href="#7-1-多道程序同时计算" class="headerlink" title="7.1. 多道程序同时计算"></a>7.1. 多道程序同时计算</h2><ol><li>CPU速度与I&#x2F;O速度不匹配的矛盾，非常突出</li><li>只有让多道程序同时进入内存争抢CPU运行，才可以够使得CPU和外围设备充分并行，从而提高计算机系统的使用效率</li><li>例如：百度的搜索引擎</li></ol><h2 id="7-2-多道程序同时计算例子"><a href="#7-2-多道程序同时计算例子" class="headerlink" title="7.2. 多道程序同时计算例子"></a>7.2. 多道程序同时计算例子</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/5.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/23.png"></th></tr></thead></table><ol><li>对于甲、乙两道程序，如果两个程序的操作之间是没有冲突的<ol><li>独占计算机单道运行时均需1小时，占用CPU时间18分钟，CPU利用率为30％</li><li>按多道程序设计方法同时运行，CPU利用率50%，由于要提供36分钟的CPU时间，大约运行72分钟。考虑到OS调度开销，实际花费时间还要长些，如80分钟</li></ol></li><li>就处理两道作业而言，提高效率33％，整体的系统的吞吐率会高</li><li>就单道作业而言，延长执行时间20分钟，即延长了33％的时间</li><li>可以采用概率方法计算CPU的利用率，假设程序平均等待I&#x2F;O 操作的时间占其运行时间的比例为P，当内存中有n道程序时，所有程序都等待I&#x2F;O操作的概率是$P^n$，即此时CPU利用率&#x3D;$1-P^n$，其中n称为多道程序的道数或度数</li></ol><h2 id="7-3-多道程序设计及优点"><a href="#7-3-多道程序设计及优点" class="headerlink" title="7.3. 多道程序设计及优点"></a>7.3. 多道程序设计及优点</h2><ol><li>多道程序设计：<strong>指允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法</strong></li><li>多道程序设计的特点<ol><li>CPU与外部设备充分并行</li><li>外部设备之间充分并行</li><li>发挥CPU、内存和设备的使用效率</li><li>提高单位时间的算题量(吞吐率)</li></ol></li><li>多道程序设计的主要缺点：延长了作业的周转时间。</li></ol><h2 id="7-4-多道程序系统的实现"><a href="#7-4-多道程序系统的实现" class="headerlink" title="7.4. 多道程序系统的实现"></a>7.4. 多道程序系统的实现</h2><ol><li>进入内存执行的程序建立管理实体：<strong>进程</strong>动态概念，驻留在操作系统中</li><li>OS应该能管理与控制进程程序的执行</li><li>OS协调管理各类资源在进程间的使用<ol><li>处理器的管理和调度</li><li>主存储器的管理和调度</li><li>其他资源的管理和调度</li><li>信号量的管理和调度</li></ol></li></ol><h2 id="7-5-多道程序系统的实现要点"><a href="#7-5-多道程序系统的实现要点" class="headerlink" title="7.5. 多道程序系统的实现要点"></a>7.5. 多道程序系统的实现要点</h2><ol><li>如何使用资源：调用操作系统提供的服务例程(如何陷入操作系统)</li><li>如何复用CPU：调度程序(在CPU空闲时让其他程序运行)</li><li>如何使CPU与I&#x2F;O设备充分并行：设备控制器与通道(专用的I&#x2F;O处理器)</li><li>如何让正在运行的程序让出CPU：中断(中断正在执行的程序，引入OS处理)，能够恢复现场而不是从头运行</li><li>需要注意的是道数是受到物理资源的制约的。</li></ol><h2 id="7-6-多道程序系统需要处理的问题"><a href="#7-6-多道程序系统需要处理的问题" class="headerlink" title="7.6. 多道程序系统需要处理的问题"></a>7.6. 多道程序系统需要处理的问题</h2><ol><li>存储保护与程序浮动</li><li>处理器管理与分配</li><li>资源管理与调度</li></ol><h1 id="8-操作系统控制计算机的角度"><a href="#8-操作系统控制计算机的角度" class="headerlink" title="8. 操作系统控制计算机的角度"></a>8. 操作系统控制计算机的角度</h1><h2 id="8-1-计算机系统操作方式"><a href="#8-1-计算机系统操作方式" class="headerlink" title="8.1. 计算机系统操作方式"></a>8.1. 计算机系统操作方式</h2><ol><li>OS规定了合理操作计算机的工作流程</li><li>OS的操作接口——系统程序：OS提供给用户的功能级接口，为用户提供的解决操作计算机和计算共性问题的所有服务的集合</li><li>OS的两类作业级接口<ol><li>脱机作业控制方式：作业控制语言，比如批处理</li><li>联机作业控制方式：操作控制命令</li></ol></li></ol><h3 id="8-1-1-脱机作业控制方式"><a href="#8-1-1-脱机作业控制方式" class="headerlink" title="8.1.1. 脱机作业控制方式"></a>8.1.1. 脱机作业控制方式</h3><ol><li>脱机作业控制的各角色工作<ol><li>OS提供<strong>作业说明语言</strong>，通过作业控制程序自动控制作业的执行</li><li>用户编写<strong>作业说明书</strong>，确定作业加工控制步骤，并与程序数据一并提交</li><li>操作员通过控制台输入作业</li></ol></li><li>例：批处理OS的作业控制方式，UNIX的shell程序，DOS的bat文件</li><li>多道批处理：可以多道作业交替占用处理器运行</li></ol><h3 id="8-1-2-联机作业控制方式"><a href="#8-1-2-联机作业控制方式" class="headerlink" title="8.1.2. 联机作业控制方式"></a>8.1.2. 联机作业控制方式</h3><ol><li>联机作业控制方式的各角色工作<ol><li>计算机提供终端</li><li>用户登录系统</li><li>OS提供命令解释程序</li><li>用户进行联机输入命令，直接控制作业步的执行</li></ol></li><li>例：分时OS的交互控制方式</li><li>图形化无非就是把上述操作图形化了而已</li></ol><h2 id="8-2-命令解释程序"><a href="#8-2-命令解释程序" class="headerlink" title="8.2. 命令解释程序"></a>8.2. 命令解释程序</h2><ol><li>命令解释程序：接受和执行一条用户提出的对作业的加工处理命令</li><li>当一个新的批作业被启动，或新的交互型用户登录进系统时，系统就自动地执行命令解释程序，负责读入控制卡或命令行，作出相应解释，并予以执行</li><li>实现方式<ol><li>命令解释语言包含命令的执行代码，一旦收到命令后，就转向相应的命令处理代码执行，执行过程中往往会使用到系统调用</li><li>由专用的实用程序实现，执行时将命令所对应的命令处理文件装入内存</li></ol></li><li>会话语言：可编程的命令解释程序，UNIX的Shell</li><li>图形化的命令控制方式</li><li>多通道交互的命令控制方式</li></ol><h2 id="8-3-命令解释程序的处理过程"><a href="#8-3-命令解释程序的处理过程" class="headerlink" title="8.3. 命令解释程序的处理过程"></a>8.3. 命令解释程序的处理过程</h2><ol><li>OS启动命令解释程序，输出命令提示符，等待键盘中断&#x2F;鼠标点击&#x2F;多通道识别</li><li>每当用户输入一条命令(暂存在命令缓冲区)并按回车换行时，申请中断</li><li>CPU响应后，将控制权交给命令解释程序，接着读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li><li>前台命令执行结束后，再次输出命令提示符，等待下一条命令</li><li>后台命令处理启动后，即可接收下条命令</li></ol><h2 id="8-4-OS内核是中断驱动的"><a href="#8-4-OS内核是中断驱动的" class="headerlink" title="8.4. OS内核是中断驱动的"></a>8.4. OS内核是中断驱动的</h2><blockquote><p>等价表述</p></blockquote><ol><li>OS内核是中断驱动的</li><li>中断是激活操作系统的唯一方式</li></ol><h1 id="9-人机交互的角度"><a href="#9-人机交互的角度" class="headerlink" title="9. 人机交互的角度"></a>9. 人机交互的角度</h1><ol><li>OS改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括<strong>传统的终端设备</strong>和<strong>新型的模式识别设备</strong></li><li>OS的人机交互部分用于<strong>控制有关设备运行</strong>和<strong>理解执行设备传来的命令</strong></li><li>人机交互功能是决定计算机系统<strong>友善性</strong>的重要因素，是当今OS<strong>研发热点</strong></li></ol><h2 id="9-1-人机交互的初期发展"><a href="#9-1-人机交互的初期发展" class="headerlink" title="9.1. 人机交互的初期发展"></a>9.1. 人机交互的初期发展</h2><ol><li>交互式控制方式<ol><li>行命令控制方式：1960年代开始使用，一行一行进行编辑</li><li>全屏幕控制方式：1970年代开始使用</li></ol></li><li>斯坦福研究所提出的发展计划<ol><li>始于1960年代，1980年代广泛应用</li><li>强调<strong>人</strong>而不是<strong>技术</strong>是<strong>人机交互</strong>的中心</li><li>代表性成果：鼠标、菜单与窗口控制(单窗口)</li></ol></li></ol><h2 id="9-2-人机交互发展-WIMP界面"><a href="#9-2-人机交互发展-WIMP界面" class="headerlink" title="9.2. 人机交互发展-WIMP界面"></a>9.2. 人机交互发展-WIMP界面</h2><ol><li>缘起：70年代后期Xerox的原型机Star</li><li>特征：窗口(Windows) (多窗口)、图标(Icons)、菜单(Menu) 和指示装置(Pointing Devices)为基础的图形用户界面WIMP</li><li>得益：Apple最初采用并大力推动</li><li>时间：1990年代开始广泛使用</li><li>不足：不允许同时使用多个交互通道，从而产生人-机交互的不平衡</li><li>Apple的界面是WIWP的顶峰</li></ol><h2 id="9-3-人机交互发展-多媒体计算机"><a href="#9-3-人机交互发展-多媒体计算机" class="headerlink" title="9.3. 人机交互发展-多媒体计算机"></a>9.3. 人机交互发展-多媒体计算机</h2><ol><li>缘起：1985年的MPC</li><li>把音频视屏、图形图像和人机交互控制结合起来，进行综合处理的计算机系统</li><li>构成：多媒体硬件平台、多媒体OS 、图形用户接口、多媒体数据开发工具</li><li>提供与时间有关的<strong>时变媒体(何时体现感觉更好)<strong>界面，既控制</strong>信息呈现</strong>，也控制何<strong>时呈现&#x2F;如何呈现</strong></li><li>人机交互界面需要使用多种媒体，同时支持多通道交互整合，改善用户体验</li></ol><h2 id="9-4-人机交互发展-虚拟现实系统-临境系统"><a href="#9-4-人机交互发展-虚拟现实系统-临境系统" class="headerlink" title="9.4. 人机交互发展-虚拟现实系统(临境系统)"></a>9.4. 人机交互发展-虚拟现实系统(临境系统)</h2><ol><li>缘起：1980年代的虚拟现实新型用户界面</li><li>VR通过计算机模拟三维虚拟世界，根据<strong>观察点</strong>、观察点改变的<strong>导航</strong>和对周围对象的操作，来模拟<strong>临境</strong>(身临其境)的感觉</li><li>支持多通道交互整合，改善用户体验</li><li>支持用户主动参与的高度自然的<strong>三维</strong>HCI，以及<strong>语音识别、头部跟踪、视觉跟踪、姿势识别</strong>等新型HCI</li><li>容许用户产生含糊和不精确的输入</li></ol><h1 id="10-程序接口的角度"><a href="#10-程序接口的角度" class="headerlink" title="10. 程序接口的角度"></a>10. 程序接口的角度</h1><h2 id="10-1-系统调用"><a href="#10-1-系统调用" class="headerlink" title="10.1. 系统调用"></a>10.1. 系统调用</h2><ol><li>操作系统的程序接口：系统调用<ol><li>操作系统实现的完成某种特定功能的过程</li><li>为所有运行程序提供访问操作系统的接口</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/24.png"></p><ol start="3"><li>为什么会出现系统调用？对上层如果暴露过于细粒度的操作，违背了<strong>软件复用</strong>的原则，所以我们将一系列的操作封装起来，作为系统调用来暴露。</li><li>为什么操作系统不能使用名空间?(没有高级语言，为什么不可以通过名字来调用):操作系统处于系统底层之上，是不可以将高阶的名字，翻译成计算机操作系统可以理解的地址。底层是通过地址号来调用，而我们的按名访问本质上也只是完成了从名空间到地址空间的映射而已<ol><li>操作系统诞生了名空间</li><li>文件系统需要使用名空间</li></ol></li><li>以32位系统为例，每个地址占4字节，以入口地址表的起地址$x_0$作为起点，依据功能号向下偏移$4*i$，读取系统调用处理子程序$Sub_i$的入口地址，然后执行$SUB_i$，执行完成之后，再返回用户空间。</li><li>没有名称空间 -&gt; 通过指针的地址计算做定位，表驱动按号索引，按号索引的前提是:<ol><li>数据必须是按号连续排列的</li><li>表中的各数据结构的规格是一致的</li></ol></li></ol><h2 id="10-2-系统调用的实现机制"><a href="#10-2-系统调用的实现机制" class="headerlink" title="10.2. 系统调用的实现机制"></a>10.2. 系统调用的实现机制</h2><ol><li>陷入处理机制：计算机系统中控制和实现系统调用的机制</li><li>陷入指令：也称<strong>访管指令</strong>，或<strong>异常中断指令</strong>，计算机系统为实现系统调用而引起处理器中断的指令</li><li>每个系统调用都事先规定了<strong>编号</strong>，并在<strong>约定</strong>寄存器中规定了传递给内部处理程序的参数</li><li>参数传递方法<ol><li>访管指令或自陷指令自带参数，参数放置在指令后的若干单元，叫直接参数</li><li>指令后放置参数的地址，叫间接指令</li><li>通过CPU的通用寄存器传递参数，不适用于大量参数传递</li><li>在内存中开辟专门堆栈区传递参数</li></ol></li><li>操作系统实现系统调用的机制被称为陷阱或异常处理机制。</li><li>由系统调用引起处理器中断的机器指令称为访管指令、自陷指令或中断指令，其中访管指令为非特权指令。</li></ol><h2 id="10-3-系统调用的实现要点"><a href="#10-3-系统调用的实现要点" class="headerlink" title="10.3. 系统调用的实现要点"></a>10.3. 系统调用的实现要点</h2><ol><li>编写系统调用处理程序</li><li>设计一张<strong>系统调用入口地址表</strong>，每个入口地址指向一个系统调用的处理程序，并包含系统调用自带参数的个数</li><li>陷入处理机制需开辟现场保护区，以保存发生系统调用时的处理器现场</li></ol><h2 id="10-4-系统调用的实现流程"><a href="#10-4-系统调用的实现流程" class="headerlink" title="10.4. 系统调用的实现流程"></a>10.4. 系统调用的实现流程</h2><ol><li>由硬件和操作系统来合作完成<ol><li>中断是由硬件完成的</li><li>查入口地址和调用是由操作系统完成的</li></ol></li><li>CPU执行程序中编写的由访管指令实现的系统调用时会产生异常，通过陷阱机制，处理器的状态由用户态转换为内核态，进入操作系统并执行相应的服务例程，以获得操作系统服务。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/7.png"></p><blockquote><ol><li>SUB子程序部分是绝对不能向用户暴露的，很危险</li><li>A部分，可以通过地址偏移来发起调用，$4*i+x_0$调用的是第i号系统调用。</li></ol></blockquote><ol><li>处理器状态包括用户态、内核态<ol><li>用户态对应非特权指令</li><li>内核态对应特权和非特权指令</li></ol></li><li>Linux中是通过为每个系统调用构造一个同名封装函数，将系统调用封装后供用户编程使用，详见P25</li></ol><h3 id="10-4-1-Transition-from-user-to-kernel-mode"><a href="#10-4-1-Transition-from-user-to-kernel-mode" class="headerlink" title="10.4.1. Transition from user to kernel mode"></a>10.4.1. Transition from user to kernel mode</h3><ol><li>特权指令和非特权指令混编实现代码</li><li>如下图的Linux系统调用执行流程：两个进程之间切换，会损失一定的时间(内核消耗时间)，应该是会非常快速的进行切换的。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/4.png"></p><blockquote><p>更多过程见课本P31-34</p></blockquote><h2 id="10-5-系统调用和函数调用之间的区别"><a href="#10-5-系统调用和函数调用之间的区别" class="headerlink" title="10.5. 系统调用和函数调用之间的区别"></a>10.5. 系统调用和函数调用之间的区别</h2><table><thead><tr><th></th><th>系统调用</th><th>函数调用</th></tr></thead><tbody><tr><td>调用形式</td><td>按地址转向</td><td>功能号调用</td></tr><tr><td>实现方式</td><td>用户态转换内核态，在内核态执行访问核心栈</td><td>用户态</td></tr><tr><td>被调用代码位置</td><td>动态调用，服务例程位于操作系统内</td><td>静态调用，调用程序和被调用程序在同一程序内</td></tr><tr><td>提供方式</td><td>由操作系统提供</td><td>编程语言提供</td></tr></tbody></table><h1 id="11-系统结构的角度"><a href="#11-系统结构的角度" class="headerlink" title="11. 系统结构的角度"></a>11. 系统结构的角度</h1><h2 id="11-1-操作系统软件的规模"><a href="#11-1-操作系统软件的规模" class="headerlink" title="11.1. 操作系统软件的规模"></a>11.1. 操作系统软件的规模</h2><ol><li>在计算机软件发展史上，OS是第一个大规模的软件系统</li><li>1960年代，由OS开发所衍生的体系结构、模块化开发、测试与验证、演化与维护等研究，直接催生了软件工程这一新兴研究领域(另一个催生来源是DB应用引发的需求与规格)</li><li>OS作为大型软件，结构设计是关键</li></ol><h2 id="11-2-操作系统软件的结构设计"><a href="#11-2-操作系统软件的结构设计" class="headerlink" title="11.2. 操作系统软件的结构设计"></a>11.2. 操作系统软件的结构设计</h2><blockquote><p>内核设计是OS设计中最为复杂的部分</p></blockquote><h3 id="11-2-1-OS构件"><a href="#11-2-1-OS构件" class="headerlink" title="11.2.1. OS构件"></a>11.2.1. OS构件</h3><ol><li>内核:核心的部分，操作系统必须有一个内核<ol><li>一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作，通常驻留在内核空间，运行于内核他，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。</li><li>内核的功能<ol><li>中断处理</li><li>时钟管理</li><li>短程调度</li><li>原语管理：原语是内核中实现特定功能的不可中断过程<ol><li>原语由内核实现，系统调用由系统进程实现</li><li>例子：通信原语、同步原语、I&#x2F;O设备原语</li></ol></li></ol></li><li>内核的属性<ol><li>内核是由中断驱动的</li><li>内核是不可抢占的</li><li>内核可以在屏蔽中断状态下进行</li><li>内核可以使用特权指令</li></ol></li></ol></li><li>进程</li><li>线程</li><li>管程</li></ol><h3 id="11-2-2-设计概念"><a href="#11-2-2-设计概念" class="headerlink" title="11.2.2. 设计概念"></a>11.2.2. 设计概念</h3><ol><li>模块化</li><li>层次式</li><li>虚拟化</li></ol><h3 id="11-2-3-操作系统内核"><a href="#11-2-3-操作系统内核" class="headerlink" title="11.2.3. 操作系统内核"></a>11.2.3. 操作系统内核</h3><ol><li>单内核：内核中各部件杂然混居的形态，始于1960年代，广泛使用；如Unix&#x2F;Linux，及Windows(自称采用混合内核的CS结构)，单内核导致内核会非常大</li></ol><blockquote><p>单内核结构的操作系统:写错了的Tanebaum,2015</p></blockquote><ol start="2"><li>微内核：<ol><li>仅将所有应用必须的核心功能放入内核，其他功能都在内核之外，由在用户态运行的服务进程实现</li><li>1980年代始，强调结构性部件与功能性部件的分离，大部分OS研究都集中在此，效率不高</li><li>详见课本P37页</li></ol></li></ol><blockquote><p>微内核结构的操作系统，存在一定的不确定性，会增加切换的次数，带来一定的性能损耗</p></blockquote><ol start="3"><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行，以获得更快的执行速度</li><li>外内核：尽可能减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化；部分嵌入式系统使用</li></ol><blockquote><p>安卓内核架构、C&#x2F;S(Client&#x2F;Server)模型</p></blockquote><h3 id="11-2-4-单内核和微内核对比"><a href="#11-2-4-单内核和微内核对比" class="headerlink" title="11.2.4. 单内核和微内核对比"></a>11.2.4. 单内核和微内核对比</h3><h3 id="11-2-5-鸿蒙操作系统的软件架构"><a href="#11-2-5-鸿蒙操作系统的软件架构" class="headerlink" title="11.2.5. 鸿蒙操作系统的软件架构"></a>11.2.5. 鸿蒙操作系统的软件架构</h3><h2 id="11-3-操作系统实现的层次结构"><a href="#11-3-操作系统实现的层次结构" class="headerlink" title="11.3. 操作系统实现的层次结构"></a>11.3. 操作系统实现的层次结构</h2><h3 id="11-3-1-操作系统实现的第一种层次结构"><a href="#11-3-1-操作系统实现的第一种层次结构" class="headerlink" title="11.3.1. 操作系统实现的第一种层次结构"></a>11.3.1. 操作系统实现的第一种层次结构</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/8.png"></p><ol><li>现在文件系统也会划归到内核中</li></ol><h3 id="11-3-2-操作系统实现的第二种层次结构"><a href="#11-3-2-操作系统实现的第二种层次结构" class="headerlink" title="11.3.2. 操作系统实现的第二种层次结构"></a>11.3.2. 操作系统实现的第二种层次结构</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/9.png"></p><ol><li>过程机制、指令解译、电路执行是由硬件完成，实现中断等机制。</li><li>当前操作系统除了硬件电路以外都是由操作系统管理</li></ol><h1 id="12-补充"><a href="#12-补充" class="headerlink" title="12. 补充"></a>12. 补充</h1><ol><li>$i++$ 返回成机器指令:<ol><li>$i -&gt; R_0$</li><li>$R_0 + 1 -&gt; R_0$</li><li>$R_0 -&gt; i$</li></ol></li></ol><h1 id="13-操作系统运行模型"><a href="#13-操作系统运行模型" class="headerlink" title="13. 操作系统运行模型"></a>13. 操作系统运行模型</h1><p>P42-44</p><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-需求分析方法</title>
    <link href="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1/"/>
    <url>/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
