<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>06-需求分析方法</title>
    <link href="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/"/>
    <url>/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/</url>
    
    <content type="html"><![CDATA[<h2 id="06-需求分析方法"><a href="#06-需求分析方法" class="headerlink" title="06-需求分析方法"></a>06-需求分析方法</h2><p>重要：注意完成课本习题</p><h1 id="1-用例文档的格式情况"><a href="#1-用例文档的格式情况" class="headerlink" title="1. 用例文档的格式情况"></a>1. 用例文档的格式情况</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/1.png"></p><h1 id="2-需求分析基础"><a href="#2-需求分析基础" class="headerlink" title="2. 需求分析基础"></a>2. 需求分析基础</h1><h2 id="2-1-为什么要需求分析"><a href="#2-1-为什么要需求分析" class="headerlink" title="2.1. 为什么要需求分析"></a>2.1. 为什么要需求分析</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/2.png"></p><ol><li>需求不是属于用户的，是应该是需求人员提出来的</li></ol><h2 id="2-2-需求分析的任务"><a href="#2-2-需求分析的任务" class="headerlink" title="2.2. 需求分析的任务"></a>2.2. 需求分析的任务</h2><ol><li>建⽴<strong>分析模型</strong>，达成开发者和用户对需求信息的共同理解:分析将复杂的系统分解为简单的部分以及它们之间的联系，确定本质特征，抛弃次要特征。</li><li>依据共同的理解，<strong>发挥创造性</strong>，创建软件系统解决方案:分析可以将一个问题分解为独立的、更简单的和易于管理的子问题来帮助寻找解决方案</li></ol><h2 id="2-3-需求分析的模型与建模"><a href="#2-3-需求分析的模型与建模" class="headerlink" title="2.3. 需求分析的模型与建模"></a>2.3. 需求分析的模型与建模</h2><h3 id="2-3-1-模型"><a href="#2-3-1-模型" class="headerlink" title="2.3.1. 模型"></a>2.3.1. 模型</h3><ol><li>“模型是对事物的抽象，帮助⼈们在创建一个事物之前可以有更好的理解”[Blaha2005]</li><li>为了更好地理解需求获取所得到的复杂信息，需要集中关注问题的计算特性(数据、功能、规则等)，建立相关的软件模型</li></ol><h3 id="2-3-2-建模"><a href="#2-3-2-建模" class="headerlink" title="2.3.2. 建模"></a>2.3.2. 建模</h3><ol><li>建立模型的过程被称为建模。”它是对系统进行思考和推理的一种方式。建模的目标是建立系统的一个表示，这个表示以精确⼀致的方式描述系统，使得系统的使用更加容易”[Fishwick1994]。</li><li>UML的规范，每一个细节，含义也需要遵从规范的，箭头，实线虚线。</li><li>抽象(Abstraction)和分解(Decomposition &#x2F; Partitioning)是建模最为常用的两种手段</li></ol><h3 id="2-3-3-需求分析模型的特点及常见的需求分析模型"><a href="#2-3-3-需求分析模型的特点及常见的需求分析模型" class="headerlink" title="2.3.3. 需求分析模型的特点及常见的需求分析模型"></a>2.3.3. 需求分析模型的特点及常见的需求分析模型</h3><ul><li>需求分析模型是专门用来描述软件解决方案的模型技术。因为软件解决方案介于用户描述与软件内部构造之间，所以需求分析模型也是介于用户概念和软件内部实体之间的模型形式。</li></ul><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/3.png"></p><ul><li>常见的需求分析模型</li></ul><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/4.png"></p><h1 id="3-结构化分析"><a href="#3-结构化分析" class="headerlink" title="3. 结构化分析"></a>3. 结构化分析</h1><h2 id="3-1-结构化方法的历史"><a href="#3-1-结构化方法的历史" class="headerlink" title="3.1. 结构化方法的历史"></a>3.1. 结构化方法的历史</h2><ol><li>结构化⽅法是针对1960’s到1980’s软件开发界所⾯临的问题提出⼀系列分析、设计和编码的技术⽅法。那个时代：<ul><li>大多数商业编程都在Cobol和Fortran中完成，然后在C和BASIC中完成</li><li>关于”好的”设计和编程技术的指导很少</li><li>没有记录需求和设计的标准技术</li></ul></li><li>关键是软件的复杂度的急剧上升</li></ol><h2 id="3-2-Multiple-Structured-Methods-emerged-多种结构化分析方法的出现"><a href="#3-2-Multiple-Structured-Methods-emerged-多种结构化分析方法的出现" class="headerlink" title="3.2. Multiple Structured Methods emerged 多种结构化分析方法的出现"></a>3.2. Multiple Structured Methods emerged 多种结构化分析方法的出现</h2><ol><li>结构化编程：in circa 1967 with Edsger W.Dijkstra</li><li>结构化设计：around 1975 with Larry Constantine and Ed Yourdon</li><li>结构化分析：in circa 1978 with Tom DeMarco, Yourdon, Gane &amp; Sarson, McMenamin &amp; Palmer</li><li>信息专家：in circa 1990 with James Martin</li></ol><h2 id="3-3-结构化分析思想"><a href="#3-3-结构化分析思想" class="headerlink" title="3.3. 结构化分析思想"></a>3.3. 结构化分析思想</h2><ol><li>自顶向下分解</li><li>各种图<ul><li>数据流图</li><li>实体关系图</li><li>状态转移图</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/36.png"></p><h2 id="3-4-数据流图-Flow-Oriented-Model"><a href="#3-4-数据流图-Flow-Oriented-Model" class="headerlink" title="3.4. 数据流图 (Flow Oriented Model)"></a>3.4. 数据流图 (Flow Oriented Model)</h2><ol><li>数据流图将系统看做是过程的集合，其中一些由人来执行，另一些由软件系统来执行。</li><li>过程的执行就是对数据的处理：它接收输⼊，进⾏数据转换，输出结果。</li><li>数据流图主要是展示了数据在通过系统如何进行了变化。</li><li>可能需要和软件系统外的实体尤其是<strong>人</strong>进行交互</li><li>数据的变化包括：<ul><li>被转换、被存储、或者被分布</li></ul></li></ol><h3 id="3-4-1-Flow-Modeling-Notation-数据流图基本元素"><a href="#3-4-1-Flow-Modeling-Notation-数据流图基本元素" class="headerlink" title="3.4.1. Flow Modeling Notation(数据流图基本元素)"></a>3.4.1. Flow Modeling Notation(数据流图基本元素)</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/41.png"></p><h4 id="3-4-1-1-外部实体"><a href="#3-4-1-1-外部实体" class="headerlink" title="3.4.1.1. 外部实体"></a>3.4.1.1. 外部实体</h4><ol><li>数据的产生或者消耗者<ul><li>示例：一个人，一个设备，一个传感器</li><li>另一个例子：基于计算机的系统</li></ul></li><li>数据必须是从一个地方来到另一个地方去</li><li>外部实体是待构建软件系统之外的人、组织、设备或者其他软件系统，它们不受系统控制，开发者不能以任何方式操纵它们。</li></ol><h4 id="3-4-1-2-过程-Process"><a href="#3-4-1-2-过程-Process" class="headerlink" title="3.4.1.2. 过程 Process"></a>3.4.1.2. 过程 Process</h4><ol><li>将数据从输入转换到输出：示例：计算税金，确定面积，格式报告，显示图形必须始终以某种方式处理数据以实现系统功能</li><li>过程是指施加于数据的动作或者行为，它使得数据发生变化，包括被转换、被存储或者被分布。</li></ol><h4 id="3-4-1-3-数据流-Data-Flow"><a href="#3-4-1-3-数据流-Data-Flow" class="headerlink" title="3.4.1.3. 数据流 Data Flow"></a>3.4.1.3. 数据流 Data Flow</h4><ol><li>数据在整个系统流动，从输入流动到输出</li><li>数据流是数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/42.png"></p><h4 id="3-4-1-4-数据存储-Data-Stores"><a href="#3-4-1-4-数据存储-Data-Stores" class="headerlink" title="3.4.1.4. 数据存储 Data Stores"></a>3.4.1.4. 数据存储 Data Stores</h4><ol><li>数据经常被存储起来等之后使用</li><li>数据存储是软件系统需要在内部手机、保存，以供日后使用的数据集合。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/43.png"></p><h3 id="3-4-2-数据流图的语法规则"><a href="#3-4-2-数据流图的语法规则" class="headerlink" title="3.4.2. 数据流图的语法规则"></a>3.4.2. 数据流图的语法规则</h3><ol><li>过程是对数据的处理，必须有输⼊，也必须有输出，输⼊数据集应该和输出数据集存在差异</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/44.png"></p><ol start="2"><li>数据流是必须和过程产⽣关联的，它要么是过程的数据输⼊，要么是过程的数据输出</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/45.png"></p><ol start="3"><li>所有的对象都应该有⼀个可以唯⼀标识自己的名称。过程使用<strong>动词</strong>，外部实体、数据流、数据存储使用<strong>名词</strong></li></ol><h3 id="3-4-3-数据流图的分层结构"><a href="#3-4-3-数据流图的分层结构" class="headerlink" title="3.4.3. 数据流图的分层结构"></a>3.4.3. 数据流图的分层结构</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/55.png"></p><ol><li>数据流图分为如上三种图:上下文图、0层图和N层图</li></ol><h4 id="3-4-3-1-上下文图"><a href="#3-4-3-1-上下文图" class="headerlink" title="3.4.3.1. 上下文图"></a>3.4.3.1. 上下文图</h4><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/56.png"></p><ol><li>上下文图是DFD的最高层次的图，是系统功能的最高抽象。上下文将整个系统看做一个过程，这个过程实现系统的所有功能。</li><li>因此，上下文图往往也脱离DFD的层次结构单独使用，用来描述系统的上下文环境和定义系统边界。</li></ol><h4 id="3-4-3-2-0层图"><a href="#3-4-3-2-0层图" class="headerlink" title="3.4.3.2. 0层图"></a>3.4.3.2. 0层图</h4><ol><li>回顾描述并使用语法分析来确定”操作” </li><li>确定外部实体(数据的生产者和消费者)</li><li>0层图通常被用作整个系统的功能概图。<ol><li>为了概述整个系统的功能，建立0层图时需要分析需求获取的信息，归纳出系统的主要功能</li><li>将系统的主要功能描述为几个比较高层的抽象过程，并在0层图中加以标书</li><li>有部分重要的数据存储会在0层图中得到表述</li></ol></li><li>0层图示例</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/57.png"></p><h4 id="3-4-3-3-1层图"><a href="#3-4-3-3-1层图" class="headerlink" title="3.4.3.3. 1层图"></a>3.4.3.3. 1层图</h4><ol><li>写一篇叙述性文章来描述这个转变(数据的转变)</li><li>分析以确定下一级转换</li><li>“平衡”流量以保持数据流量的连续性</li><li>1层图实例</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/59.png"></p><h4 id="3-4-3-4-N层图"><a href="#3-4-3-4-N层图" class="headerlink" title="3.4.3.4. N层图"></a>3.4.3.4. N层图</h4><ol><li>父过程:被分解的过程</li><li>子图:分解后产生的揭示更多细节的图</li><li>原始DFD图:所有过程无法再次分解的图。</li><li>子图的接口流:父过程的输入输出，往往从空白的区域引出。</li><li>子图中过程的编号需要用父过程中的编号作为前缀。</li><li>注意:低于0层图的子图上通常不显示外部实体</li></ol><h3 id="3-4-4-数据流图的分层"><a href="#3-4-4-数据流图的分层" class="headerlink" title="3.4.4. 数据流图的分层"></a>3.4.4. 数据流图的分层</h3><ol><li>输⼊、处理、输出</li><li>分层将细节逐步细化</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/58.png"></p><h3 id="3-4-5-过程分解的平衡原则"><a href="#3-4-5-过程分解的平衡原则" class="headerlink" title="3.4.5. 过程分解的平衡原则"></a>3.4.5. 过程分解的平衡原则</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/60.png"></p><h2 id="3-5-实体关系图-ERD-数据的建模"><a href="#3-5-实体关系图-ERD-数据的建模" class="headerlink" title="3.5. 实体关系图(ERD) - 数据的建模"></a>3.5. 实体关系图(ERD) - 数据的建模</h2><ol><li>独立于处理检查数据对象</li><li>关注数据域(数据说明)</li><li>指示数据对象如何相互关联</li><li>能够弥补过程建模在数据说明方面的缺陷，是描述数据的定义、结构和关系等特性的技术。</li></ol><h3 id="3-5-1-实体关系图的组成元素"><a href="#3-5-1-实体关系图的组成元素" class="headerlink" title="3.5.1. 实体关系图的组成元素"></a>3.5.1. 实体关系图的组成元素</h3><h4 id="3-5-1-1-传统实体-Typical-Objects"><a href="#3-5-1-1-传统实体-Typical-Objects" class="headerlink" title="3.5.1.1. 传统实体(Typical Objects)"></a>3.5.1.1. 传统实体(Typical Objects)</h4><blockquote><p>实体是需要在系统中收集和存储的现实世界事物的类别描述。</p></blockquote><ol><li>实体并不是孤立存在的，相互交互相互影响</li><li>参与关系的每个实体都针对关系拥有最大基数和最小基数</li><li>最大基数:对关系中任意的其他实体实例，该实体可能参与关系的最大数量。最大基数为1，表示为One，否则为Many</li><li>最小基数:对关系中任意的其他实体实例，该实体可能参与关系的最小数量。实体在关系中的最小基数被标记为Optional,最小基数为1时，实体在关系中的最小基数被标记为mandatory</li><li>实体的例子<ol><li>external entities:printer, user, sensor</li><li>things:reports, displays, signals</li><li>occurrences or events:interrupt, alarm</li><li>roles:manager, engineer, salesperson</li><li>organizational units:devision, team</li><li>places:manufacturing ﬂoor</li><li>structures:employee record</li></ol></li></ol><h3 id="3-5-2-Data-Objects-and-Attributes-属性"><a href="#3-5-2-Data-Objects-and-Attributes-属性" class="headerlink" title="3.5.2. Data Objects and Attributes 属性"></a>3.5.2. Data Objects and Attributes 属性</h3><ol><li>数据对象包含一组作为对象的方面、质量、特征或描述符的属性</li><li>属性可以对尸体进行描述的特征。</li></ol><h3 id="3-5-3-Relationship-关系"><a href="#3-5-3-Relationship-关系" class="headerlink" title="3.5.3. Relationship 关系"></a>3.5.3. Relationship 关系</h3><ol><li>连通性<ul><li>系统必须记住的事实，不能或不能计算或推导出来</li><li>关系的几个实例可以存在</li><li>实体可以以多种方式关联</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/37.png"></p><h3 id="3-5-4-建立实体关系图的步骤"><a href="#3-5-4-建立实体关系图的步骤" class="headerlink" title="3.5.4. 建立实体关系图的步骤"></a>3.5.4. 建立实体关系图的步骤</h3><ol><li>第1级-对所有数据对象(实体)及其相互之间的”连接”建模</li><li>第2级-对所有实体和关系建模</li><li>第3级-对所有实体、关系和属性建模，以提供进一步的深度</li></ol><h4 id="3-5-4-1-ERD的图形表示"><a href="#3-5-4-1-ERD的图形表示" class="headerlink" title="3.5.4.1. ERD的图形表示"></a>3.5.4.1. ERD的图形表示</h4><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/38.png"></p><h4 id="3-5-4-2-键-Key"><a href="#3-5-4-2-键-Key" class="headerlink" title="3.5.4.2. 键(Key)"></a>3.5.4.2. 键(Key)</h4><ol><li>实体的⼀个或者多个属性能够唯⼀确定和标示每个实例，这些属性或者属性 组合就被称为实体的标示符，或者键(Key)</li></ol><h3 id="3-5-5-实体关系图实例"><a href="#3-5-5-实体关系图实例" class="headerlink" title="3.5.5. 实体关系图实例"></a>3.5.5. 实体关系图实例</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/39.png"></p><h1 id="4-面向对象分析"><a href="#4-面向对象分析" class="headerlink" title="4. 面向对象分析"></a>4. 面向对象分析</h1><h2 id="4-1-面向对象分析的简单过程"><a href="#4-1-面向对象分析的简单过程" class="headerlink" title="4.1. 面向对象分析的简单过程"></a>4.1. 面向对象分析的简单过程</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/5.png"></p><h2 id="4-2-需求与用例"><a href="#4-2-需求与用例" class="headerlink" title="4.2. 需求与用例"></a>4.2. 需求与用例</h2><ol><li>传统上，这些要求是在客户和开发人员之间的合同文件中规定的：很难满足所有的需求。</li><li>1992年，Jacobson提出了用例方法：它们来自于传统的开发方法，并适应OOAD。</li></ol><h2 id="4-3-用例-重要"><a href="#4-3-用例-重要" class="headerlink" title="4.3. 用例(重要)"></a>4.3. 用例(重要)</h2><ol><li>用例最初由[Jacobson1992] 在 Objectory 方法中提出的,它将⽤例定义为”在系统(或者子系统或者类)和外部对象的<strong>交互</strong>当中所执行的行为序列的描述,包括<strong>各种不同的序列和错误的序列</strong>,它们能够联合提供⼀种<strong>有价值的服务</strong>“[Rumbaugh2004]。</li><li>[Cockburn2001]认为用例描述了在不同条件下系统对某⼀⽤户的<strong>请求的响应</strong>。根据用户的请求和请求时的系统条件,系统将执⾏<strong>不同的行为序列</strong>, 每⼀个行为序列被称为⼀个<strong>场景</strong>。⼀个用例是多个场景的集合。</li></ol><h3 id="4-3-1-目标、交互与行为序列"><a href="#4-3-1-目标、交互与行为序列" class="headerlink" title="4.3.1. 目标、交互与行为序列"></a>4.3.1. 目标、交互与行为序列</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/6.png"></p><h3 id="4-3-2-案例"><a href="#4-3-2-案例" class="headerlink" title="4.3.2. 案例"></a>4.3.2. 案例</h3><ol><li>连锁超市管理系统的收银员为了完成⼀次销售任务,会使⽤软件系统处理销售过程,那么就可以建立⼀个⽤例”销售处理”。考虑实际销售时的不同条件,会发⽣不同的⾏为:<ul><li>在⼀切顺利时是⼀种正常⾏为流程;</li><li>购买多个同样商品时可以逐⼀输⼊每个商品,也可以分别输⼊商品号与数量;</li><li>销售过程中可能会发现某个商品无法识别;</li><li>有可能⼀个商品被纳⼊销售清单后用户⼜提出退回……</li></ul></li><li>上述的每⼀个⾏为都是⼀个场景。所有的行为联合起来就构成了场景的集合——⽤例,它的目标与价值是完成销售任务。</li><li>除了上述基本操作以外，还应该考虑用户大量的操作。</li><li>用例是需求的一种组织，一种表达。</li></ol><h2 id="4-4-用例图"><a href="#4-4-用例图" class="headerlink" title="4.4. 用例图"></a>4.4. 用例图</h2><ol><li>⽤例:椭圆</li><li>参与者:小人</li><li>关系:简单的就是一条直线</li><li>系统边界:是一个框</li></ol><h3 id="4-4-1-用例图组成成分"><a href="#4-4-1-用例图组成成分" class="headerlink" title="4.4.1. 用例图组成成分"></a>4.4.1. 用例图组成成分</h3><h4 id="4-4-1-1-参与者"><a href="#4-4-1-1-参与者" class="headerlink" title="4.4.1.1. 参与者"></a>4.4.1.1. 参与者</h4><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/7.png"></p><ol><li>参与者是用户或其他系统对要开发的系统所扮演的角色。</li><li>用例图中的单个参与者可以表示多个用户(或系统)。</li><li>单个用户(或系统)也可以扮演多个角色。</li><li>参与者不需要是人，例如，需要来自当前系统的某些信息的外部系统也是参与者。</li></ol><h4 id="4-4-1-2-用例-需要语境"><a href="#4-4-1-2-用例-需要语境" class="headerlink" title="4.4.1.2. 用例(需要语境)"></a>4.4.1.2. 用例(需要语境)</h4><ol><li>以用例的形式表达需求。</li><li>用例表示有助于构建、关联和理解基本需求的典型场景集。</li><li>场景是对系统在实践中如何使用的描述：用户与计算机系统之间的典型交互</li><li>一般会用动宾短语，加上actor作为主语就是句子了。</li></ol><h4 id="4-4-1-3-系统边界"><a href="#4-4-1-3-系统边界" class="headerlink" title="4.4.1.3. 系统边界"></a>4.4.1.3. 系统边界</h4><ol><li>强调重点是什么是要详细的，什么不是。</li><li>系统边界隐式存在于没有显式表示的系统边界的图中</li><li>参与者总是在边界之外，用例总是在边界之内。</li><li>系统边界是指一个系统所包含的系统成分与系统外事务的分界线。</li></ol><h4 id="4-4-1-4-关系"><a href="#4-4-1-4-关系" class="headerlink" title="4.4.1.4. 关系"></a>4.4.1.4. 关系</h4><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/8.png"></p><ol><li>有关</li><li>泛化关系，指向的是被泛化的。</li><li>包含关系</li><li>继承关系</li><li>如果能清晰include和extends可以画，不明白可以直接连线和不画。</li><li>multiplicity:多样性。</li></ol><h3 id="4-4-2-用例图的建立的步骤"><a href="#4-4-2-用例图的建立的步骤" class="headerlink" title="4.4.2. 用例图的建立的步骤"></a>4.4.2. 用例图的建立的步骤</h3><ol><li>目标分析与解决方向的确定</li><li>寻找参与者</li><li>寻找用例</li><li>细化用例</li></ol><h4 id="4-4-2-1-目标分析"><a href="#4-4-2-1-目标分析" class="headerlink" title="4.4.2.1. 目标分析"></a>4.4.2.1. 目标分析</h4><ol><li>问题目标的解决方案</li><li>×××连锁商店是一家刚刚发展起来的⼩型连锁商店，其前身是⼀家独立的小百货门面店。<ul><li>⾸先是随着商店规模的扩⼤，顾客量大幅增长，手工作业销售迟缓，顾客购物排队现象严重，导致流失客源。</li><li>其次是商店的商品品种增多，⽆法准确掌握库存，商品积压、缺货和报废的现象上升 明显。</li><li>再次是商店⾯临的竞争⽐以前更⼤，希望在降低成本，吸引顾客，增强竞争⼒的同时，保持盈利⽔平。</li></ul></li><li>业务需求<ol><li>BR1：在系统使⽤6个⽉后，商品积压、缺货和报废的现象要减少50%</li><li>BR2：在系统使⽤3个⽉后，销售⼈员⼯作效率提⾼50%</li><li>BR3：在系统使⽤6个⽉后，运营成本要降低15%<ul><li>范围：⼈⼒成本和库存成本</li><li>度量：检查平均员工数量和平均每10,000元销售额的库存成本</li></ul></li><li>BR4：在系统使⽤6个⽉后，销售额度要提⾼20%<ul><li>最好情况：40%</li><li>最可能情况：20%</li><li>最坏情况：10%</li></ul></li></ol></li><li>系统功能<ol><li>SF1：分析商品库存，发现可能的商品积压、缺货和报废现象</li><li>SF2：根据市场变化调整销售的商品</li><li>SF3：制定促销⼿段，处理积压商品</li><li>SF4：与生产厂家联合进⾏商品促销</li><li>SF5：制定促销手段进行销售竞争</li><li>SF6：掌握员工变动和授权情况</li><li>SF7：处理商品⼊库与出库</li><li>SF8：发展会员，提高顾客回头率</li><li>SF9：允许积分兑换商品和赠送吸引会员的礼品，提⾼会员满意度</li><li>SF10：帮助收银员处理销售与退货任务</li></ol></li></ol><h4 id="4-4-2-2-寻找参与者与用例"><a href="#4-4-2-2-寻找参与者与用例" class="headerlink" title="4.4.2.2. 寻找参与者与用例"></a>4.4.2.2. 寻找参与者与用例</h4><ol><li>每个用户的任务(⽬标)都是⼀个独⽴用例</li><li>案例中的参与者的目标<ol><li>总经理的目标有：<ul><li>产品调整(增删改产品信息)</li><li>特价策略制定(增删改特价策略)</li><li>赠送策略制定(增删改赠送策略)</li><li>库存分析；(分析可能的商品积压)</li></ul></li><li>客户经理的目标有：<ul><li>会员管理；(会员发展、礼品赠送)</li><li>库存管理；(商品入库、出库和库存分析)</li></ul></li><li>收银员的目标有：<ul><li>销售处理(销售)</li><li>退货；(退货)</li></ul></li><li>管理员的目标有：<ul><li>⽤户管理(增删改⽤户信息)</li></ul></li></ol></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/9.png"></p><h4 id="4-4-2-3-细化用例"><a href="#4-4-2-3-细化用例" class="headerlink" title="4.4.2.3. 细化用例"></a>4.4.2.3. 细化用例</h4><ol><li>如果用例的粒度不合适就需要进⾏细化和调整。<ul><li>判断标准是：⽤例描述了为应对<strong>一个业务事件</strong>，由<strong>一个用户</strong>发起，并在<strong>一个连续时间段</strong>内完成，可以<strong>增加业务价值</strong>的任务。</li><li>eg.查询车票和买车票是两个用例</li></ul></li><li>产品具体的细化<ol><li>特价策略制定、赠送策略制定两个用例的业务目的、发起源和过程基本相同，仅仅是业务数据不同，所以可以合并为⼀个⽤例销售策略制定。</li><li>会员管理用例有两个明显不同的业务事件，可以被细化为发展会员和礼品赠送2个更细粒度的用例。</li><li>客户经理的库存管理用例也有三个不同的业务⽬标：出库、⼊库和库存分析，所以也应该细化为三个用例商品出库、商品⼊库和库存分析，其中库存分析⽤例与总经理的库存分析⽤例相同。</li></ol></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/10.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/12.png"></p><h4 id="4-4-2-4-常见错误"><a href="#4-4-2-4-常见错误" class="headerlink" title="4.4.2.4. 常见错误"></a>4.4.2.4. 常见错误</h4><ol><li>不要将用例细化为没有独立业务价值的单个操作<ul><li>例如,不要将用户管理细化为增加、修改和删除三个更⼩的用例,因为它们要联合起来才能体现出业务价值。</li></ul></li><li>不要将同⼀个业务目标细化为不同用例<ul><li>例如<strong>特价策略制定和赠送策略制定</strong>。</li></ul></li><li>不要将没有业务价值(而是技术实现需要)的内容作为用例<ul><li>常见的错误有<strong>登录</strong>(应该描述为安全性质量需求)、”数据验证&#x2F;输入&#x2F;输出数据检查”(应该描述为数据需求或者业务规则)、”连接数据库”(属性软件内部实现⽽不是需求)、网络传输等。</li></ul></li><li>不要将单个步骤细化为用例</li><li>不要将片面的一个方面细化为用例</li></ol><h4 id="4-4-2-5-完整实例"><a href="#4-4-2-5-完整实例" class="headerlink" title="4.4.2.5. 完整实例"></a>4.4.2.5. 完整实例</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[实例一]<br>×××连锁商店是一家刚刚发展起来的小型连锁商店，其前身是一家独立的小百货门面店。<br>首先是随着商店规模的扩大，顾客量大幅增长，手工作业销售迟缓，顾客购物排队现象严重，导致流失客源。其次是商店的商品品种增多，无法准确掌握库存，商品积压、缺货和报废的现象上升明显。再次是商店面临的竞争比以前更大，希望在降低成本，吸引顾客，增强竞争力的同时，保持盈利水平。<br><br>BR<span class="hljs-number">1</span>：在系统使用<span class="hljs-number">6</span>个月后，商品积压、缺货和报废的现象要减少<span class="hljs-number">50</span><span class="hljs-meta">%</span><br>BR<span class="hljs-number">2</span>：在系统使用<span class="hljs-number">3</span>个月后，销售人员工作效率提高<span class="hljs-number">50</span><span class="hljs-meta">%</span><br>BR<span class="hljs-number">3</span>：在系统使用<span class="hljs-number">6</span>个月后，运营成本要降低<span class="hljs-number">15</span><span class="hljs-meta">%</span><br>范围：人力成本和库存成本，度量：检查平均员工数量和平均每<span class="hljs-number">10</span>,<span class="hljs-number">000</span>元销售额的库存成本<br>BR<span class="hljs-number">4</span>：在系统使用<span class="hljs-number">6</span>个月后，销售额度要提高<span class="hljs-number">20</span><span class="hljs-meta">%</span>，最好情况：<span class="hljs-number">40</span><span class="hljs-meta">%</span>，最可能情况：<span class="hljs-number">20</span><span class="hljs-meta">%</span>，最坏情况：<span class="hljs-number">10</span><span class="hljs-meta">%</span><br><br>SF<span class="hljs-number">1</span>：分析商品库存，发现可能的商品积压、缺货和报废现象<br>SF<span class="hljs-number">2</span>：根据市场变化调整销售的商品<br>SF<span class="hljs-number">3</span>：制定促销手段，处理积压商品<br>SF<span class="hljs-number">4</span>：与生产厂家联合进行商品促销<br>SF<span class="hljs-number">5</span>：制定促销手段进行销售竞争<br>SF<span class="hljs-number">6</span>：掌握员工变动和授权情况<br>SF<span class="hljs-number">7</span>：处理商品入库与出库<br>SF<span class="hljs-number">8</span>：发展会员，提高顾客回头率<br>SF<span class="hljs-number">9</span>：允许积分兑换商品和赠送吸引会员的礼品，提高会员满意度<br>SF<span class="hljs-number">10</span>：帮助收银员处理销售与退货任务<br><br>从上述特性可以发现涉及的用户类别：总经理，客户经理，收银员，管理员<br>总经理的目标有：<br>    <span class="hljs-number">1.</span> 产品调整<span class="hljs-comment">(增删改产品信息)</span><br>    <span class="hljs-number">2.</span> 特价策略制定<span class="hljs-comment">(增删改特价策略)</span><br>    <span class="hljs-number">3.</span> 赠送策略制定<span class="hljs-comment">(增删改赠送策略)</span><br>    <span class="hljs-number">4.</span> 库存分析；<span class="hljs-comment">(分析可能的商品积压)</span><br>客户经理的目标有：<br>    <span class="hljs-number">1.</span> 会员管理；<span class="hljs-comment">(会员发展、礼品赠送)</span><br>    <span class="hljs-number">2.</span> 库存管理；<span class="hljs-comment">(商品入库、出库和库存分析)</span><br>收银员的目标有：销售处理<span class="hljs-comment">(销售)</span>，退货；<span class="hljs-comment">(退货)</span><br>管理员的目标有：用户管理<span class="hljs-comment">(增删改用户信息)</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">【示例<span class="hljs-number">2</span>】<br>网上书店系统(OBS)是一个基于web的应用程序，允许用户浏览和购买网上产品。该应用程序支持网上购物车的概念，类似于其他网上零售商，如<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Amazon</span>.</span></span>com,。该系统的结账功能将集成信用卡交易处理以及内部计费系统。该系统还提供管理员视图，允许授权的员工查看和管理产品、用户和订单。<br>用户：购买、浏览<br>员工：查看用户、订单、产品管理<br>管理员：授权<br>信用卡：结账<br>内部计费：结账<br>注意：内部计费指的是单位内部，而不是系统内部<br></code></pre></td></tr></table></figure><h3 id="4-4-3-用例文档模板"><a href="#4-4-3-用例文档模板" class="headerlink" title="4.4.3. 用例文档模板"></a>4.4.3. 用例文档模板</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/13.png"></p><ol><li>用例标识:至少在本文档中标识应当是唯一，最好是在整个项目中的文档标识是唯一的</li><li>触发事件:</li><li>前置条件:系统应该满足的条件，但是不是达到这个条件就除法</li><li>后置条件:用例处理完的状态</li><li>扩展流程:不按照我们预估的顺序走，不是错误的。<ul><li>也包含一些异常说明</li></ul></li></ol><h3 id="4-4-4-用例模板实例"><a href="#4-4-4-用例模板实例" class="headerlink" title="4.4.4. 用例模板实例"></a>4.4.4. 用例模板实例</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/11.png"></p><ol><li>UC1是ID，前置条件是应该被完成的</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/14.png"></p><ol start="2"><li><p>流程是被标识数字，并且数字应该是唯一的。</p></li><li><p>上面的8和9合并(无和系统的交互)<br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/15.png"></p></li><li><p>2a:非法输入一定要明确的提示(a标识扩展，然后之后写出扩展流程的具体流程)</p></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/16.png"></p><ol><li>特殊需求应当保证确定有需求才写，符合规格要求</li></ol><h3 id="4-4-5-用例文档的部分问题"><a href="#4-4-5-用例文档的部分问题" class="headerlink" title="4.4.5. 用例文档的部分问题"></a>4.4.5. 用例文档的部分问题</h3><ol><li>顾客为什么不是参与者:顾客没有直接和我们交互，因为是通过收银员进行交互</li><li>上传下载为什么不是⽤例:是系统之间的交互，并不是<strong>系统和系统外的交互</strong></li><li>系统可不可以分为服务器和客户端两个系统:<ol><li>表达用例的时候还是在表达需求，这时是没有服务器端和客户端的概念的，这时我们的实现细节</li></ol></li></ol><h3 id="4-4-6-UML中用例图的作用"><a href="#4-4-6-UML中用例图的作用" class="headerlink" title="4.4.6. UML中用例图的作用"></a>4.4.6. UML中用例图的作用</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/17.png"></p><ol><li>用例图在整个UML中是有很重要的作用，是其他用例的基础</li></ol><h2 id="4-5-概念类图-Conceptual-Class-Diagram"><a href="#4-5-概念类图-Conceptual-Class-Diagram" class="headerlink" title="4.5. 概念类图(Conceptual Class Diagram)"></a>4.5. 概念类图(Conceptual Class Diagram)</h2><ol><li>概念类图又被称为”领域模型”(Domain Model)</li><li>类图是面向对象分析方法的核心:类图描述类(对象)和这些类(对象)之间的关系</li><li>概念类图和<strong>设计类图</strong>的不同点:关注系统与外界的交互，⽽不是软件系统的内部构造机制</li><li><strong>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</strong></li><li>类图只有类和类名，没有包含方法。</li><li>用例不是概念类，同一个用例可能产生多个概念类</li></ol><h3 id="4-5-1-概念类图的注意事项"><a href="#4-5-1-概念类图的注意事项" class="headerlink" title="4.5.1. 概念类图的注意事项"></a>4.5.1. 概念类图的注意事项</h3><ol><li>注意：与设计类图有所不同，分析类图关注现实世界问题域，而不是软件系统的内部构造机制；</li><li>类型、方法、可见性等复杂的软件构造细节不会在概念类图中，不允许出现与现实无关的内容</li></ol><h3 id="4-5-2-概念类图基本元素"><a href="#4-5-2-概念类图基本元素" class="headerlink" title="4.5.2. 概念类图基本元素"></a>4.5.2. 概念类图基本元素</h3><ol><li>对象<ul><li>标识符:对象自治、对象请求写作</li><li>状态:存储数据，如密码、名称</li><li>行为:利用数据做什么</li></ul></li><li>类:对象集合的抽象</li><li>链接(link)(dependency)<ul><li>对象之间的互相协作的关系</li><li>描述了对象之间的物理或业务联系</li></ul></li><li>关联<ul><li>对象之间链接的抽象</li><li>聚合与组合</li></ul></li><li>继承:泛化关系</li></ol><h3 id="4-5-3-关联与依赖"><a href="#4-5-3-关联与依赖" class="headerlink" title="4.5.3. 关联与依赖"></a>4.5.3. 关联与依赖</h3><ol><li>两个分析类通常以某种方式相互关联<ul><li>在UML中，这些关系称为<strong>关联</strong></li><li>关联可以通过指示多样性来重新定义(数据建模中使用术语基数)</li></ul></li><li>如果类之间存在关联，则类的实例之间存在链接(依赖项)</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/18.png"></p><ol start="3"><li>上图中注意基数和箭头的形状</li><li>会使用到的四种关系线:<ol><li>聚合关系不必可以使用，但是组合关系要适当的使用</li><li>继承关系、组合关系、聚合关系、普通关联</li></ol></li></ol><h3 id="4-5-4-继承"><a href="#4-5-4-继承" class="headerlink" title="4.5.4. 继承"></a>4.5.4. 继承</h3><ol><li>将域对象类组织到层次结构中</li><li>层次结构顶部的类反映了所有类的公共特性</li><li>对象类从一个或多个超级类继承其属性和服务。必要时可将其专门化</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/19.png"></p><ol start="4"><li>使用空心箭头</li></ol><h3 id="4-5-5-建立概念类图的步骤-重要"><a href="#4-5-5-建立概念类图的步骤-重要" class="headerlink" title="4.5.5. 建立概念类图的步骤(重要)"></a>4.5.5. 建立概念类图的步骤(重要)</h3><ol><li>对每个用例文本描述，尤其是场景描述，建⽴<strong>局部</strong>的概念类图<ul><li>根据用例的⽂本描述，<strong>识别候选类</strong></li><li><strong>筛选候选类</strong>，确定概念类</li><li><strong>识别关联</strong></li><li><strong>识别重要属性</strong></li></ul></li><li>将所有用例产⽣的局部概念类图进⾏合并，建⽴软件系统的整体概念类图</li><li>自己注:先画关联关系，再添加类的属性</li></ol><h3 id="4-5-6-候选类识别"><a href="#4-5-6-候选类识别" class="headerlink" title="4.5.6. 候选类识别"></a>4.5.6. 候选类识别</h3><ol><li>发现软件系统与外界交互时可能涉及的对象与类，它们就是候选类。</li><li>行为分析、名词分析、CRC等很多种⽅法都可以⽤来分析⽤例⽂本描述 </li><li>名词分析:提取出用例描述中的名词作为候选类</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/20.png"></p><h3 id="4-5-7-筛选候选类，确定概念类"><a href="#4-5-7-筛选候选类，确定概念类" class="headerlink" title="4.5.7. 筛选候选类，确定概念类"></a>4.5.7. 筛选候选类，确定概念类</h3><ol><li>确定概念类的准则：该对象的状态与行为是否全部必要<ol><li>依据系统的需求</li><li>该类的对象实例的状态与⾏为是否完全必要</li><li>如果是只允许打印两次，则要为何打印的状态。</li></ol></li><li>候选类向概念类的转换：如果候选类的对象实例<ol><li>(状态+行为)既需要维持⼀定的状态，⼜需要依据状态表现⼀定的行为<ul><li>确定为⼀个概念类</li></ul></li><li>(仅状态)如只需要维护状态，不需要表现行为<ul><li>确定是不是其他概念类的属性</li></ul></li><li>(仅行为)不需要维护状态，却需要表现⾏为<ul><li>⾸先要重新审视需求是否有遗漏，因为没有状态⽀持的对象无法表现⾏为</li><li>如果确定没有需求的遗漏，就需要剔除该候选类，并将⾏为转交给具备状态⽀持能⼒的其他概念类</li></ul></li><li>(无状态行为)既不需要维护状态，⼜不需要表现行为:废弃</li></ol></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/21.png"></p><h3 id="4-5-8-识别关联"><a href="#4-5-8-识别关联" class="headerlink" title="4.5.8. 识别关联"></a>4.5.8. 识别关联</h3><ol><li>分析用例文本描述，发现概念类之间的<strong>协作</strong>，需要协作的类之间需要建立关联。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/22.png"></p><ol start="2"><li>分析和补充<strong>问题域</strong>内的关系，例如概念类之间的整体部分关系和明显的语义联系：对问题域关系的补充要适可⽽⽌，不要把关系搞得过度复杂化。</li><li><strong>去除冗余关联和导出关联</strong>。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/23.png"></p><h3 id="4-5-9-识别重要属性"><a href="#4-5-9-识别重要属性" class="headerlink" title="4.5.9. 识别重要属性"></a>4.5.9. 识别重要属性</h3><ol><li>这些属性往往是实现类协作时<strong>必要的信息</strong>，是协作的条件、输⼊、结果或者过程记录。</li><li>通过分析用例的描述，并与用户交流，补充问题域信息，可以发现重要的属性信息。</li><li>在分析每个单独的用例(场景)描述时，为各个概念类发现的重要属性可能不多，甚⾄有些概念类没有任何重要属性。但是，系统通常有多个⽤例和很多场景，会建立多个<strong>局部</strong>的概念类图，只有在合并所有局部概念类图之后， 各个概念类的重要属性才能得到全⾯的体现。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/24.png"></p><h3 id="4-5-10-概念类图生成的步骤-总结"><a href="#4-5-10-概念类图生成的步骤-总结" class="headerlink" title="4.5.10. 概念类图生成的步骤(总结)"></a>4.5.10. 概念类图生成的步骤(总结)</h3><ol><li>识别候选类(名词分析法)</li><li><strong>确定概念类</strong> (看是否满足既有状态又有行为)<ol><li>既需要维持一定的状态，又需要依据状态表现一定的行为：确定为一个概念类</li><li>如只需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，却需要表现行为：首先重新审视需求是否有遗漏，因为没有状态支持的对象无法表现行为；如果确定没有需求的遗漏，就需要剔除该候选类，并将行为转交给具备状态支持能力的其他概念类</li><li>既不需要维护状态，又不需要表现行为：应该被完全剔除</li></ol></li><li>识别关联(文本中提取出”名词＋动词＋名词”的结构)：第一标准是满足需求的要求，第二标准是现实状况</li><li>识别重要属性：协作的必要信息，通过分析用例的描述，补充问题域信息发现。</li></ol><h3 id="4-5-11-实例"><a href="#4-5-11-实例" class="headerlink" title="4.5.11. 实例"></a>4.5.11. 实例</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs scss">【示例<span class="hljs-number">1</span>】<br><span class="hljs-number">1</span>、如果是会员，收银员输入客户编号(属性、无行为)<br><span class="hljs-number">2</span>、系统显示会员信息(就是会员)，包括姓名(属性、无行为)与积分(属性、无行为)<br><span class="hljs-number">3</span>、收银员输入商品标识(商品属性、无行为)<br><span class="hljs-number">4</span>、系统记录并显示商品信息(有状态、有行为)，商品信息包括商品标识、描述、数量、价格、特价(如果有商品特价策略的话)和本项商品总价(商品属性)<br><span class="hljs-number">5</span>、系统显示已购入的商品清单(有状态、有行为)，商品清单包括商品标识、描述、数量、价格、特价、各项商品总价和所有品总价(商品属性)<br>收银员重复<span class="hljs-number">3</span>-<span class="hljs-number">5</span>步，直到完成所有商品的输入<br><span class="hljs-number">6</span>、收银员结束输入，系统计算并显示总价(存储在账单中，有行为)，计算根据总额特价策略(有状态、有行为)进行<br><span class="hljs-number">7</span>、系统根据商品赠送策略和总额赠送策略计算并显示赠品清单(要)，赠品清单包括各项赠品的标识、描述与数量(不要)<br><span class="hljs-number">8</span>、收银员请顾客(就是会员)支付账单(有状态、有行为)<br><span class="hljs-number">9</span>、顾客支付，收银员输入收取的现金数额(有属性、无行为、不要)<br><span class="hljs-number">10</span>、系统给出应找的余额(有属性、无行为、不要)，收银员找零<br><span class="hljs-number">11</span>、收银员结束销售，系统记录销售信息(有状态、有行为)、商品清单、赠品清单和账单信息，并更新库存(有状态、有行为)<br><span class="hljs-number">12</span>、系统打印收据(根据需求，如果是一次性就无状态无行为，如果是丢了还可以打印就有状态有行为)<br>注意：一切看需求。<br><br>(<span class="hljs-number">1</span>)若商品ID必须符合标准，则ID有状态、有行为<br>(<span class="hljs-number">2</span>)若商品数量单位不同，则单位换算的职责交给数量，有状态、有行为<br>(<span class="hljs-number">3</span>)若商品价格按照国际汇率有不同定位，则价格有状态、有行为<br><br>【示例<span class="hljs-number">2</span>】<br>ATM系统通过显示屏，输入键盘(有数字和特殊输入按键)，银行卡读卡器，存款插槽，收据打印机等与用户交互。客户使用ATM机存款，取款，余额查询，对账户的更新交由账户系统的一个接口来处理。安全系统将为每个客户分配一个PIN码和安全级别。每次事物执行之前都需要验证PIN码。将来，银行计划使用ATM机支持一些常规操作，例如使用地址和电话号码修改。<br><br>分析：显示器、按键、读卡器、存款插槽、收据打印机 不属于现实世界<br>客户：属性：PIN、地址、电话号码、安全级别<br>账户：余额<br>交易<br><br>【示例<span class="hljs-number">3</span>】<br><span class="hljs-number">1</span>. 顾客向系统提起查询请求<br><span class="hljs-number">2</span>. 系统根据请求为顾客提供一个CD的推荐列表<br><span class="hljs-number">3</span>.顾客在推荐列表中选定一个CD，然后要求查看更详细的信息<br><span class="hljs-number">4</span>. 系统为顾客提供选定CD的详细信息<br><span class="hljs-number">5</span>. 顾客购买选定CD.<br><span class="hljs-number">6</span>. 顾客离开<br><br>分析：<br>查询请求：有状态、有行为<br>顾客和CD：看戏球，不确定是否存储详细信息<br>推荐列表：有状态、有行为(增删改)<br></code></pre></td></tr></table></figure><h2 id="4-6-用例模型和对象模型之间的鸿沟"><a href="#4-6-用例模型和对象模型之间的鸿沟" class="headerlink" title="4.6. 用例模型和对象模型之间的鸿沟"></a>4.6. 用例模型和对象模型之间的鸿沟</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/25.png"></p><ol><li>用例模型和对象模型之间是存在比较大的差距的。</li></ol><h2 id="4-7-顺序图-交互图"><a href="#4-7-顺序图-交互图" class="headerlink" title="4.7. 顺序图(交互图)"></a>4.7. 顺序图(交互图)</h2><ol><li>行为模型显示了对象之间的交互，以产生一些特定的系统行为，这些行为被指定为一个用例</li><li>UML中的序列图(或协作图)用于建模对象之间的交互</li><li>分析阶段，主要是利⽤<strong>系统顺序图</strong>，表达系统和外部参与者之间的交互⾏为：务必要严格谨慎的界定系统</li></ol><h3 id="4-7-1-顺序图的图例"><a href="#4-7-1-顺序图的图例" class="headerlink" title="4.7.1. 顺序图的图例"></a>4.7.1. 顺序图的图例</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/26.png"></p><ol><li>下划线表示对象，没有下划线表示类(上图中的名字)</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/27.png"></p><ol start="2"><li>区分不同的箭头： 箭头们无论是从系统到外部还是从外部到系统都是一样的</li></ol><h3 id="4-7-2-系统顺序图"><a href="#4-7-2-系统顺序图" class="headerlink" title="4.7.2. 系统顺序图"></a>4.7.2. 系统顺序图</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/28.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/29.png"></p><ol><li>画外部和内部之间的交互应当仔细辨别系统和系统(也就是系统边界)</li><li>不同框的含义:<ol><li>alt一定要选(多选一):<strong>注意，每一种可选分支之间要用虚线分割，而且在表示执行态的圆柱上面要写监护条件，放在[]里面。</strong></li><li>opt一定要选(选择0或者1)</li><li>loop:表示循环，在旁边使用[]书写循环条件</li></ol></li><li>步骤:<ol><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加消息</li></ol></li></ol><h2 id="4-8-状态图"><a href="#4-8-状态图" class="headerlink" title="4.8. 状态图"></a>4.8. 状态图</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/30.png"></p><h3 id="4-8-1-状态图的基本概念"><a href="#4-8-1-状态图的基本概念" class="headerlink" title="4.8.1. 状态图的基本概念"></a>4.8.1. 状态图的基本概念</h3><ol><li>状态：一组可观察的情况，描述了一个系统在给定时间的行为</li><li>状态转换：从一个状态到另一个状态的转换</li><li>事件：使系统表现出某种可预测的行为形式的事件</li><li>行为：由于过渡而发生的过程</li></ol><h3 id="4-8-2-状态图的示例"><a href="#4-8-2-状态图的示例" class="headerlink" title="4.8.2. 状态图的示例"></a>4.8.2. 状态图的示例</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/31.png"></p><ul><li>上图非常重要，请务必认真确定</li></ul><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/32.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/34.png"></p><h3 id="4-8-3-创建状态图的步骤"><a href="#4-8-3-创建状态图的步骤" class="headerlink" title="4.8.3. 创建状态图的步骤"></a>4.8.3. 创建状态图的步骤</h3><ol><li>确定上下文环境<ul><li>状态图是立足于状态快照进⾏⾏为描述的，因此建⽴状态图时首先要搞清楚<strong>状态的主体</strong>，确定状态的上下⽂环境。常⻅的状态主体有：类、用例、多个⽤例和整个系统。</li><li>状态应该是相对较多，比较复杂的。</li></ul></li><li>识别<strong>状态</strong><ul><li>状态主体会表现出⼀些稳定的状态，它们需要被识别出来，并且标记出其中的初始状态和结束状态集。在有些情况下，可能会不存在确定的初始状态和结束状态。</li></ul></li><li>建⽴<strong>状态转换</strong><ul><li>根据需求所描述的系统⾏为，建⽴各个稳定状态之间可能存在的转换。</li></ul></li><li>补充<strong>详细信息</strong>，完善状态图<ul><li>添加转换的触发事件、转换⾏为和监护条件等详细信息。</li></ul></li></ol><h3 id="4-8-4-示例-销售处理用例状态图"><a href="#4-8-4-示例-销售处理用例状态图" class="headerlink" title="4.8.4. 示例:销售处理用例状态图"></a>4.8.4. 示例:销售处理用例状态图</h3><ol><li>明确状态图的主体：⽤例UC1销售处理。</li><li>识别⽤例UC1销售处理可能存在的稳定状态：<ul><li>空闲状态(开始状态)：收银员已经登录和获得授权，但并没有请求开始销售⼯作的状态；</li><li>销售开始状态：开始⼀个新销售事务，系统开始执⾏⼀个销售任务的状态；</li><li>VIP顾客信息显示状态：输⼊了客户编号，系统显示该VIP顾客信息的状态；</li><li>商品信息显示状态：刚刚输⼊了⼀个物品项，显示该物品(和赠品)描述信息的状态；</li><li>列表显示状态：以列表⽅式显示所有已输⼊物品项(和赠品)信息的状态；</li><li>错误提示状态：输⼊信息错误的状态；</li><li>账单处理状态：输⼊结束，系统显示账单信息，收银员进⾏结帐处理的状态。</li><li>销售结束状态：更新信息，打印收据的状态。</li></ul></li></ol><h3 id="4-8-5-状态转换表-辅助完成状态图绘制"><a href="#4-8-5-状态转换表-辅助完成状态图绘制" class="headerlink" title="4.8.5. 状态转换表(辅助完成状态图绘制)"></a>4.8.5. 状态转换表(辅助完成状态图绘制)</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/33.png"></p><ol><li>用来分析状态之间的关系</li></ol><h2 id="4-9-例题"><a href="#4-9-例题" class="headerlink" title="4.9. 例题"></a>4.9. 例题</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec6/01.png"></p><h1 id="5-使用需求方法细化和明确需求"><a href="#5-使用需求方法细化和明确需求" class="headerlink" title="5. 使用需求方法细化和明确需求"></a>5. 使用需求方法细化和明确需求</h1><ol><li>为什么要细化<ul><li>⽤户需求的描述的模糊性和系统设计所需要的严谨性之间的⽭盾</li></ul></li><li>如何细化<ul><li>需求分析建模</li><li>发现其中的遗漏、冲突、冗余和错误</li><li>迭代(获取、分析、获取、分析。。。)</li></ul></li></ol><h2 id="5-1-系统顺序图有助于发现交互性的缺失"><a href="#5-1-系统顺序图有助于发现交互性的缺失" class="headerlink" title="5.1. 系统顺序图有助于发现交互性的缺失"></a>5.1. 系统顺序图有助于发现交互性的缺失</h2><h2 id="5-2-概念类图有助于发现"><a href="#5-2-概念类图有助于发现" class="headerlink" title="5.2. 概念类图有助于发现"></a>5.2. 概念类图有助于发现</h2><ol><li>部分信息的使用不准确<ul><li>例如步骤 2 中输⼊的是商品标识,⽽不是商品,第 5 步显示的已输⼊商品列表信息和总价。</li></ul></li><li>部分信息不明确<ul><li>例如会员信息、商品信息、商品列表信息、赠品 信息、更新的数据、收据等等各⾃的详细内容并没有描述。</li></ul></li><li>遗漏了重要内容<ul><li>例如总价的计算需要使⽤商品特价策略和总额特 价策略,赠品的计算需要使⽤商品赠送策略和总额赠送策略。</li></ul></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/40.png"></p><h2 id="5-3-状态图有助于发现页面的跳转"><a href="#5-3-状态图有助于发现页面的跳转" class="headerlink" title="5.3. 状态图有助于发现页面的跳转"></a>5.3. 状态图有助于发现页面的跳转</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/46.png"></p><h2 id="5-4-建⽴系统需求"><a href="#5-4-建⽴系统需求" class="headerlink" title="5.4. 建⽴系统需求"></a>5.4. 建⽴系统需求</h2><ol><li>8种规格说明</li><li>不同的分析⽅法适合不同的规格说明</li></ol><h3 id="5-4-1-by-mode-功能需求分类"><a href="#5-4-1-by-mode-功能需求分类" class="headerlink" title="5.4.1. by mode 功能需求分类"></a>5.4.1. by mode 功能需求分类</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/47.png"></p><h3 id="5-4-2-by-user-class"><a href="#5-4-2-by-user-class" class="headerlink" title="5.4.2. by user class"></a>5.4.2. by user class</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/48.png"></p><h3 id="5-4-3-by-object"><a href="#5-4-3-by-object" class="headerlink" title="5.4.3. by object"></a>5.4.3. by object</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/49.png"></p><h3 id="5-4-4-by-feature"><a href="#5-4-4-by-feature" class="headerlink" title="5.4.4. by feature"></a>5.4.4. by feature</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/50.png"></p><h3 id="5-4-5-by-stimulus"><a href="#5-4-5-by-stimulus" class="headerlink" title="5.4.5. by stimulus"></a>5.4.5. by stimulus</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/51.png"></p><ol><li>根据刺激和不同的相应</li></ol><h3 id="5-4-6-by-functional-hierarchy"><a href="#5-4-6-by-functional-hierarchy" class="headerlink" title="5.4.6. by functional hierarchy"></a>5.4.6. by functional hierarchy</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/52.png"><br><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/53.png"></p><h3 id="5-4-7-multiple-organization"><a href="#5-4-7-multiple-organization" class="headerlink" title="5.4.7. multiple organization"></a>5.4.7. multiple organization</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/54.png"></p><h1 id="6-其他注意"><a href="#6-其他注意" class="headerlink" title="6. 其他注意"></a>6. 其他注意</h1><p>​1. alt是多选一，必选，将两个部分划分开。</p><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05-需求基础</title>
    <link href="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/"/>
    <url>/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/</url>
    
    <content type="html"><![CDATA[<h2 id="05-需求基础"><a href="#05-需求基础" class="headerlink" title="05-需求基础"></a>05-需求基础</h2><ol><li>软件需求是一个连接现实世界与计算机世界的活动:它既需要从问题出发，分析问题域，研究解决问题所需要的互动效应。</li></ol><h1 id="1-一个产品的开发过程"><a href="#1-一个产品的开发过程" class="headerlink" title="1. 一个产品的开发过程"></a>1. 一个产品的开发过程</h1><ol><li>客户想要什么</li><li>产品经理理解</li><li>设计师分析</li><li>程序员进行编写</li><li>交给测试人员测试</li><li>商业人员描述这个产品</li><li>项目的文档</li><li>如何进行部署</li><li>价格像过山车一样变化</li><li>如何进行支持运维</li><li>进行广告宣传</li><li>最后使用用户需要什么</li></ol><h1 id="2-需求工程的内容"><a href="#2-需求工程的内容" class="headerlink" title="2. 需求工程的内容"></a>2. 需求工程的内容</h1><h2 id="2-1-软件建立的依据"><a href="#2-1-软件建立的依据" class="headerlink" title="2.1. 软件建立的依据"></a>2.1. 软件建立的依据</h2><ol><li>单纯的软件系统是不能解决问题的，它只有和现实世界之间形成<strong>有效互动</strong>才能实现问题的解决</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/1.png"></p><h2 id="2-2-需求工程"><a href="#2-2-需求工程" class="headerlink" title="2.2. 需求工程"></a>2.2. 需求工程</h2><ol><li>需求工程的概念：所有需求处理活动的总和。它<strong>收集</strong>信息、<strong>分析</strong>问题、<strong>整合</strong>观点、记录需求并<strong>验证</strong>其正确性，最终描述出软件被应用后与其环境互动形成的<strong>期望效应</strong>。 </li><li>三个主要任务：<ol><li>需求工程必须说明软件系统将被应用的应用环境及其<strong>目标</strong>，说明用来达成这些目标的软件功能，也即要同时说明软件”需要<strong>做什么</strong>“和”<strong>为什么</strong>需要做”。</li><li>需求⼯程必须将⽬标和功能反映到软件系统当中，映射为<strong>可行的软件行为</strong>，并对软件⾏为进⾏准确的<strong>规格说明</strong>。</li><li>现实世界是<strong>不断变化</strong>的世界，因此需求⼯程还需要妥善处理⽬标和功能随着时间演化的变动情况。</li></ol></li></ol><h2 id="2-3-需求工程的具体活动"><a href="#2-3-需求工程的具体活动" class="headerlink" title="2.3. 需求工程的具体活动"></a>2.3. 需求工程的具体活动</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/2.png"></p><ol><li>需求要逐步进行<strong>验证</strong>，越早发现bug所付出的代价越少。</li><li>需求工程活动包括需求开发和需求管理两部分。</li></ol><h2 id="2-4-需求开发过程模型"><a href="#2-4-需求开发过程模型" class="headerlink" title="2.4. 需求开发过程模型"></a>2.4. 需求开发过程模型</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/3.png"></p><ol><li>需求获取是从利益相关人的问题域中提取出来的。</li><li>需求应该是面向很多人的，这样子才能体现出来需求的有用性。</li></ol><h2 id="2-5-需求获取"><a href="#2-5-需求获取" class="headerlink" title="2.5. 需求获取"></a>2.5. 需求获取</h2><ol><li>从<strong>人、文档或者环境</strong>当中获取需求的过程</li><li>要利⽤各种⽅法和技术来<strong>发现</strong>需求<ul><li>需求是客观存在的，但是一定是由需求开发人员提出的</li></ul></li></ol><h3 id="2-5-1-目标分析"><a href="#2-5-1-目标分析" class="headerlink" title="2.5.1. 目标分析"></a>2.5.1. 目标分析</h3><ol><li>根据问题确定目标:发现用户的期望和现实之间的差距</li><li>通过分析利害关系⼈确定目标:一个软件系统可能会有很多的厉害关系人，他们需要从各自立场出发，具有不同的目标要求</li></ol><h3 id="2-5-2-需求获取的常见困难"><a href="#2-5-2-需求获取的常见困难" class="headerlink" title="2.5.2. 需求获取的常见困难"></a>2.5.2. 需求获取的常见困难</h3><ol><li>⽤户和开发人员的背景不同，立场不同：”床边B超,肝胆胰脾”:很难以保证开发人员懂得这句话的含义</li><li>普通用户缺乏<strong>概括性、综合性</strong>的表述能⼒：不聪明的记者:请别人进行一句话描述</li><li>⽤户存在<strong>认知困境</strong>：平板电脑,在ipad还没有出现的时候</li><li>⽤户<strong>越俎代庖</strong>：双机热备:如果甲方有一定的经验，我们就是要求系统能够…，⾄于怎么实现是你开发者的事</li><li><strong>缺乏用户参与</strong>：不愿参与的医⽣：有一些情况下用户并不愿意参与开发</li></ol><h3 id="2-5-3-用户需求获取的方法"><a href="#2-5-3-用户需求获取的方法" class="headerlink" title="2.5.3. 用户需求获取的方法"></a>2.5.3. 用户需求获取的方法</h3><ol><li>面谈:面对面的会见；问答格式</li><li>问卷:集体获取方法之一</li><li>文档分析</li><li>头脑风暴:特殊的群体面谈方法，目的是发现潜在需求</li><li>专题讨论</li><li>原型:建立一个有形的制品来方便沟通和交流</li></ol><h3 id="2-5-4-以Story-board作为原型"><a href="#2-5-4-以Story-board作为原型" class="headerlink" title="2.5.4. 以Story board作为原型"></a>2.5.4. 以Story board作为原型</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/3.png"></p><h3 id="2-5-5-重新认识需求获取"><a href="#2-5-5-重新认识需求获取" class="headerlink" title="2.5.5. 重新认识需求获取"></a>2.5.5. 重新认识需求获取</h3><ol><li>⽤户和开发⼈员的背景不同，⽴场不同：”床边B超,肝胆胰脾”：消除默认知识</li><li>普通⽤户缺乏概括性、综合性的表述能力：不聪明的记者：专业的需求人员</li><li>⽤户存在认知困境：平板电脑：原型(做一个原型帮助用户理解的草图模型)</li><li>⽤户越俎代庖<ul><li>双机热备：需求是开发人员开发出来的，不是⽤户提出来的</li><li>我们就是要求系统能够….，⾄于怎么实现是你开发者的事：协商</li></ul></li><li>缺乏用户参与：不愿参与的医⽣：为用户参与提供⽅便</li></ol><h2 id="2-6-需求分析"><a href="#2-6-需求分析" class="headerlink" title="2.6. 需求分析"></a>2.6. 需求分析</h2><ol><li>通过<strong>建模</strong>来整合各种信息，以使得人们更好的理解问题。</li><li>为问题定义出⼀个需求集合，这个集合能够为问题界定⼀个有效的<strong>解决方案</strong>。</li><li><strong>检查</strong>需求当中存在的错误、遗漏、不⼀致等各种缺陷，并加以修正。</li></ol><h3 id="2-6-1-边界分析"><a href="#2-6-1-边界分析" class="headerlink" title="2.6.1. 边界分析"></a>2.6.1. 边界分析</h3><ol><li>定义项目的范围。系统边界之内定义的是系统需要对外提供的功能。</li><li>系统边界的定义要保证系统能够和周围环境形成有效的互动</li><li>系统⽤例图、上下文图通常被⽤来定义系统的边界。</li></ol><h3 id="2-6-2-需求建模"><a href="#2-6-2-需求建模" class="headerlink" title="2.6.2. 需求建模"></a>2.6.2. 需求建模</h3><ol><li>建模是为展现和解释信息⽽进⾏的抽象描述活动</li><li>常⽤的技术包括类图、顺序图、状态图等建模技术</li><li>在为需求建模时，常用的技术包括<strong>数据流图、实体关系图、状态转换图、类图</strong>等半形式化建模技术。</li></ol><h2 id="2-7-需求规格说明"><a href="#2-7-需求规格说明" class="headerlink" title="2.7. 需求规格说明"></a>2.7. 需求规格说明</h2><ol><li>在系统用户之间<strong>交流需求信息</strong></li><li>要简洁、精确、⼀致和易于理解</li><li>需求⼯程师在这个阶段的重要工作包括:<ol><li>定制文档模版，提高效率</li><li>编写文档(模型预言和自然语言两种)</li></ol></li></ol><h2 id="2-8-需求验证"><a href="#2-8-需求验证" class="headerlink" title="2.8. 需求验证"></a>2.8. 需求验证</h2><ol><li>需求规格说明文档至少要满足下面几个标准:<ol><li>⽂档内每条需求都<strong>正确、准确</strong>的反映了用户的意图；</li><li>⽂档记录的需求集在整体上具有<strong>完整性和⼀致性</strong>；</li><li>⽂档的组织⽅式和需求的书写⽅式具有<strong>可读性</strong>和**可修改性(方便保证版本简化)**。</li></ol></li><li>需求验证的方法:包括同级评审、原型、模拟等。</li></ol><h2 id="2-9-需求管理"><a href="#2-9-需求管理" class="headerlink" title="2.9. 需求管理"></a>2.9. 需求管理</h2><ol><li>保证需求作用的持续、稳定和有效发挥：在需求开发活动之后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展⼯作</li><li>进⾏变更控制：纳入和实现合理的变更请求，拒绝不合理的变更请求，控制变更的成本和影响范围</li></ol><h1 id="3-需求基础"><a href="#3-需求基础" class="headerlink" title="3. 需求基础"></a>3. 需求基础</h1><h2 id="3-1-需求-重要"><a href="#3-1-需求-重要" class="headerlink" title="3.1. 需求 重要"></a>3.1. 需求 重要</h2><ol><li>IEEE对需求的定义为[IEEE610.12-1990]：<ol><li>用户为了解决问题或达到某些目标所需要的条件或能力；</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；</li><li>对1或2中的一个条件或一种能力的一种文档化表述。</li></ol></li><li>需求是一种期望：源自现实又高于现实，需求是多变和可调整的，项⽬可以依据实际情况调整需求的实现程度。</li></ol><h2 id="3-2-需求的表述方式"><a href="#3-2-需求的表述方式" class="headerlink" title="3.2. 需求的表述方式"></a>3.2. 需求的表述方式</h2><ol><li>作为⼀种<strong>期望</strong>，需求通常被表述为”系统应该…”、”在…时，系统应该…”、 “⽤户可以通过系统…”等，例如R1。</li><li>R1：系统应该允许顾客退回已经购买的产品。</li></ol><h2 id="3-3-软件解决方案"><a href="#3-3-软件解决方案" class="headerlink" title="3.3. 软件解决方案"></a>3.3. 软件解决方案</h2><ol><li>需求是一种<strong>解决问题后所能达到的期望</strong></li><li>一件事情的两面<ul><li>问题是糟糕的一面</li><li>需求是理想的一面</li></ul></li></ol><h2 id="3-4-需求开发的目标"><a href="#3-4-需求开发的目标" class="headerlink" title="3.4. 需求开发的目标"></a>3.4. 需求开发的目标</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/4.png"></p><h2 id="3-5-问题域"><a href="#3-5-问题域" class="headerlink" title="3.5. 问题域"></a>3.5. 问题域</h2><ol><li>现实世界运行规律的一种反映</li><li>需求的<strong>产生域</strong>，也是需求的<strong>解决地</strong>。</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄⾃修改现实世界的实际情况。</li></ul></li></ol><h2 id="3-6-问题的解决"><a href="#3-6-问题的解决" class="headerlink" title="3.6. 问题的解决"></a>3.6. 问题的解决</h2><ol><li>基础：模拟与共享现象</li><li>⽅法：直接与间接</li><li>解决⽅案：需求规格说明</li></ol><h2 id="3-7-区分需求、问题域和规格说明"><a href="#3-7-区分需求、问题域和规格说明" class="headerlink" title="3.7. 区分需求、问题域和规格说明"></a>3.7. 区分需求、问题域和规格说明</h2><h3 id="3-7-1-问题域"><a href="#3-7-1-问题域" class="headerlink" title="3.7.1. 问题域"></a>3.7.1. 问题域</h3><ol><li>现实世界运⾏规律的⼀种反映</li><li>需求的<strong>产生域</strong>，也是需求的<strong>解决地</strong>。</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄⾃修改现实世界的实际情况。</li></ul></li></ol><h3 id="3-7-2-规格说明"><a href="#3-7-2-规格说明" class="headerlink" title="3.7.2. 规格说明"></a>3.7.2. 规格说明</h3><ol><li>软件产品的方案描述，它以软件产品的运行机制为主要内容。</li><li>它不是需求但实现需求，不是问题域但需要与问题域互动。</li><li>规格说明要以关注<strong>对外交互</strong>的⽅式描述软件解决⽅案，它既需要从软件产品的⻆度⽽不是⽤户的⻆度进⾏描述，⼜不能太多地涉及软件产品的内部构造机制。</li><li>为什么描述的是交互?<ul><li>因为交互对我们而言是一个对外的重要展示。</li></ul></li></ol><h2 id="3-8-超市销售系统"><a href="#3-8-超市销售系统" class="headerlink" title="3.8. 超市销售系统"></a>3.8. 超市销售系统</h2><ol><li>问题：超市的成本太⾼</li><li>需求：超市的成本应该降低:比较笼统</li><li>问题域：超市的成本主要由⼈⼒成本和库存成本组成</li><li>规格说明<ul><li>库存预测:大致进行推测</li><li>库存报警</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/5.png"></p><h1 id="4-三种需求层次-业务需求、用户需求、系统级需求-需求的层次性"><a href="#4-三种需求层次-业务需求、用户需求、系统级需求-需求的层次性" class="headerlink" title="4. 三种需求层次:业务需求、用户需求、系统级需求(需求的层次性)"></a>4. 三种需求层次:业务需求、用户需求、系统级需求(需求的层次性)</h1><ol><li>题型:给出一个实例，给出三个层次的例子，对给定的需求实例，判断其层次</li></ol><h2 id="4-1-业务需求-目标，解决方案与系统特性"><a href="#4-1-业务需求-目标，解决方案与系统特性" class="headerlink" title="4.1. 业务需求(目标，解决方案与系统特性)"></a>4.1. 业务需求(目标，解决方案与系统特性)</h2><ol><li>业务需求是高层次的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。</li><li>为什么是系统特性？因为还没有到细节的部分</li><li>特性说明了系统为⽤户提供的各项功能，它限定了系统的<strong>范围</strong>(Scope)</li></ol><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[示例]<br><span class="hljs-number">1.</span> R<span class="hljs-number">2</span>：在系统使⽤<span class="hljs-number">3</span>个月后，销售额度应该提⾼<span class="hljs-number">20</span><span class="hljs-meta">%</span><span class="hljs-comment">(期望，没有从软件角度进行描述，业务需求)</span><br><span class="hljs-number">2.</span> 可以建⽴高层次的解决⽅案，其系统特性如SF<span class="hljs-number">1</span>～SF<span class="hljs-number">4</span>所示。<span class="hljs-comment">(Feature)</span>，如下是系统需求<br>    SF<span class="hljs-number">1</span>：管理VIP顾客信息。<br>    SF<span class="hljs-number">2</span>：提供VIP顾客服务，增加回头率。<br>    SF<span class="hljs-number">3</span>：使⽤多样化的特价⽅案，吸引顾客购买，增加销售额。<br>    SF<span class="hljs-number">4</span>：使⽤多样化的赠送⽅案，吸引顾客购买，增加销售额。<br></code></pre></td></tr></table></figure><h2 id="4-2-用户需求-任务，问题域知识"><a href="#4-2-用户需求-任务，问题域知识" class="headerlink" title="4.2. 用户需求(任务，问题域知识)"></a>4.2. 用户需求(任务，问题域知识)</h2><ol><li>问题域知识：执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么<ol><li>直接用户</li><li>间接用户(<strong>通用软件的销售人员和售后支持人员</strong>)</li></ol></li><li>问题域知识：是需要了解到期望所来源的背景知识。</li><li><strong>特性</strong><ul><li>模糊、不清晰(允许适度的用形容词和副词) </li><li>多特性混杂 (功能和⾮功能的混杂)</li><li>多逻辑混杂 (⼀个任务需要多次系统交互才能完成)</li></ul></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[示例]<br><span class="hljs-bullet">1.</span> R3：系统要帮助收银员完成销售处理(期望，用户需求) <br><span class="hljs-bullet">2.</span> SF1：管理VIP顾客信息 针对系统需求<br><span class="hljs-bullet">3.</span> 针对每⼀个系统特性，都可以建⽴⼀组⽤户需求。例如对SF1，可以建⽴⽤户需求 组如UR1.1～UR1.7，它们中每⼀条都是⽤户完成具体任务所需要的功能：<br><span class="hljs-code">    UR1.1：系统应该允许客户经理添加、修改或者删除会员个⼈信息。(问题域)</span><br><span class="hljs-code">    UR1.2：系统应该记录会员的购买信息。</span><br><span class="hljs-code">    UR1.3：系统应该允许客户经理查看会员的个⼈信息和购买信息。</span><br><span class="hljs-code">    UR1.4：系统应该允许客户经理查看所有会员的统计信息。</span><br></code></pre></td></tr></table></figure><ul><li>例如对UR1.1，需要<strong>补充问题域知识</strong>如下：会员的个⼈信息有：客户编号、姓名、联系⽅式(具体是什么：手机、邮箱等)、积分。</li></ul><h2 id="4-3-系统需求"><a href="#4-3-系统需求" class="headerlink" title="4.3. 系统需求"></a>4.3. 系统需求</h2><ol><li>需求分析模型：用户对<strong>系统行为的期望</strong>，每个系统级需求反映了<strong>一次外界与系统的交互行为</strong>，或者<strong>系统的⼀个实现细节</strong>(和用户需求有着很大的区别)</li><li>描述了开发人员<strong>需要实现什么</strong></li><li>将用户需求转化为系统需求的过程是⼀个复杂的过程<ul><li>首先需要分析<strong>问题领域</strong>及其特性，从中发现问题域和计算机系统的共享知识，建⽴系统的知识模型；</li><li>然后将⽤户需求<strong>部署到系统模型</strong>当中，即定义系列的系统⾏为，让它们联合起来实现⽤户需求，每⼀个系统⾏为即为⼀个系统需求。</li><li>该过程就是需求⼯程当中最为重要的需求分析活动，⼜称<strong>建模与分析活动</strong>。</li></ul></li><li>系统级需求还可能会补充一些与软件实现相关的细节。</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[示例]<br><span class="hljs-bullet">1.</span> UR1.3：系统应该允许客户经理查看会员的个⼈信息和购买信息。<br><span class="hljs-bullet">2.</span> R4：收银员输⼊购买的商品时，系统要显示该商品的描述、单价、数量和总价。(期望，展现系统输入输出，系统级需求)<br><span class="hljs-bullet">3.</span> 对⽤户需求UR1.3，可以依据任务中的交互细节将之转化为系统级需求SR1.3.1～ SR1.3.4。<br><span class="hljs-code">    SR1.3.1在接到客户经理的请求后，系统应该为客户经理提供所有会员的个⼈信息。</span><br><span class="hljs-code">    SR1.3.2在客户经理输⼊会员的客户编号时，系统要提供该会员的个⼈信息。</span><br><span class="hljs-code">    SR1.3.3在客户经理选定⼀个会员并申请查看购买信息时，系统要提供该会员的历史购买记录。</span><br><span class="hljs-code">    SR1.3.4经理可以通过键盘输⼊客户编号，也可以通过读卡器输⼊客户编号。</span><br></code></pre></td></tr></table></figure><h2 id="4-4-综合示例"><a href="#4-4-综合示例" class="headerlink" title="4.4. 综合示例"></a>4.4. 综合示例</h2><ol><li>R1：在系统使用3个月后，销售额度应该提高20%(业务需求－为何开发系统)</li><li>R2：系统要帮助收银员完成销售处理；(用户需求－帮助用户做什么)</li><li>系统特性SF1：管理VIP顾客信息，针对每一个系统特性，都可以建立一组用户需求。例如对SF1，每一条都是用户完成具体任务所需要的功能：<ul><li>UR1.1：客户经理可以使用系统添加、修改或者删除会员个人信息。(用户需求)</li><li>UR1.2：收银员使用系统进行销售时会记录会员的购买信息。 (用户需求)</li><li>UR1.3：客户经理可以使用系统查看会员的个人信息和购买信息。(用户需求)</li><li>UR1.4：客户经理可以使用系统查看所有会员的统计信息。 (用户需求)</li></ul></li><li>R3：收银员输入购买的商品时，系统要显示该商品的描述、单价、数量和总价(系统级需求－系统怎么与外界交互)</li><li>对用户需求UR1.3，可以依据任务中的交互细节将之转化为系统级需求SR1.3.1～SR1.3.4。<ul><li>SR1.3.1在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。(系统级需求)</li><li>SR1.3.2在客户经理输入会员的客户编号时，系统要提供该会员的个人信息。(系统级需求)</li><li>SR1.3.3在客户经理选定一个会员并申请查看购买信息时，系统要提供该会员的历史购买记录。</li><li>SR1.3.4经理可以通过键盘输入客户编号，也可以通过读卡器输入客户编号。(系统级需求)</li></ul></li><li>ATM机：问题：营业厅人力成本过高，不吸引客户(业务需求)</li><li>问题域：存钱、取钱、转账(用户需求)</li></ol><h2 id="4-5-课堂练习"><a href="#4-5-课堂练习" class="headerlink" title="4.5. 课堂练习"></a>4.5. 课堂练习</h2><ol><li>NBA数据分析应用</li><li>业务需求<ol><li>NBA球队⽼板希望知道谁是2014-2015赛季最大⼼脏的投⼿？</li><li>老板想要买球星</li><li>老板想要知道应该派遣哪位球星上</li></ol></li><li>⽤户需求？<ol><li>系统应该允许老板可以查看各个投手的数据</li><li>系统应该允许老板查看最后两分钟，投手的得分率和投篮次数。</li><li>系统应该允许老板查看投手的转会信息和身价</li></ol></li><li>系统级需求？<ol><li>在接到老板的请求后，系统应该为老板提供所有球星的相关信息。</li></ol></li><li>千万不要忘记业务需求，一定要基于业务需求出发。</li></ol><h1 id="5-需求分类"><a href="#5-需求分类" class="headerlink" title="5. 需求分类"></a>5. 需求分类</h1><ol><li>题型:对给定实例，给出不同类型的需求例子；对给定的需求示例，判断需求类型</li></ol><h2 id="5-1-需求谱系分类"><a href="#5-1-需求谱系分类" class="headerlink" title="5.1. 需求谱系分类"></a>5.1. 需求谱系分类</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/7.png"></p><ol><li>需求展开为三项，系统需求展开为三项</li></ol><h2 id="5-2-综合案例"><a href="#5-2-综合案例" class="headerlink" title="5.2. 综合案例"></a>5.2. 综合案例</h2><ol><li>项目需求(<strong>人的数量、计划成本、时间</strong>)<ul><li>R5：项⽬的成本要控制在60万元人民币以下。</li><li>R6：项⽬要在6个月内完成。</li></ul></li><li>过程需求(<strong>人的分工、合作、方法、工具</strong>)<ul><li>R7：在开发中，开发者要提交软件需求规格说明⽂档、设计描述⽂档和测试报告。</li><li>R8：项⽬要使⽤持续集成⽅法进⾏开发。</li></ul></li><li>其他需求<ul><li>R9：系统要购买专用服务器，其规格不低于….。</li><li>R10：系统投⼊使⽤时，需要对⽤户进⾏1个星期的集中培训。</li></ul></li><li>不切实际的期望<ul><li>R11：系统要分析会员的购买记录，预测该会员将来⼀周和⼀个月内、会购买的商品；(技术上不可行)</li><li>R12：系统要能够对每⽉的出入库以及销售行为进⾏标准的财务分析；(在有限的资源条件下可行)</li><li>R13：在使⽤系统时，收银员必须要在2个⼩时内完成⼀个销售处理的所有操作。(超出了软件所影响的问题域范围)</li></ul></li><li>正确的形式<ul><li>R14：如果⼀个销售处理任务在2个小时内没有完成，系统要撤销该任务的所有已执⾏操作</li></ul></li></ol><h2 id="5-3-软件需求的分类-IEEE"><a href="#5-3-软件需求的分类-IEEE" class="headerlink" title="5.3. 软件需求的分类(IEEE)"></a>5.3. 软件需求的分类(IEEE)</h2><ol><li>功能需求(Functional Requirement)：和系统主要共作相关的需求，即在不考虑物理约束的情况下，⽤户希望系统所能够执行的活动，这些活动可以帮助⽤户完成任务。<strong>功能需求主要表现为系统和环境之间的⾏为交互</strong>。</li><li>性能需求(Performance Requirement)：系统整体或系统组成部分应该拥有的性能特征，例如CPU使⽤率、内存使⽤率等。</li><li>质量属性(Quality Attribute)：系统完成工作的质量，即系统需要在⼀个”好的程度”上实现功能需求，例如可靠性程度、可维护性程度等。</li><li>对外接口(External Interface)：系统和环境中其他系统之间需要建⽴的接⼝，包括硬件接⼝、软件接⼝、数据库接⼝等等。</li><li>约束：进⾏系统构造时需要遵守的约束，例如<strong>编程语言、硬件设施</strong>等</li></ol><h3 id="5-3-1-功能需求"><a href="#5-3-1-功能需求" class="headerlink" title="5.3.1. 功能需求"></a>5.3.1. 功能需求</h3><ol><li>功能需求是最常见、最主要和最重要的需求，是能够为用户带来业务价值的系统⾏为</li><li><strong>最需要按照三个抽象层次进行展开</strong>，说明了关系</li><li>软件产品产生价值的基础，需求检查最重要的部分</li><li>比如:在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。</li></ol><h3 id="5-3-2-数据需求"><a href="#5-3-2-数据需求" class="headerlink" title="5.3.2. 数据需求"></a>5.3.2. 数据需求</h3><ol><li><strong>功能需求</strong>的补充：如果在功能需求部分明确定义了<strong>相关的数据结构</strong>，那么就不需要再行定义数据需求</li><li>数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容：<ul><li>各个功能使⽤的<strong>数据信息</strong>；</li><li>使用频率；</li><li>可访问性要求；</li><li><strong>数据实体及其关系</strong>；</li><li>完整性约束；</li><li><strong>数据保持</strong>要求。</li></ul></li><li>例如，连锁超市销售系统可以使用数据需求DR1和DR2。<ul><li>DR1：系统需要存储的数据实体及其关系为图6-14的内容。(数据实体及其关系)</li><li>DR2：系统需要存储1年内的销售记录和退货记录。(数据保持)</li></ul></li></ol><h3 id="5-3-3-性能需求"><a href="#5-3-3-性能需求" class="headerlink" title="5.3.3. 性能需求"></a>5.3.3. 性能需求</h3><ol><li>需要进⾏专门的模拟和测试<ul><li>速度(Speed)，系统完成任务的时间，例如PR1。<ul><li>PR1：所有的⽤户查询都必须在<strong>10秒</strong>内完成。</li></ul></li><li>容量(Capacity)，系统所能存储的数据量，例如PR2。<ul><li>PR2：系统应该能够存储⾄少100万个销售信息。</li></ul></li><li>吞吐量(Throughput)，系统在连续的时间内完成的事务数量，例如PR3。<ul><li>PR3：解释器每分钟应该⾄少解析5000条没有错误的语句。</li></ul></li><li>负载(Load)，系统可以承载的并发⼯作量，例如PR4。<ul><li>PR4：系统应该允许50个营业服务器同时从集中服务器上进⾏数据的上传或下载。</li></ul></li><li>实时性(Time-Critical)，严格的实时要求，例如PR5。<ul><li>PR5：监测到病⼈异常后，监控器必须在0.5秒内发出警报。(和故障警报不同，故障不是系统的正常功能)</li></ul></li></ul></li><li>一定避免使用<strong>很快、较快</strong>等修饰词，而如果难以估计明确，应当结合需求的灵活性，保证可行性。</li></ol><h3 id="5-3-4-需求的灵活性"><a href="#5-3-4-需求的灵活性" class="headerlink" title="5.3.4. 需求的灵活性"></a>5.3.4. 需求的灵活性</h3><ol><li>PR6：98％的查询不能超过10秒。</li><li>PR7：<ul><li>(最低标准)在200个⽤户并发时，系统不能崩溃；</li><li>(⼀般标准)在200个⽤户并发时，系统应该在80％的时间内能正常⼯作；</li><li>(理想标准)在200个⽤户并发时，系统应该能保持正常的⼯作状态。</li></ul></li></ol><h3 id="5-3-5-质量属性"><a href="#5-3-5-质量属性" class="headerlink" title="5.3.5. 质量属性"></a>5.3.5. 质量属性</h3><ol><li>系统为了满⾜<strong>规定的及隐含</strong>的所有要求而需要具备的要素称为质量 </li><li>质量属性是为了度量质量要素而选用的特征 </li><li>质量模型就是能够为质量需求的描述和评价提供工作基础的特征集及特征之间的联系 </li><li>质量属性的重要性 <ul><li>对设计的影响很⼤ </li><li>对越复杂的系统越为重要 </li><li>[Robert19901] ：真实的现实系统中，在决定系统的成功或失败的因素中，满⾜⾮功能属性往往被满⾜功能性需求更为重要。</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/8.png"></p><h4 id="5-3-5-1-常见质量属性"><a href="#5-3-5-1-常见质量属性" class="headerlink" title="5.3.5.1. 常见质量属性"></a>5.3.5.1. 常见质量属性</h4><ol><li><strong>可靠性</strong>(Reliability)：在规格时间间隔内和规定条件下，系统或部件执⾏所要求能⼒的能⼒。<ul><li>QA1：在进⾏数据的下载和上传中，如果⽹络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复。</li></ul></li><li><strong>可用性</strong>(Availability)：软件系统在投⼊使⽤时可操作和可访问的程度或能实现其指定系统功能的概率。<ul><li>QA2：系统的可⽤性要达到98%。</li></ul></li><li><strong>安全性</strong>(Security)：软件阻⽌对其程序和数据进⾏未授权访问的能⼒，未授权的访问可能是有意，也可能是⽆意的。<ul><li>QA3：VIP顾客只能查看⾃⼰的个⼈信息和购买记录；</li><li>收银员只能查看，不能修改、删除VIP顾客的信息。</li></ul></li><li><strong>可维护性</strong>(Maintainability)：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。<ul><li>QA4：如果系统要增加新的特价类型，要能够在2个⼈⽉内完成。</li></ul></li><li><strong>可移植性</strong>(Portability)：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。<ul><li>QA5：集中服务器要能够在1⼈⽉内从Window 7操作系统更换到Solaris 10操作系统。</li></ul></li><li><strong>易用性</strong>(Usability)：与⽤户使⽤软件所花费的努⼒及其对使⽤的评价相关的特性。<ul><li>QA6：使⽤系统1个⽉的收银员进⾏销售处理的效率要达到10件商品&#x2F;分钟。</li></ul></li></ol><h4 id="5-3-5-2-质量属性的开发"><a href="#5-3-5-2-质量属性的开发" class="headerlink" title="5.3.5.2. 质量属性的开发"></a>5.3.5.2. 质量属性的开发</h4><ol><li>用户并不能明确地提出他们对产品质量的期望：并不了解软件系统的开发过程，也就⽆从判断哪些质量属性会在怎样的程度上给设计带来多大的影响，也⽆法将他们对软件系统的质量要求细化成⼀组组的可量化的质量属性</li><li>需求工程师<ul><li>质量属性⼤都是和功能需求联系在⼀起的，因此需要对照软件的质量属性检查每⼀项功能需求，尽⼒去判断质量属性存在的可能性 ，形容词和副词通常意味着质量属性的存在 </li><li>对于⼀些不和任何功能需求相联系的全局性质量属性，需求⼯程师要在碰到特定的实例时意识到它们的存在 </li><li>开发原型判断能不能保证可靠性等，和工程师进行确定</li></ul></li></ol><h3 id="5-3-6-对外接口"><a href="#5-3-6-对外接口" class="headerlink" title="5.3.6. 对外接口"></a>5.3.6. 对外接口</h3><ol><li><strong>解系统和其他系统</strong>之间的软硬件接⼝:包括硬件接口、软件接口、数据库接口等<ul><li>接口的用途</li><li>接口的输⼊输出</li><li>数据格式</li><li>命令格式</li><li>异常处理要求</li></ul></li><li>用户界面</li><li>案例，注册使用Google Maps API</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec5/9.png"></p><h3 id="5-3-7-约束"><a href="#5-3-7-约束" class="headerlink" title="5.3.7. 约束"></a>5.3.7. 约束</h3><ol><li>总体上限制了开发⼈员设计和构建系统时的选择范围 </li><li><strong>系统开发及运行的环境</strong><ul><li>包括目标机器、操作系统、⽹络环境、编程语⾔、数据库管理系统等</li><li>C1：系统要使⽤Java语言进⾏开发。</li></ul></li><li><strong>问题域内的相关标准</strong><ul><li>包括法律法规、⾏业协定、企业规章等。</li></ul></li><li><strong>商业规则</strong><ul><li>⽤户在任务执⾏中的⼀些潜在规则也会限制开发⼈员设计和构建系统的选择范围</li></ul></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">R1</span>：已过保质期的食品不能销售<br><span class="hljs-built_in">R2</span>：顾客可以使用美元付款<br></code></pre></td></tr></table></figure><ol><li>提交的地址解析请求次数是否有限制？(这就是为什么Google Map API进行控制)<ul><li>如果在 24 ⼩时时段内收到来⾃⼀个 IP 地址超过 15,000 个地址解析请求，或从⼀个 IP 地址提交的地址解析请求速率过快，Google 地图 API编 码器将⽤ 620 状态代码开始响应。如果地址解析器的使⽤仍然过多，则 从该 IP 地址对 Google 地图 API 地址解析器的访问可能被永久阻⽌。</li></ul></li></ol><h2 id="5-4-一些说明"><a href="#5-4-一些说明" class="headerlink" title="5.4. 一些说明"></a>5.4. 一些说明</h2><ol><li>整个需求：项目需求、过程需求、系统需求(包括软件需求、硬件需求和其他需求)</li><li>软件需求有着三中不同的层次需求:业务需求、用户需求和系统需求，分类是按照性能需求等等。</li><li>层次性:是指细节不一样，分类是指描述的东西不一样。</li></ol><h1 id="6-题目"><a href="#6-题目" class="headerlink" title="6. 题目"></a>6. 题目</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span> 为了有效地捕获系统需求<span class="hljs-operator">,</span>应采用<span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span> 。<br><span class="hljs-variable">A</span><span class="hljs-operator">.</span>瀑布模型<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span><span class="hljs-variable">V</span> 模型<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span>原型模型<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span>螺旋模型<br><span class="hljs-number">2.</span> 软件开发过程中，需求分析阶段的输出不包括<span class="hljs-punctuation">(</span><span class="hljs-built_in">D</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">A</span><span class="hljs-operator">.</span>数据流图<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span>实体联系图<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span>数据字典<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span>软件体系结构图<br><span class="hljs-number">3.</span> <span class="hljs-string">&quot;软件产品必须能够在 3 秒内对用户请求作出响应&quot;</span>属于软件需求中的<span class="hljs-punctuation">(</span><span class="hljs-variable">B</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">A</span><span class="hljs-operator">.</span>功能需求<br><span class="hljs-variable">B</span><span class="hljs-operator">.</span>非功能需求<br><span class="hljs-built_in">C</span><span class="hljs-operator">.</span>设计约束<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span>逻辑需求<br></code></pre></td></tr></table></figure><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04-项目启动</title>
    <link href="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/"/>
    <url>/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/</url>
    
    <content type="html"><![CDATA[<h2 id="04-项目启动"><a href="#04-项目启动" class="headerlink" title="04-项目启动"></a>04-项目启动</h2><h1 id="1-项目和项目管理"><a href="#1-项目和项目管理" class="headerlink" title="1. 项目和项目管理"></a>1. 项目和项目管理</h1><ol><li>项目的核心是计划：计划包括项目需要的资源、活动，以及在项目中需要产生的中间交付产品。</li></ol><h2 id="1-1-项目"><a href="#1-1-项目" class="headerlink" title="1.1. 项目"></a>1.1. 项目</h2><ol><li>项⽬是具有下列特征的⼀系列活动和任务[Kerzner2009]<ul><li>具有⼀个明确的目标；</li><li>有限定的开始和结束日期；</li><li>有成本限制；</li><li>消耗人力和⾮人力资源；</li><li>多工种合作。</li></ul></li><li>项目管理的目标<ul><li>在限定时间内；</li><li>在⼀定的成本内；</li><li>在要求的质量⽔平上；</li><li>⾼效使⽤资源；</li><li>获得客户认可。</li></ul></li><li>过程组：项目启动、项目计划、项目执⾏，项目跟踪与控制和项⽬收尾</li><li>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪 与控制、⻛险管理、配置管理</li></ol><h1 id="2-团队组织与管理"><a href="#2-团队组织与管理" class="headerlink" title="2. 团队组织与管理"></a>2. 团队组织与管理</h1><h2 id="2-1-团队"><a href="#2-1-团队" class="headerlink" title="2.1. 团队"></a>2.1. 团队</h2><ol><li>⼀个协作良好的团队是任何项目成功的基础。</li><li>软件项⽬尤其依赖于有效的团队组织和管理：软件开发是⼀个以⼈为主的活动，⼈⼒资源是软件项⽬最⼤的资产。</li><li>有很多实践者认为⽐⽣产⾼质量产品更⼤的成功是<strong>在⽣产过程中建⽴⼀个凝聚的团队</strong></li></ol><h2 id="2-2-团队的特征"><a href="#2-2-团队的特征" class="headerlink" title="2.2. 团队的特征"></a>2.2. 团队的特征</h2><ol><li>[Katzenbach1993]将团队定义为：为了⼀致的⽬的、绩效标准、⽅法⽽共担 责任并且技能互补的少数⼈。<ul><li>团队成员要具备共同的目标。</li><li>团队成员要共担责任。</li><li>团队成员要技能互补。</li><li>团队内部要有⼀个明确的结构。</li></ul></li></ol><h2 id="2-3-团队结构"><a href="#2-3-团队结构" class="headerlink" title="2.3. 团队结构"></a>2.3. 团队结构</h2><ol><li>主程序员团队:决策需要由主程序员进行制定<ul><li>效率高，如果完成把握大，并且需要时间紧迫，可以优先考虑</li><li>一个人的决断容易影响整个团队，如果项目复杂，主程序员会成为瓶颈。</li><li>适用于把握性大，时间要求紧的情况</li></ul></li><li>民主团队:没有集中的瓶颈，成员发挥能动性，工作效率降低，冲突解决。敏捷+较有挑战性的项目</li><li>开放团队:<ul><li>为了创新而存在的。黑箱管理，问题在于项目进展没有可视度。</li><li>相对于前两个团队的需求明确，团队的需求并不明确</li><li>管理者主要负责清除出现的障碍。</li><li>开放团队是为了创新而存在</li></ul></li></ol><h2 id="2-4-团队建设-高凝聚力的团队被称为胶冻团队-重要"><a href="#2-4-团队建设-高凝聚力的团队被称为胶冻团队-重要" class="headerlink" title="2.4. 团队建设(高凝聚力的团队被称为胶冻团队) 重要"></a>2.4. 团队建设(高凝聚力的团队被称为胶冻团队) 重要</h2><ol><li><strong>建立团队章程</strong>：建立明确的团队章程，统一团队成员的目标，对团队成员进行一定的约束。经验：有必要指定一定的章程，约束团队成员之间的行为，比如开会请假必须得到其他三人的同意，又如一旦某项决策做出，不同意者不能再后续阶段违反等。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/1.png"></p><ol start="2"><li><strong>持续成功</strong>：设置小里程碑，每隔一段时间让团队体验成功。每次作业的检查结果一定程度上肯定了每个小阶段的工作。</li><li><strong>和谐沟通</strong>：和谐沟通：建立持续有效的沟通机制，相互尊重，管道畅通，开放透明，坦诚真实。开会频率保持在每周一次左右为宜，在工作量大的时候，需要集体工作，当面沟通，另外吵架可以，但是需要达成一致。</li><li><strong>不断总结</strong>：不断总结上一阶段的工作成果，运用项目评审等手段，进行反思回顾，指导后续阶段的开发。每个阶段都会有启动会议对上个阶段进行回顾，评审会议对此阶段进行评审。</li><li><strong>避免团队杀手</strong>:需要对别人的工作全心全意的信任，尽管评审是必要的。产品质量的降低会使得凝聚力下降。<ul><li>防范式管理。</li><li>官僚主义。</li><li>地理分散:异地办公</li><li>时间分割:可以保证全天候有人在</li><li>产品质量的降低。</li><li>虚假的最后期限。</li><li>⼩圈子管理</li></ul></li><li>没有人能够成为多个胶冻团队的成员。</li></ol><h1 id="3-软件质量保障"><a href="#3-软件质量保障" class="headerlink" title="3. 软件质量保障"></a>3. 软件质量保障</h1><h2 id="3-1-软件质量"><a href="#3-1-软件质量" class="headerlink" title="3.1. 软件质量"></a>3.1. 软件质量</h2><ol><li>软件工程师也要对软件产品的质量负责。</li><li>对软件质量的要求可能是显式的，也可能是隐式的。</li><li>⼈们通常会选⽤系统的某些质量要素进⾏量化处理，建⽴质量特征，这些特征被称为质量属性(Quality Attribute)。</li><li>为了根据质量属性描述和评价系统的整体质量，⼈们从很多质量属性的定义当中选择了⼀些能够相互配合、相互联系的特征集，它们被称为质量模型。</li><li>详见书上的IEEE的标准 P54页</li></ol><h2 id="3-2-质量模型"><a href="#3-2-质量模型" class="headerlink" title="3.2. 质量模型"></a>3.2. 质量模型</h2><ol><li>因素</li><li>功能性</li><li>可靠性</li><li>易用性:人机交互</li><li>效率</li><li>可维护性</li><li>可移植性</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/2.png"></p><h2 id="3-3-质量保障"><a href="#3-3-质量保障" class="headerlink" title="3.3. 质量保障"></a>3.3. 质量保障</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/3.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/4.png"></p><h2 id="3-4-评审"><a href="#3-4-评审" class="headerlink" title="3.4. 评审"></a>3.4. 评审</h2><h3 id="3-4-1-典型的评审过程"><a href="#3-4-1-典型的评审过程" class="headerlink" title="3.4.1. 典型的评审过程"></a>3.4.1. 典型的评审过程</h3><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/5.png"></p><ol><li>在规划阶段(Planning)，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与⼈员、审查内容等等。</li><li>在总体部署阶段(Overview)，向所有参与审查会议的⼈员描述待审查材料的内容、审查的⽬标以及⼀些假设，并分发⽂档。</li><li>在准备阶段(Preparation)，审查⼈员各⾃独⽴执⾏检查任务。在检查的过程当中，他们可能会被要求使⽤检查清单、场景等检查⽅法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集 ⼈员。</li><li>在审查会议阶段(Inspection Meeting)，通过会议讨论，识别、确认、分类发现的错误。(200L&#x2F;h)</li><li>在返⼯阶段(Rework)，修改发现的缺陷。</li><li>在跟踪阶段(Follow-up)，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</li></ol><h2 id="3-5-质量度量"><a href="#3-5-质量度量" class="headerlink" title="3.5. 质量度量"></a>3.5. 质量度量</h2><ol><li>度量产⽣⾃统计控制(Statistical Control)思想。”你不能控制⾃⼰⽆法度量的东⻄”[DeMarco1998]。</li><li>测度(Measure)就是为了描述软件产品⽽提供的定量指标：代码⾏数</li><li>进行测度的活动被称为测量(Measurement)。</li><li>度量(Metric)是软件产品在特定属性上的量化测度程度。</li><li>例如基于所有对象的代码⾏数测度可以建⽴平均代码⾏数、最⼤代码⾏数、最⼩代码⾏数</li></ol><h2 id="3-6-质量保障有哪些措施-重要"><a href="#3-6-质量保障有哪些措施-重要" class="headerlink" title="3.6. 质量保障有哪些措施(重要)"></a>3.6. 质量保障有哪些措施(重要)</h2><ol><li>需求开发——需求评审和需求度量；</li><li>体系结构——体系结构评审和集成测试(持续集成)；</li><li>详细设计——详细设计评审、设计度量和集成测试(持续集成)；</li><li>构造阶段——代码评审、代码度量、测试(测试驱动和持续集成)；</li><li>测试阶段——测试、测试度量。</li><li>要及时的根据保障计划进行质量验证，质量验证的方法主要有评审、测试和质量度量三种。</li></ol><h1 id="4-软件配置管理"><a href="#4-软件配置管理" class="headerlink" title="4. 软件配置管理"></a>4. 软件配置管理</h1><h2 id="4-1-软件配置管理的动机"><a href="#4-1-软件配置管理的动机" class="headerlink" title="4.1. 软件配置管理的动机"></a>4.1. 软件配置管理的动机</h2><ol><li>在软件开发活动中，除了最终产品之外，还会产⽣很多中间制品，例如需求规格说明、需求分析模型、软件体系结构设计模型、详细设计模型等。这些制品是不同阶段、不同⻆⾊、不同软件开发活动进⾏协同的基础。</li><li>在复杂软件系统开发中，产⽣的制品数量众多，以⾄于开发者需要维护⼀个清单才能清楚项⽬所处的状态，理解已经完成的⼯作和将要进⾏的⼯作。</li><li>某个制品发⽣变化带来的最⼤挑战是如何确保其使⽤者能够得到最新的制品，避免开发协同出现问题。</li></ol><h2 id="4-2-配置管理"><a href="#4-2-配置管理" class="headerlink" title="4.2. 配置管理"></a>4.2. 配置管理</h2><ol><li>IEEE将配置管理定义为[IEEE610.12-1990]：”⽤技术的和管理的指导和监督⽅法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的⼀致性”。</li></ol><h2 id="4-3-配置项"><a href="#4-3-配置项" class="headerlink" title="4.3. 配置项"></a>4.3. 配置项</h2><ol><li>IEEE将配置项定义为[IEEE610.12-1990]：”置于软件配置管理之下的软件配置的各种有关项⽬，包括各类管理⽂档、评审记录与⽂档、软件文档、源码及其可执⾏码、运⾏所需的系统软件和⽀持软件以及有关数据等”。</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/6.png"></p><ol start="2"><li>一旦需求发生变更，则需要从评审开始重新操作</li></ol><h2 id="4-4-基线"><a href="#4-4-基线" class="headerlink" title="4.4. 基线"></a>4.4. 基线</h2><ol><li>基线是指通过了评审和验证，可以作为后续开发工作基础而进入协同工作过程，需要纳入配置管理和执行变更控制的制品称为该配置项的<strong>基线</strong>。</li></ol><h2 id="4-5-配置管理活动-重要"><a href="#4-5-配置管理活动-重要" class="headerlink" title="4.5. 配置管理活动(重要)"></a>4.5. 配置管理活动(重要)</h2><ol><li>标识配置项版本管理:确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。</li><li>版本管理：极其重要</li><li>变更控制：变更请求表单，教材61页</li><li>配置审计:验证配置项的完整性、正确性、一致性和可追踪性。</li><li>状态报告:反映当前的配置状态。</li><li>软件发布管理:将配置项发布到开发活动之外，例如发布给客户。</li></ol><h2 id="4-6-辅助管理工具"><a href="#4-6-辅助管理工具" class="headerlink" title="4.6. 辅助管理工具"></a>4.6. 辅助管理工具</h2><p>在项目实践中，使用配置管理工具对项目进行配置管理，如SVN。 </p><h2 id="4-7-版本管理示意图"><a href="#4-7-版本管理示意图" class="headerlink" title="4.7. 版本管理示意图"></a>4.7. 版本管理示意图</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/7.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/8.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/9.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/10.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/11.png"></p><h3 id="4-7-1-分支管理常见策略"><a href="#4-7-1-分支管理常见策略" class="headerlink" title="4.7.1. 分支管理常见策略"></a>4.7.1. 分支管理常见策略</h3><ol><li>主分支(Master)</li><li>开发分支(Develop)</li><li>临时性分支<ul><li>功能(Feature)</li><li>预发布(Release)</li><li>修补bug(Fixbug)</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/12.png"></p><h3 id="4-7-2-查看不同"><a href="#4-7-2-查看不同" class="headerlink" title="4.7.2. 查看不同"></a>4.7.2. 查看不同</h3><ol><li>git diff<ul><li>⼯作区 vs 暂存区</li></ul></li><li>git diff head<ul><li>⼯作区 vs 版本库</li></ul></li><li>git diff –cached<ul><li>暂存区 vs 版本库</li></ul></li></ol><h3 id="4-7-3-为啥要暂存区"><a href="#4-7-3-为啥要暂存区" class="headerlink" title="4.7.3. 为啥要暂存区"></a>4.7.3. 为啥要暂存区</h3><ol><li>增加灵活性<ul><li>修改了4个⽂件，在不放弃任何修改的情况下，其中⼀个⽂件不想提交，如何操作？(没add : git add 已经add: git reset –soft )</li><li>修改到⼀半的⽂件，突然间不需要或者放弃修改了，怎么恢复未修改前⽂件？ (git checkout)</li><li>代码写⼀半，被打断去做其他功能开发，未完成代码保存？(git stash)</li><li>代码写⼀半，发现忘记切换分支了？(git stash &amp; git checkout)</li><li>代码需要回滚了？(git reset)</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/13.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/14.png"></p><h2 id="4-8-变更要求表单"><a href="#4-8-变更要求表单" class="headerlink" title="4.8. 变更要求表单"></a>4.8. 变更要求表单</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/15.png"></p><h1 id="5-管理实践"><a href="#5-管理实践" class="headerlink" title="5. 管理实践"></a>5. 管理实践</h1><h2 id="5-1-经济为本"><a href="#5-1-经济为本" class="headerlink" title="5.1. 经济为本"></a>5.1. 经济为本</h2><ol><li>⼈员的成本：这是最重要的一部分投⼊。现在的软件从业⼈员的⼯资不断上涨，⼯资占整个软件成本的⽐例更是呈上升趋势。 除了开发⼈员外，还要计算项⽬管理⼈员和其他相应⽀持⼈员的费⽤(不是全职的，按时间乘⽐例计算)。</li><li>工具的购买：包括计算机及其周围配套设备等硬件，也包括开发⼯具、办公套件等软件。</li><li>培训的费⽤：开发⼈员接受培训，获得开发项⽬所需技能的费⽤。</li><li>差旅费：拜访客户，参加会议等的费⽤。</li><li>维护的费⽤：定时的数据备份、系统监控、系统维修和升级等引起的费⽤。</li><li>生产停顿的损失：因为项⽬调试引起正常⼯作业务停顿的损失。</li><li>市场和服务的费⽤：推⼴软件产品所要的⼴告费⽤、参加展览会的费⽤等。</li><li>机会成本：因为投资该项⽬，⽽不能投资别的项⽬或者放银⾏收取利息的机会成本。</li><li>节约商业活动成本：只要是和⽆新软件系统时候⽐较，将节省的时间和原材料折算成量化的数字。例如，开发了 新的库存管理系统后，加快了流通并减少了库存浪费。</li><li>创新商机增加销售：指由于使⽤新软件带来的盈利，可能是软件产品本身的销售，也可能是软件项⽬带来的营业 成⻓。</li><li>提⾼品牌含⾦量： 提⾼质量和客户满意度，可以带来品牌含⾦量的提⾼。这⽐较虚⼀点，但也可以像企业的⽆ 形资产⼀样估算。</li></ol><h3 id="5-1-1-总结"><a href="#5-1-1-总结" class="headerlink" title="5.1.1. 总结"></a>5.1.1. 总结</h3><ol><li>为技术⽽技术是条死胡同</li><li>以经济原则指导软件项⽬的决策过程</li><li>按照产品规律来营销软件产品</li><li>以收益为依据规划设计产品</li></ol><h2 id="5-2-分工协作"><a href="#5-2-分工协作" class="headerlink" title="5.2. 分工协作"></a>5.2. 分工协作</h2><h3 id="5-2-1-建议的团队"><a href="#5-2-1-建议的团队" class="headerlink" title="5.2.1. 建议的团队"></a>5.2.1. 建议的团队</h3><ol><li>⾸席程序员</li><li>副⼿</li><li>⾏政助理</li><li>编辑</li><li>秘书两名</li><li>程序管理员</li><li>⼯具专家</li><li>测试员</li><li>语⾔专家</li></ol><h3 id="5-2-2-三架马车"><a href="#5-2-2-三架马车" class="headerlink" title="5.2.2. 三架马车"></a>5.2.2. 三架马车</h3><ol><li>产品经理:关于产品需求</li><li>项目经理:实施过程中的管理<ul><li>配置管理、合理、管理、控制</li></ul></li><li>技术经理:保证可以克服技术难题</li></ol><h3 id="5-2-3-项目管理的角色"><a href="#5-2-3-项目管理的角色" class="headerlink" title="5.2.3. 项目管理的角色"></a>5.2.3. 项目管理的角色</h3><ol><li>非正式的角色</li><li>明确定义的角色(PM)<ul><li>领导整个团队以了解项⽬⼯作(计划，进度安排以及收集需求)</li><li>带领项⽬进⾏设计和开发⼯作(沟通、决策以及中期策略)</li><li>以及驱动完成整个项⽬(领导⼒、⻛险管理以及终局策略)</li></ul></li></ol><h2 id="5-3-目标驱动"><a href="#5-3-目标驱动" class="headerlink" title="5.3. 目标驱动"></a>5.3. 目标驱动</h2><ol><li>确保原因的合理性</li></ol><h3 id="5-3-1-目标的SMART原则"><a href="#5-3-1-目标的SMART原则" class="headerlink" title="5.3.1. 目标的SMART原则"></a>5.3.1. 目标的SMART原则</h3><ol><li>speciﬁc 明确的</li><li>measurable 可度量的</li><li>achievable 可实现的</li><li>reasonable 有理由的</li><li>time 时间</li></ol><h2 id="5-4-常来常往"><a href="#5-4-常来常往" class="headerlink" title="5.4. 常来常往"></a>5.4. 常来常往</h2><h3 id="5-4-1-观念"><a href="#5-4-1-观念" class="headerlink" title="5.4.1. 观念"></a>5.4.1. 观念</h3><ol><li>相互尊重</li><li>管道流畅</li><li>开放透明</li><li>坦诚真实</li></ol><h2 id="5-5-有张有弛"><a href="#5-5-有张有弛" class="headerlink" title="5.5. 有张有弛"></a>5.5. 有张有弛</h2><h3 id="5-5-1-方法"><a href="#5-5-1-方法" class="headerlink" title="5.5.1. 方法"></a>5.5.1. 方法</h3><ol><li>启动大会</li><li>发布聚会</li><li>休假</li><li>技术培训</li><li>⼈员培训和被培训</li><li>换个项⽬</li></ol><h2 id="5-6-不断总结"><a href="#5-6-不断总结" class="headerlink" title="5.6. 不断总结"></a>5.6. 不断总结</h2><ol><li>关键是”不断”</li></ol><h3 id="5-6-1-给管理新手的建议"><a href="#5-6-1-给管理新手的建议" class="headerlink" title="5.6.1. 给管理新手的建议"></a>5.6.1. 给管理新手的建议</h3><ol><li>压⼒和分⼼</li><li>不要将流程与⽬标相混淆</li><li>适度参与</li><li>利⽤好⾃⼰的观点</li><li>创造独特的价值</li><li>你所知道的⽐你想象的要多。</li><li>让⼈喜欢是好事，但不⽤刻意讨好。</li><li>⼈们并不介意⾃⼰被管理。</li><li>如果你想唤起别⼈对某件事的热情，⾃⼰先表现出热情。</li><li>需要坦⽩的时候就直⾔不讳。</li><li>你需要不停地进步。</li></ol><h1 id="6-项目实践"><a href="#6-项目实践" class="headerlink" title="6. 项目实践"></a>6. 项目实践</h1><ol><li>为实践项⽬组建你的团队：<ul><li>选择技能互补的成员组成团队，明确分⼯；</li><li>根据成员特点，选择团队结构；(建议使⽤⺠主团队)</li><li>建⽴团队章程；</li><li>明确团队的交流沟通⼿段。</li><li>需要保留开发过程，用来确保可查</li></ul></li><li>配置管理<ul><li>所有产物都通过Gitlab来管理</li><li>建⽴Group</li><li>⽂档采⽤MD⽂件</li></ul></li><li>项目结构:</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/15.png"><br><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec4/16.png"></p><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03-实例项目描述</title>
    <link href="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec3/"/>
    <url>/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec3/</url>
    
    <content type="html"><![CDATA[<h2 id="03-实例项目描述"><a href="#03-实例项目描述" class="headerlink" title="03-实例项目描述"></a>03-实例项目描述</h2><ol><li>对应课本中的第三章</li></ol><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><h1 id="2-目标"><a href="#2-目标" class="headerlink" title="2. 目标"></a>2. 目标</h1><ol><li>数值化的硬性要求</li></ol><h1 id="3-系统用户"><a href="#3-系统用户" class="headerlink" title="3. 系统用户"></a>3. 系统用户</h1><table><thead><tr><th>用户类别</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>-</td></tr></tbody></table><ol><li>简单描述各个用户的行为和系统期望。</li><li>往往要有系统管理员</li></ol><h1 id="4-用户访谈要点"><a href="#4-用户访谈要点" class="headerlink" title="4. 用户访谈要点"></a>4. 用户访谈要点</h1><ol><li>根据上面的系统用户进行单个的分析</li><li>主要包含:基本情况、对新系统的态度(要求)、工作细节、可能出现的问题等。</li></ol><h1 id="5-项目时间过程"><a href="#5-项目时间过程" class="headerlink" title="5. 项目时间过程"></a>5. 项目时间过程</h1><ol><li>需要绘制各个部分对应的图，从项目启动、需求分析、软件设计、软件构造、软件测试、软件移交等部分。</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02-软件工程的发展</title>
    <link href="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/"/>
    <url>/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/</url>
    
    <content type="html"><![CDATA[<h2 id="02-软件工程的发展"><a href="#02-软件工程的发展" class="headerlink" title="02-软件工程的发展"></a>02-软件工程的发展</h2><h1 id="1-软件工程的三个环境因素"><a href="#1-软件工程的三个环境因素" class="headerlink" title="1. 软件工程的三个环境因素"></a>1. 软件工程的三个环境因素</h1><ol><li>基础：抽象软件实体和虚拟计算机</li><li>目标：现实的问题</li><li>三个环境因素:<ol><li>目标</li><li>正确性基础</li><li>实现基础</li></ol></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/1.png"></p><h2 id="1-1-现实"><a href="#1-1-现实" class="headerlink" title="1.1. 现实"></a>1.1. 现实</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/2.png"></p><h2 id="1-2-抽象软件"><a href="#1-2-抽象软件" class="headerlink" title="1.2. 抽象软件"></a>1.2. 抽象软件</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/3.png"></p><h2 id="1-3-虚拟机"><a href="#1-3-虚拟机" class="headerlink" title="1.3. 虚拟机"></a>1.3. 虚拟机</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/4.png"></p><h1 id="2-软件发展历程"><a href="#2-软件发展历程" class="headerlink" title="2. 软件发展历程"></a>2. 软件发展历程</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/5.png"></p><h1 id="3-Before-1950s-软件是硬件一部分"><a href="#3-Before-1950s-软件是硬件一部分" class="headerlink" title="3. Before 1950s 软件是硬件一部分"></a>3. Before 1950s 软件是硬件一部分</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/6.png"></p><ol><li>科学研究(主要是军事用途)</li><li>计算理论(lambda演算和图灵机)</li><li>冯诺依曼架构</li><li>软件是硬件的一部分</li></ol><h1 id="4-年代-1950s"><a href="#4-年代-1950s" class="headerlink" title="4. 年代:1950s"></a>4. 年代:1950s</h1><h2 id="4-1-软件工程和硬件工程是一样的"><a href="#4-1-软件工程和硬件工程是一样的" class="headerlink" title="4.1. 软件工程和硬件工程是一样的"></a>4.1. 软件工程和硬件工程是一样的</h2><ol><li>第一代编程语言:机器语言，第二代编程语言:汇编语言</li><li>主框架研究和BIOS</li><li>硬件主导的发展过程</li></ol><h2 id="4-2-发展过程"><a href="#4-2-发展过程" class="headerlink" title="4.2. 发展过程"></a>4.2. 发展过程</h2><ol><li>虚拟计算机<ul><li>第一台商用计算机(UNIVAC I)</li><li>机器为中心</li></ul></li><li>抽象软件实体<ul><li>格雷斯·霍珀是哈佛Mark I计算机的第一批程序员之一，该领域的先驱，大约在1952年为计算机编程语言开发了第一个编译器。</li><li>20世纪50年代早期计算机的程序员，特别是UNIVAC I和IBM 701，使用机器语言程序，即第一代语言(1GL)。1GL编程很快被类似的机器专用语言(2GL)所取代，这种语言被称为汇编语言或”汇编程序”。</li></ul></li></ol><h2 id="4-3-机器为中心"><a href="#4-3-机器为中心" class="headerlink" title="4.3. 机器为中心"></a>4.3. 机器为中心</h2><ol><li>我⼯作的第⼀天(1950s)，我的主管向我展示了通用电⼒ERA1103计算机，这个家伙⾜⾜占满了⼀个⼤房间。他对我说：”听着，我们每⼩时要为这台计算机⽀出600美元，⽽每⼩时只需为你⽀出2美元，我想你知道该怎么做了” -Boehm 2006</li></ol><h2 id="4-4-软件发展方法"><a href="#4-4-软件发展方法" class="headerlink" title="4.4. 软件发展方法"></a>4.4. 软件发展方法</h2><ol><li>在这⼀时期，⼈们的主要集中⼒放在硬件上，所以没有出现对软件开发专⻔⽅法与技术的需求，也就没有出现被普遍使用的软件开发⽅法与技术。</li></ol><h2 id="4-5-软件发展过程"><a href="#4-5-软件发展过程" class="headerlink" title="4.5. 软件发展过程"></a>4.5. 软件发展过程</h2><ol><li>美国和加拿大防空半自动化地面环境</li><li>1个MLOC防空系统，实时，365 * 24，用户密集型</li><li>成功让很多难以预估的系统的发展</li><li>硬件主导的瀑布式过程</li></ol><h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6. 总结"></a>4.6. 总结</h2><ol><li>科学计算</li><li>机器为中心的科学主题</li><li>第一代和第二代编程语言</li><li>软件工程和硬件工程是相似的</li><li>硬件主导的发展过程</li><li>强调回溯和测试</li><li>科学家和硬件工程师</li></ol><h1 id="5-年代-1960s"><a href="#5-年代-1960s" class="headerlink" title="5. 年代:1960s"></a>5. 年代:1960s</h1><h2 id="5-1-过程"><a href="#5-1-过程" class="headerlink" title="5.1. 过程"></a>5.1. 过程</h2><ol><li>虚拟计算机<ul><li>更好的基础设施：操作系统、编译器(函数式)、应用</li><li>产品系列：OS-360, CAD&#x2F;CAM, math&#x2F;statistics libraries</li><li>许多巨大的成功：Apollo, ESS, BofA check processing</li><li>信用卡、ATM</li></ul></li><li>抽象软件实体<ul><li>在20世纪50年代后期，汇编语言程序设计发展到包括宏指令的使用，随后又发展了”第三代”程序设计语言(3GL)，如FORTRAN、LISP和COBOL。</li><li>ASCII美国信息交换标准码</li></ul></li></ol><h2 id="5-2-两个重要的诉讼案"><a href="#5-2-两个重要的诉讼案" class="headerlink" title="5.2. 两个重要的诉讼案"></a>5.2. 两个重要的诉讼案</h2><ol><li>通过⼀项诉讼案裁定ENIAC专利不再有效(1973裁决)<ul><li>使得计算机体系结构从此进⼊公共领域</li></ul></li><li>作为反垄断诉讼的结果，IBM同意分类定价软件<ul><li>使得软件不再依附于计算机硬件，独⽴存在</li></ul></li></ol><h2 id="5-3-应用为中心"><a href="#5-3-应用为中心" class="headerlink" title="5.3. 应用为中心"></a>5.3. 应用为中心</h2><ol><li>商业应用</li><li>批处理过程</li></ol><h2 id="5-4-软件不是硬件"><a href="#5-4-软件不是硬件" class="headerlink" title="5.4. 软件不是硬件"></a>5.4. 软件不是硬件</h2><ol><li>软件与现实世界关系更加密切，对需求的规格化更加困难：[Royce1970]提到”⽣产500万美元的硬件设备，30⻚的规格说明书就可以 为⽣产提供⾜够多的细节，⽣产500万美元的软件，1500⻚的规格说明书 才可以获取相当的控制。”</li><li>软件⽐硬件容易修改的多，并且不需要昂贵的⽣产线复制产品：因为不需要昂贵的⽣产线，所以⼈⼒资源是软件开发的最⼤资源，⼈⼒成 本是软件开发的主要成本，⼈的因素是软件开发中的最⼤因素。</li><li>软件没有损耗：软件维护的主要⼯作是修改软件，主要成本是修改的⼈⼒成本。为了降低维护成本，要求开发者在开发时就要让软件产品设计的易于修改。</li><li>软件不可见：很难辨别软件进度是否正常，需要开发者更多地使用模型⼿段以可视图形的⽅式反映软件⽣产，也需要开发者使用更深⼊的⼿段(例如度量)监控软件⽣产过程。</li></ol><h2 id="5-5-软件危机"><a href="#5-5-软件危机" class="headerlink" title="5.5. 软件危机"></a>5.5. 软件危机</h2><ol><li>软件危机<ol><li>对软件开发成本和进度的估计常常不准确。开发成本超出预算，实际进度⽐预定计划⼀再拖延的现象并不罕⻅。 </li><li>用户对”已完成”系统不满意的现象经常发⽣。</li><li>软件产品的质量不可靠。</li><li>软件的可维护程度⾮常之低。</li><li>软件通常没有适当的⽂档资料。</li><li>软件的成本不断提高。</li><li>软件开发⽣产率无法满足⼈们对软件的生产要求，软件开发⽣产率的提⾼落后于硬件的发展。</li></ol></li><li>这⼀情况迫使NATO科学委员会在1968和1969年召开两届⾥程碑式的”软件⼯程”会议，很多业界领先的研究者和实践者参加了这两届会议。1968年的会议主要分析了软件⽣产中的问题，提出了”软件危机”的说法。1969年的会议着重讨论了”软件危机”的解决⽅法，指出了”软件⼯程”的⽅向[Peter1969]，用⼯程的⽅法⽣产软件。</li></ol><h2 id="5-6-软件发展方法"><a href="#5-6-软件发展方法" class="headerlink" title="5.6. 软件发展方法"></a>5.6. 软件发展方法</h2><ol><li>因为缺乏正确科学知识的指导，也没有多少经验原则可以遵循，因此1960s的软件开发在总体上依靠程序员的个⼈能⼒，是”工艺式”的开发。</li><li>到了1960s后期，因为认识到”工艺式”开发的问题，很多研究者开始从编程入手探索解决软件危机的办法，这些促成了1970s结构化编程⽅法的建⽴。</li></ol><h2 id="5-7-软件发展过程"><a href="#5-7-软件发展过程" class="headerlink" title="5.7. 软件发展过程"></a>5.7. 软件发展过程</h2><ol><li>牛仔式编程</li><li>软件工艺</li><li>个人英雄主义</li></ol><h2 id="5-8-问题"><a href="#5-8-问题" class="headerlink" title="5.8. 问题"></a>5.8. 问题</h2><ol><li>意大利面条，易读性低</li><li>很多的bug</li><li>大项目往往计划和控制很脆弱</li></ol><h2 id="5-9-总结"><a href="#5-9-总结" class="headerlink" title="5.9. 总结"></a>5.9. 总结</h2><ol><li>商业应用(批处理过程)</li><li>应用为中心商业框架</li><li>第三代编程语言</li><li>软件不是硬件</li><li>软件工艺的提出</li><li>计算机科学系的出现</li><li>软件危机的出现</li><li>软件需求超过软件工程师的供应 </li><li>图灵奖(1966)</li></ol><h1 id="6-年代-1970s-结构化方法、瀑布模型和形式化方法"><a href="#6-年代-1970s-结构化方法、瀑布模型和形式化方法" class="headerlink" title="6. 年代:1970s 结构化方法、瀑布模型和形式化方法"></a>6. 年代:1970s 结构化方法、瀑布模型和形式化方法</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/8.png"></p><ol><li>软件产品</li><li>商业微型计算机</li><li>结构化编程语言</li><li>结构化编程，瀑布模型和形式化方法</li></ol><h2 id="6-1-过程"><a href="#6-1-过程" class="headerlink" title="6.1. 过程"></a>6.1. 过程</h2><ol><li>虚拟计算机<ul><li>数据库管理系统</li><li>编译器</li><li>开发环境</li><li>软盘，软盘驱动器</li></ul></li><li>抽象软件实体<ul><li>在1969到1973之间被作为一种系统编程语言发展，并且保持常用。</li><li>Pascal(1970)，Smalltalk(1972)，Prolog，Scheme(1975)，SQL(1978)</li><li>函数式、块结构、顺序、分支、循环</li></ul></li></ol><h2 id="6-2-软件发展方法"><a href="#6-2-软件发展方法" class="headerlink" title="6.2. 软件发展方法"></a>6.2. 软件发展方法</h2><ol><li>结构化编程语言<ul><li>函数</li><li>顺序，分支，循环</li></ul></li><li>自上而下，逐步求解</li><li>分解思想分层思想</li><li>图的思想</li><li>模块化，数据隐藏</li><li>抽象数据类型</li><li>结构化方法</li></ol><h2 id="6-3-结构化方法"><a href="#6-3-结构化方法" class="headerlink" title="6.3. 结构化方法"></a>6.3. 结构化方法</h2><ol><li>结构化编程(Bohm-Jacopini: GO TO 是不应该常有的)<ul><li>形式化编程：Dijkstra, Hoare, Floyd</li><li>正式自上而下的SP:Mills、Baker</li></ul></li><li>通过以下来组织程序<ul><li>函数：算法</li><li>三种控制逻辑</li><li>格式和格式检查</li></ul></li><li>当编译器处理好函数时，有组织的程序：模块化方法</li><li>模块化使这些事情变得重要<ul><li>信息隐藏</li><li>数据抽象</li></ul></li><li>使用数据流图、实体关系图和结构图来进行结构化设计。</li></ol><h2 id="6-4-形式化方法"><a href="#6-4-形式化方法" class="headerlink" title="6.4. 形式化方法"></a>6.4. 形式化方法</h2><ol><li>“形式方法”的分支，通过数学证明或通过”编程演算”的构造来关注程序的正确性</li><li>在60年代的十年里，理论计算机科学作为一门被数学界和计算界都认可的学科，它可以指向应用和数学的优雅</li><li>工作量大，一般是很重要的程序才使用形式化方法处理</li></ol><h2 id="6-5-形式化方法的问题"><a href="#6-5-形式化方法的问题" class="headerlink" title="6.5. 形式化方法的问题"></a>6.5. 形式化方法的问题</h2><ol><li>对于小的重要的程序是成功的</li><li>最大的验证项目约10 KSLOC</li><li>证据表明存在缺陷，而不是缺失<ul><li>规格有缺陷，证明有问题</li></ul></li><li>程序员社区的可伸缩性<ul><li>技术需要数学专业知识，500美元&#x2F;SLOC</li><li>1975年调查中的平均程序员<ul><li>两年大学，SW 经历</li><li>熟悉两种语言和应用程序</li><li>邋遢，呆板，凌驾于头脑中，管理不善</li></ul></li></ul></li></ol><h2 id="6-6-软件发展过程"><a href="#6-6-软件发展过程" class="headerlink" title="6.6. 软件发展过程"></a>6.6. 软件发展过程</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/9.png"></p><ol><li>瀑布模型</li><li>每个阶段做至少两次</li></ol><h2 id="6-7-瀑布模型的问题"><a href="#6-7-瀑布模型的问题" class="headerlink" title="6.7. 瀑布模型的问题"></a>6.7. 瀑布模型的问题</h2><ol><li>对连续里程碑的过度字面解释<ul><li>原型设计是在关键设计评审之前进行编码</li><li>与用户密集型系统不匹配</li></ul></li><li>难以审查和维护的重量级文档<ul><li>7年项目，需求变化318%</li><li>已通过但未验证的里程碑</li></ul></li><li>与COTS、重用、遗留软件不匹配：自下而上与自上而下的流程</li><li>可扩展性、周期时间和过时 <ul><li>Months &#x3D; $5 * \sqrt[3]{KSLOC}$ for sequential development</li><li>3000 KSLOC &#x3D;&gt; 5*14.4 &#x3D; 72 months : 4 computer generations</li></ul></li></ol><h2 id="6-8-软件与硬件成本代价变换"><a href="#6-8-软件与硬件成本代价变换" class="headerlink" title="6.8. 软件与硬件成本代价变换"></a>6.8. 软件与硬件成本代价变换</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/11.png"></p><h2 id="6-9-时间与修复代价的问题"><a href="#6-9-时间与修复代价的问题" class="headerlink" title="6.9. 时间与修复代价的问题"></a>6.9. 时间与修复代价的问题</h2><p>越早发现，修复成本越低</p><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/12.png"></p><h2 id="6-10-量化方法"><a href="#6-10-量化方法" class="headerlink" title="6.10. 量化方法"></a>6.10. 量化方法</h2><ol><li>软件生产效率数据：最好程序员可以是最差程序员的26倍</li><li>按阶段和类型划分的软件缺陷</li><li>复杂性度量</li><li>软件质量</li><li>成本和进度估算</li></ol><h2 id="6-11-总结"><a href="#6-11-总结" class="headerlink" title="6.11. 总结"></a>6.11. 总结</h2><ol><li>软件产品</li><li>商业微型计算机</li><li>结构化编程语言</li><li>结构化方法</li><li>瀑布模型</li><li>形式化模型</li><li>量化方法</li></ol><h1 id="7-年代-1980s：生产力，面向对象，重用，软件过程模型"><a href="#7-年代-1980s：生产力，面向对象，重用，软件过程模型" class="headerlink" title="7. 年代:1980s：生产力，面向对象，重用，软件过程模型"></a>7. 年代:1980s：生产力，面向对象，重用，软件过程模型</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/13.png"></p><ol><li>个人消费者市场的应用</li><li>面向对象</li><li>个人计算机 图形界面</li></ol><h2 id="7-1-过程"><a href="#7-1-过程" class="headerlink" title="7.1. 过程"></a>7.1. 过程</h2><ol><li>虚拟计算机<ul><li>个人计算机</li><li>更好的编译器</li><li>图形化界面编程环境</li><li>存储器</li></ul></li><li>抽象软件实体<ul><li>图形界面</li><li>面向对象编程语言</li></ul></li></ol><h2 id="7-2-应用"><a href="#7-2-应用" class="headerlink" title="7.2. 应用"></a>7.2. 应用</h2><ol><li>成指数型增长<ul><li>软件复杂度</li><li>个人消费市场规模</li></ul></li><li>全世界对生产力、竞争力的关注</li><li>日本的例子：将部分其他产业的方法引入到软件行业，丰田</li></ol><h2 id="7-3-软件发展方法-现代结构化分析和设计"><a href="#7-3-软件发展方法-现代结构化分析和设计" class="headerlink" title="7.3. 软件发展方法 现代结构化分析和设计"></a>7.3. 软件发展方法 现代结构化分析和设计</h2><ol><li><ul><li>更多的结构化方法</li><li>分析和设计的同时思考</li></ul></li><li>面向对象分析和设计</li><li>软件重用</li></ol><h3 id="7-3-1-现代结构化分析和设计"><a href="#7-3-1-现代结构化分析和设计" class="headerlink" title="7.3.1. 现代结构化分析和设计"></a>7.3.1. 现代结构化分析和设计</h3><ol><li>1970s中后期基于结构化编程建⽴了早期的结构化⽅法，包括结构化分析与结构化设计：更多地还在关注于软件程序的构建。</li><li>到了1980s，⼈们逐步开始将结构化分析与设计的关注点转向问题解决和系统构建，产⽣了现代结构化⽅法<ul><li>信息工程(Information Engineering)[Martin1981]、JSD(Jackson System Development)[Jackson1983]、SSADM(Structured systems analysis and design method )、SADT( Structure Analysis and Design Technique)[Marca1987]和现代结构化分析(Modern Structured Analysis)[Yourdon1989]。</li></ul></li></ol><ul><li>更注重系统构建⽽不是程序构建，所以更重视问题分析、需求规格和系统总体结构组织⽽不是让分析与设计结果符合结构化程序设计理论，更重视阶段递进的系统化开发过程，⽽不是⼀切围绕最后的编程进⾏。</li></ul><h3 id="7-3-2-面向对象编程"><a href="#7-3-2-面向对象编程" class="headerlink" title="7.3.2. 面向对象编程"></a>7.3.2. 面向对象编程</h3><ol><li>最早的面向对象编程思想可追溯到1960s的Simular-67语⾔[Nygaard1978]：使用了类、对象、协作、继承、多态(子类型)等最基础的⾯向对象概念。</li><li>1970s的Smalltalk[Kay1993]就是完全基于面向对象思想的程序设计语⾔：它强化了⼀切皆是对象和对象封装的思想，发展了继承和多态。</li><li>到了1980s中后期，随着C++的出现和⼴泛应用，面向对象编程成为程序设计的主流。C++只是在C语⾔中加⼊面向对象的特征，并不是纯粹的⾯向对象语⾔。</li><li>面向对象特性 <ul><li>⾯向对象本身不像结构化⼀样有基于数学的程序设计理论的⽀撑</li><li>[Booch1997]认为模块化、信息隐藏等设计思想和数据库模型的进步都是促使⾯向对象概念演进的重要因素。</li><li>与结构化⽅法相⽐，⾯向对象⽅法中的结构和关系(类、对象、⽅法、继承)能够为领域应用提供更加自然的⽀持，使得软件的复用性和可修改性更加强⼤。</li><li>可复用性满⾜了1980s追求⽣产⼒的要求，尤其是提⾼了GUI编程的⽣产⼒，这也是推动⾯向对象编程发展的重要动⼒[Graham2001]。</li></ul></li></ol><h3 id="7-3-3-结构化编程-和-面向对象编程-对比"><a href="#7-3-3-结构化编程-和-面向对象编程-对比" class="headerlink" title="7.3.3. 结构化编程 和 面向对象编程 对比"></a>7.3.3. 结构化编程 和 面向对象编程 对比</h3><ol><li>结构化<ul><li>学术化</li><li>严谨，充足的数学⽀持</li></ul></li><li>⾯向对象<ul><li>商业化</li><li>原则的必要性，流派的复杂化<ul><li>相当数量的程序员使用⾯向对象的语⾔写着过程式的程序</li><li>⾯向对象是个好东⻄，但是只有专家级程序员才能用好它</li></ul></li></ul></li><li>⼯业界与学术界的鸿沟</li></ol><h3 id="7-3-4-重用和面向对象"><a href="#7-3-4-重用和面向对象" class="headerlink" title="7.3.4. 重用和面向对象"></a>7.3.4. 重用和面向对象</h3><ol><li>1950’s: Math routines, utilities</li><li>1960’s: McIlroy component marketplace, Simula – 67</li><li>1970’s: Abstract data types, Parnas program families</li><li>1980’s: Smalltalk, Eiffel, C++, OO methods, reuse libraries</li><li>1990’s: Domain engineering, product lines, UML, pub-sub architectures</li><li>2000’s: Model driven development, service oriented architectures</li></ol><h3 id="7-3-5-软件重用"><a href="#7-3-5-软件重用" class="headerlink" title="7.3.5. 软件重用"></a>7.3.5. 软件重用</h3><ol><li>面向对象</li><li>第4代语言</li><li>购买商用组件</li><li>程序产⽣器(自动化编程)</li></ol><h2 id="7-4-Software-Process-软件过程"><a href="#7-4-Software-Process-软件过程" class="headerlink" title="7.4. Software Process 软件过程"></a>7.4. Software Process 软件过程</h2><ol><li>过程模型<ul><li>原型[Budde1984]</li><li>渐进交付[Basili1975]</li><li>演化式开发[Gilb1981]</li><li>螺旋[Boehm1988]</li></ul></li><li>过程评价:很重要<ul><li>CMU SEI(卡内基梅隆大学软件研究所)建⽴了软件能⼒成熟度模型 <strong>SW-CMM</strong>[Humphrey1988]，它通过评价<strong>企业的开发过程管理来反映企业的生产能力</strong>。</li><li>国际标准化机构也完成⼀个类似的软件过程评价标准ISO-9001。</li></ul></li><li>使用⼯具支持过程<ul><li>计算机辅助软件⼯程(CASE)</li></ul></li></ol><h2 id="7-5-没有银弹"><a href="#7-5-没有银弹" class="headerlink" title="7.5. 没有银弹"></a>7.5. 没有银弹</h2><ol><li>Frederick P. Brooks经过分析后认为，软件开发的根本困难在于软件产品的内在特性，它们是⽆法回避的，也不是可以轻易解决的，没有技术能够起到银弹的作用 ——没有银弹。</li><li>布鲁克斯提出了主要的挑战<ul><li>很棒的设计者</li><li>快速原型法</li><li>快速迭代式开发</li><li>在工作中避免重用</li></ul></li></ol><h2 id="7-6-人"><a href="#7-6-人" class="headerlink" title="7.6. 人"></a>7.6. 人</h2><ol><li>最终要的因素<ul><li>软件工程是依赖于人、为了人。</li></ul></li><li>1970’s: 温伯格计算机编程心理学</li><li>1980’s: 《人件》</li><li>1990’s – 2000’s: 在敏捷和CMM文化中强调的重要性<ul><li>流程和工具上的个人和交互</li><li>人员CMM，个人软件过程，团队软件过程</li></ul></li></ol><h2 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7. 总结"></a>7.7. 总结</h2><ol><li>生产力</li><li>个人消费</li><li>个人计算机</li><li>图像界面</li><li>现代化结构化方法</li><li>面向对象</li><li>重用</li><li>软件过程</li><li>没有银弹</li><li>人力成本</li></ol><h1 id="8-年代-1990s：局域网，软件架构，RUP，过程改进"><a href="#8-年代-1990s：局域网，软件架构，RUP，过程改进" class="headerlink" title="8. 年代:1990s：局域网，软件架构，RUP，过程改进"></a>8. 年代:1990s：局域网，软件架构，RUP，过程改进</h1><p>解决信息孤岛问题，，，，，，，，，，，，，</p><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/14.png"></p><ol><li>Web Application 网络应用</li><li>Intranet 软局域网</li><li>Software Architecture 软件框架</li><li>RUP</li></ol><h2 id="8-1-Progress"><a href="#8-1-Progress" class="headerlink" title="8.1. Progress"></a>8.1. Progress</h2><ol><li>虚拟计算机<ul><li>局域网</li><li>中间件</li></ul></li><li>抽象软件实体<ul><li>软件结构</li><li>Java</li><li>ISBSG国际软件基准组织</li></ul></li></ol><h2 id="8-2-企业为中心"><a href="#8-2-企业为中心" class="headerlink" title="8.2. 企业为中心"></a>8.2. 企业为中心</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/15.png"></p><ol><li>整合以前建⽴的各个”应用孤岛”，实现对整个企业业务的全⾯整体化管理</li><li>以局域⽹为基础的软件系统可以覆盖企业的所有重要部⻔、重要⼈员和重要⼯作，实现它们之间的有效协同，从根本上提⾼企业的业务能⼒，价值和复杂度上都⽐孤⽴应用有着质的提⾼。</li></ol><h2 id="8-3-大规模软件系统"><a href="#8-3-大规模软件系统" class="headerlink" title="8.3. 大规模软件系统"></a>8.3. 大规模软件系统</h2><ol><li>复杂度：1990s的⼀个发展主题就是建⽴能够开发⼤规模软件系统的⽅法与技术。</li><li>可修改性：1990s出现了对软件可变更性的持续追求，这种态势延续⾄今。</li><li>开发周期：⼈们必须解决⼤规模软件系统开发周期过⻓的问题，并在1990s中后期提出了市场驱动开发(Market Driven Development)的⼝号</li><li>用户价值：从1990s后期开始，⼈们认识到了用户价值的重要性，并持续探索⾄今，⼈机交互、涉众分析等很多新的⽅法与技术都是为了提⾼软件产品的用户价值⽽提出来的。</li></ol><h2 id="8-4-软件发展方法"><a href="#8-4-软件发展方法" class="headerlink" title="8.4. 软件发展方法"></a>8.4. 软件发展方法</h2><ol><li>面向对象</li><li>软件架构</li><li>人机交互</li><li>需求工程</li><li>基于大规模软件开发方法重用</li><li>网络应用开发方法</li></ol><h2 id="8-5-面向对象思想"><a href="#8-5-面向对象思想" class="headerlink" title="8.5. 面向对象思想"></a>8.5. 面向对象思想</h2><ol><li>出现了OMT[Rumbaugh1991]、Booch⽅法[Booch1997]、<br>OOSE[Jacobson1992]、CRC卡[Beck1989,Wirfs-Brock1990]等⼀系列⾯向对象的分析与设计⽅法。</li><li>⼀个统⼀的面向对象建模语⾔UML[UML]被建⽴和传播。<ul><li>对于开发的系统绘制的UML 第四层（图）</li><li>UML的图例语法等 第三层（图例）</li><li>描述UML的模型 第二层</li><li>模型的模型 第一层</li></ul></li><li>设计模式[Gamma1995]、⾯向对象设计原则[Martin2002]等有效的⾯向对象实践经验被⼴泛的传播和应用。</li></ol><h2 id="8-6-软件体系架构"><a href="#8-6-软件体系架构" class="headerlink" title="8.6. 软件体系架构"></a>8.6. 软件体系架构</h2><ol><li>上世纪70年代开发复杂软件系统的初步尝试[Brooks1975]使得⼈们明确和发展了独立的软件设计体系，提出了模块化、信息隐藏等最为基础的设计思想。</li><li>到了随后的80年代中期，这些思想逐⼀⾛向成熟，并且成功融⼊了软件开发过程。这时，⼀些新的探索就出现了，其中包括⾯向对象设计，也包括针对⼤规模软件系统设计的⼀些总结与思考</li><li>于是，研究者们[Perry1992, Garlan1993]在1990s初期正式提出了”软件体系结构”这⼀主题，并结合上世纪90年代之后出现的软件系统规模⽇益扩⼤的趋势，在其后的⼗年中对其进⾏了深⼊的探索与研究。</li><li>⼈们在体系结构的基本内涵、⻛格、描述、设计、评价等⽅⾯开展了卓有成效的⼯作，在2000s初建⽴了⼀个⽐较系统的软件体系结构⽅法体系[Kruchten2006, Shaw2006]。</li></ol><h2 id="8-7-两种复用的模式"><a href="#8-7-两种复用的模式" class="headerlink" title="8.7. 两种复用的模式"></a>8.7. 两种复用的模式</h2><ol><li><strong>框架</strong>：是领域特定的复用技术。它的基本思想是根据应用领域的共性和差异性特点，建⽴一个灵活的体系结构，并实现其中⽐较固定的部分，留下变化的部分等待开发者补充。</li><li><strong>构件</strong>：是在代码实现层次上进⾏复用的技术。它的基本思想是给所有的构件定义⼀个接⼝标准，就像机械工程定义螺丝和螺⺟的标准规格⼀样，这样就可以忽略每个构件内部的因素实现不同构件之间的通信和交互。COM和JavaBean就是1990s产⽣并流⾏起来的构件标准。</li></ol><h2 id="8-8-网络开发发展方法"><a href="#8-8-网络开发发展方法" class="headerlink" title="8.8. 网络开发发展方法"></a>8.8. 网络开发发展方法</h2><ol><li>在1990s早期，⼈们主要使用HTML开发静态的Web站点。</li><li>到了1990s中后期，ASP、JSP、PHP、JavaScript等动态Web开发技术开始流⾏。</li><li>在1990s后期，⼈们建⽴了Web程序的数据描述标准XML。</li></ol><h2 id="8-9-Software-process"><a href="#8-9-Software-process" class="headerlink" title="8.9. Software process"></a>8.9. Software process</h2><ol><li>过程模型 <ul><li>RUP</li><li>Agile</li><li>产品线</li></ul></li><li>过程改进：CMMI</li><li>开源软件, 遗留软件，商用货架产品(COTS)</li><li>反向工程</li><li>风险驱动的并行工程：带锚点的双赢螺旋；合理的统一过程</li><li>RUP:<ul><li>颜色代表本阶段做的多少</li><li>分为四个阶段</li></ul></li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/16.png"></p><h2 id="8-10-开源"><a href="#8-10-开源" class="headerlink" title="8.10. 开源"></a>8.10. 开源</h2><ol><li>开源<ul><li>来源于黑客文化<ul><li>集体代码所有权</li><li>免费的软件，数据，计算介质</li></ul></li><li>免费软件</li><li>Linux</li><li>Raymond’s “The Cathedral and the Bazaar”</li></ul></li><li>组件和COTS是它们的未来</li></ol><h2 id="8-11-总结"><a href="#8-11-总结" class="headerlink" title="8.11. 总结"></a>8.11. 总结</h2><ol><li>企业为中心，避免信息孤岛</li><li>大规模软件系统</li><li>Web</li><li>软件结构</li><li>特定领域方法</li><li>产品先重用</li><li>并行驱动、风险驱动过程：RUP</li><li>CMMI</li></ol><h1 id="9-年代-00s：互联网、敏捷、混合敏捷和计划驱动"><a href="#9-年代-00s：互联网、敏捷、混合敏捷和计划驱动" class="headerlink" title="9. 年代:00s：互联网、敏捷、混合敏捷和计划驱动"></a>9. 年代:00s：互联网、敏捷、混合敏捷和计划驱动</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/17.png"></p><ol><li>Internet</li><li>Agile 敏捷</li></ol><h2 id="9-1-过程"><a href="#9-1-过程" class="headerlink" title="9.1. 过程"></a>9.1. 过程</h2><ol><li>虚拟计算机<ul><li>互联网</li><li>嵌入式设备</li><li>.Net, J2EE, 网络设备</li><li>Linux, WinCE, iOS, Android 移动设备</li><li>团队协作开发环境</li></ul></li><li>抽象软件实体<ul><li>UML 2.0</li><li>模型驱动的开发和面向服务的体系结构</li><li>混合敏捷和计划驱动的产品和过程架构</li><li>用快速、不可预知的变化封装零件</li><li>按规范并行构建、V&amp;V、敏捷再选择</li></ul></li></ol><h2 id="9-2-以用户为中心的应用"><a href="#9-2-以用户为中心的应用" class="headerlink" title="9.2. 以用户为中心的应用"></a>9.2. 以用户为中心的应用</h2><ol><li>网络应用</li><li>大众消费者</li><li>提高系统工程和软件工程的集成度：”软系统工程”的发展趋势</li><li>越来越关注可用性和价值：使软件和硬件适合人们，而不是相反</li><li>紧急需求与预定需求</li></ol><h2 id="9-3-软件发展方法"><a href="#9-3-软件发展方法" class="headerlink" title="9.3. 软件发展方法"></a>9.3. 软件发展方法</h2><ol><li>延续1990s的技术进展<ul><li>集成系统与软件工程</li><li>混合敏捷、计划驱动方法</li><li>面向服务的体系结构，模型驱动的开发</li></ul></li><li>Web技术发展</li><li>领域特定的软件工程方法<ul><li>以⽹络为中⼼的系统；</li><li>信息系统；</li><li>⾦融和电⼦商务系统；</li><li>⾼可信系统；</li><li>嵌⼊式和实时系统；</li><li>多媒体、游戏和娱乐系统；</li><li>⼩型移动平台系统。</li></ul></li></ol><h2 id="9-4-软件过程"><a href="#9-4-软件过程" class="headerlink" title="9.4. 软件过程"></a>9.4. 软件过程</h2><ol><li>敏捷</li><li>平衡</li></ol><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/18.png"></p><ol><li>上图中的部分度量<ol><li>人员多少</li><li>企业文化</li><li>需求变更的情况</li></ol></li><li>越偏向中心，越敏捷</li></ol><h2 id="9-5-SE-从商业到个人"><a href="#9-5-SE-从商业到个人" class="headerlink" title="9.5. SE: 从商业到个人"></a>9.5. SE: 从商业到个人</h2><ol><li>知识体系</li><li>认可大学教育</li></ol><h2 id="9-6-总结"><a href="#9-6-总结" class="headerlink" title="9.6. 总结"></a>9.6. 总结</h2><ol><li>大规模网络应用</li><li>大众消费应用</li><li>领域特定软件工程</li><li>敏捷</li></ol><h1 id="10-年代-2010s-Big-data-amp-AI"><a href="#10-年代-2010s-Big-data-amp-AI" class="headerlink" title="10. 年代:2010s - Big data &amp; AI"></a>10. 年代:2010s - Big data &amp; AI</h1><ol><li>云:云已经开始落地，并且效果很好</li><li>众包</li><li>Facebook,twiter,wechat,tiktok</li><li>Big data</li><li>AI</li><li>可穿戴式设备</li></ol><h2 id="10-1-Barry-Bohem’s-view"><a href="#10-1-Barry-Bohem’s-view" class="headerlink" title="10.1. Barry Bohem’s view"></a>10.1. Barry Bohem’s view</h2><ol><li>八大惊喜潮流<ol><li>增加SysE和SwE的集成</li><li>用户&#x2F;价值焦点</li><li>软件关键性和可靠性</li><li>快速，持续变更</li><li>分布，移动性，互操作性，全球化</li><li>开源、重用、遗留集成</li><li>计算量</li></ol></li><li>两种发展趋势<ul><li>原子软件</li><li>生物和计算机结合</li></ul></li></ol><h2 id="10-2-软件工程有可能的改进"><a href="#10-2-软件工程有可能的改进" class="headerlink" title="10.2. 软件工程有可能的改进"></a>10.2. 软件工程有可能的改进</h2><ol><li>软件⽣产⼒和质量度量不精确</li><li>存储认证可重用组件需要成为主流</li><li>质量控制不稳定</li><li>变更控制也做的不好</li><li>项⽬估算也有待提⾼</li><li>软件安全⼀直在警戒⽔平以下</li><li>软件⼯程需要发放执照和职业资格认证的真正职业</li><li>⾮功能性需求的新型度量⽅法</li><li>遗留软件的维护</li></ol><h2 id="10-3-最近的软件工程概念"><a href="#10-3-最近的软件工程概念" class="headerlink" title="10.3. 最近的软件工程概念"></a>10.3. 最近的软件工程概念</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/19.png"></p><ol><li>开发运维一体化</li><li>微服务</li><li>CI&#x2F;CD:持续开发，持续集成</li><li>容器开发</li></ol><h2 id="10-4-开发过程"><a href="#10-4-开发过程" class="headerlink" title="10.4. 开发过程"></a>10.4. 开发过程</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/20.png"></p><h2 id="10-5-服务网格"><a href="#10-5-服务网格" class="headerlink" title="10.5. 服务网格"></a>10.5. 服务网格</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/21.png"></p><ol><li>一个结点，A服务和B服务，有控制面板控制所有的服务，将所有的服务集成起来，让开发人员更关注于绿色部分</li><li>蓝色部分:sidecar(边车)，负责处理服务以外的建立的联系</li></ol><h2 id="10-6-持续软件工程"><a href="#10-6-持续软件工程" class="headerlink" title="10.6. 持续软件工程"></a>10.6. 持续软件工程</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/22.png"></p><ol><li>将商业策略和开发运维结合</li><li>中台设计:将业务和架构结合</li></ol><h2 id="10-7-混沌工程"><a href="#10-7-混沌工程" class="headerlink" title="10.7. 混沌工程"></a>10.7. 混沌工程</h2><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/23.png"></p><ol><li>比如在一个系统中出现问题(如何在双11之前确保双11不会出现问题)：如何保证在真实的需求下也是充足的。</li><li>最小化爆炸半径:在生产环境中，随机在一些局部给系统一个爆炸，来确定具体的状况。</li></ol><h1 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h1><p><img src="/2023/03/30/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec2/24.png"></p><ol><li>From the 1950’s<ul><li><code>+</code> 不要忽略科学</li><li><code>+</code> 三思而后行(避免过早的承诺)</li><li><code>-</code> 避免不连续的顺序过程</li></ul></li><li>From the 1960’s<ul><li><code>+</code> 跳出框框思考</li><li><code>+</code> 尊重软件的差异</li><li><code>-</code> 避免牛仔编程</li></ul></li><li>From the 1970’s<ul><li><code>+</code> 更早处理错误</li><li><code>+</code> 确定系统布标</li><li><code>-</code> 避免自上而下的发展还原论</li></ul></li><li>From the 1980’s<ul><li><code>+</code> 提高生产力的途径有很多</li><li><code>+</code> 对产品有益的东西对工艺有益</li><li><code>-</code> 对银弹持怀疑态度</li></ul></li><li>From the 1990’s<ul><li><code>+</code> 时间就是金钱，对人很重要</li><li><code>+</code> 对人来说软件要实用</li><li><code>-</code> 快速，但是不要急躁</li></ul></li><li>From the 2000’s<ul><li><code>+</code> 如果变化很快，适应性胜过可重复性</li><li><code>+</code> 考虑并满足所有利益相关者的价值主张</li><li><code>-</code> 避免爱上你的口号(雅格尼)</li></ul></li><li>For the 2010’s<ul><li><code>+</code> 把手放在手边</li><li><code>+</code> 有生存策略</li><li><code>-</code> 要什么都相信<ul><li><code>-</code> 不要完全相信互联网</li></ul></li></ul></li></ol><h1 id="12-软件工程教育的未来挑战-2050年代的学生生涯"><a href="#12-软件工程教育的未来挑战-2050年代的学生生涯" class="headerlink" title="12. 软件工程教育的未来挑战-2050年代的学生生涯"></a>12. 软件工程教育的未来挑战-2050年代的学生生涯</h1><ol><li>不断更新课件</li><li>预测未来趋势并为学生做好准备</li><li>将永恒的原则与老化实践分离</li><li>使小型学生项目与大型行业实践相关 </li><li>参与研究；将结果纳入课程</li><li>帮助学生学会学习</li><li>为从业者提供终身学习</li></ol><h1 id="13-从1950s—2000s之间的特点-简答"><a href="#13-从1950s—2000s之间的特点-简答" class="headerlink" title="13. 从1950s—2000s之间的特点(简答)"></a>13. 从1950s—2000s之间的特点(简答)</h1><ol><li>1950s：科学计算；以机器为中心进行编程；像生产硬件一样生产软件。</li><li>1960s：业务应用(批量数据处理和事物计算)；软件不同于硬件；用软件工艺的方式生产软件。</li><li>1970s：结构化方法；瀑布模型；强调规则和纪律。它们奠定了软件工程的基础，是后续年代软件工程发展的支撑。</li><li>1980s：追求生产力最大化；现代结构化方法&#x2F;面向对象编程广泛应用；重视过程的作用。</li><li>1990s：企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；web应用出现</li><li>2000s：大规模web应用；大量面向大众的web产品；追求快速开发、可变更性、用户价值和创新。</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.存储管理</title>
    <link href="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/"/>
    <url>/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/</url>
    
    <content type="html"><![CDATA[<h2 id="Lecture3-存储管理"><a href="#Lecture3-存储管理" class="headerlink" title="Lecture3-存储管理"></a>Lecture3-存储管理</h2><ol><li>存储管理是操作系统的重要组成部分，负责管理计算机系统的重要资源——内存储器。</li><li>内存空间一般分为两部分<ol><li>系统区：存放操作系统内核程序和数据结构等。</li><li>用户区：存放应用程序和数据。</li></ol></li><li>存储管理包括以下功能：<ol><li>存储分配：位进程分配内存空间以便运行，完成内存区的分配和去配工作。</li><li>地址映射：内存被抽象为一维或二维地址空间；逻辑空间到物理空间映射。</li><li>存储保护：系统隔离分配给进程的内存区，防止地址越界或操作越权。</li><li>存储共享：系统允许多个进程共享内存区。</li><li>存储扩充：形成虚拟存储器。</li></ol></li></ol><h1 id="1-存储管理的基础"><a href="#1-存储管理的基础" class="headerlink" title="1. 存储管理的基础"></a>1. 存储管理的基础</h1><h2 id="1-1-逻辑地址"><a href="#1-1-逻辑地址" class="headerlink" title="1.1. 逻辑地址"></a>1.1. 逻辑地址</h2><ol><li>逻辑地址：又称相对地址，即用户编程所使用的地址空间</li><li>逻辑地址从零开始编号，有两种形式：<ol><li>一维逻辑地址(地址)</li><li>二维逻辑地址(段号:段内地址)<br>。</li></ol></li></ol><h2 id="1-2-物理地址：从处理器角度看到的物理内存单元。"><a href="#1-2-物理地址：从处理器角度看到的物理内存单元。" class="headerlink" title="1.2. 物理地址：从处理器角度看到的物理内存单元。"></a>1.2. 物理地址：从处理器角度看到的物理内存单元。</h2><ol><li>物理地址：又称绝对地址，即程序执行所使用的地址空间</li><li>处理器执行指令时按照物理地址进行</li></ol><h2 id="1-3-段式程序设计"><a href="#1-3-段式程序设计" class="headerlink" title="1.3. 段式程序设计"></a>1.3. 段式程序设计</h2><ol><li>把一个程序设计成多个段：代码段、数据段、堆栈段等等</li><li>用户可以自己应用<strong>段覆盖技术</strong>扩充内存空间使用量，这一技术是程序设计技术，不是OS存储管理的功能：只是用一些段构成一个比较小的程序，然后动态来调整。</li><li>结合虚存完成内存部分的扩充</li></ol><h2 id="1-4-主存储器的复用"><a href="#1-4-主存储器的复用" class="headerlink" title="1.4. 主存储器的复用"></a>1.4. 主存储器的复用</h2><ol><li>多道程序设计需要复用主存</li><li>按照分区复用：<ol><li>主存划分为多个固定&#x2F;可变尺寸的分区</li><li>一个程序&#x2F;程序段占用一个分区</li></ol></li><li>按照页架复用：<ol><li>主存划分成多个固定大小的页架</li><li>一个程序&#x2F;程序段占用多个页架</li></ol></li></ol><h2 id="1-5-存储管理的基本模式"><a href="#1-5-存储管理的基本模式" class="headerlink" title="1.5. 存储管理的基本模式"></a>1.5. 存储管理的基本模式</h2><ol><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定分区或可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li><li>注意是否可以虚拟化</li></ol><h2 id="1-6-存储管理模式示意图"><a href="#1-6-存储管理模式示意图" class="headerlink" title="1.6. 存储管理模式示意图"></a>1.6. 存储管理模式示意图</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/1.png"></p><ol><li>应用级程序员直接面对的是<strong>逻辑地址</strong>，而最后运行需要使用的是<strong>物理地址：从处理器角度看到的物理内存单元。</strong>。</li><li>一般目前常用的是<strong>动态重定位</strong>，将逻辑地址转换为对应的物理地址。</li><li>分页：形成页框加载程序，页框和页框之间可以是不连续的。</li><li>分段：每一个段有相应分区，使用段表完成逻辑段向物理段的映射</li><li>段页式：在分段基础上，还实现了页框部分。</li></ol><h1 id="2-存储管理的功能"><a href="#2-存储管理的功能" class="headerlink" title="2. 存储管理的功能"></a>2. 存储管理的功能</h1><h2 id="2-1-地址转换"><a href="#2-1-地址转换" class="headerlink" title="2.1. 地址转换"></a>2.1. 地址转换</h2><ol><li><strong>地址转换</strong>：又称重定位，即把逻辑地址转换成绝对地址<ol><li><strong>静态重定位</strong>：在<strong>程序装入内存</strong>时进行地址转换：由装入程序执行，早期小型OS使用，基于地址固定值进行偏移。</li><li><strong>动态重地位(主流)<strong>：在</strong>CPU执行程序时进行地址转换</strong>：从效率出发，依赖硬件地址转换机构，运行时正确的将其逻辑地址转换为物理地址。</li></ol></li><li>解释执行指令的时候才进行地址的转换，必须要借助硬件电路完成，而不能用软件完成(效率考量)</li></ol><h2 id="2-2-存储保护"><a href="#2-2-存储保护" class="headerlink" title="2.2. 存储保护"></a>2.2. 存储保护</h2><ol><li>为<strong>避免</strong>主存中的多个进程<strong>相互干扰</strong>，必须<strong>对主存中的程序和数据进行保护</strong><ol><li>私有主存区中的信息：可读可写</li><li>公共区中的共享信息：根据授权</li><li>非本进程信息：不可读写</li></ol></li><li>这一功能需要软硬件协同完成：CPU检查是否允许访问，不允许则<strong>产生地址保护异常</strong>，由OS进行相应处理<ol><li>地址越界保护依赖于硬件设施、常用的有界地址和存储键。</li><li>进程在访问分配给自己的内存区时，要对访问权限进行检查</li></ol></li></ol><h2 id="2-3-主存储器空间的分配与去配"><a href="#2-3-主存储器空间的分配与去配" class="headerlink" title="2.3. 主存储器空间的分配与去配"></a>2.3. 主存储器空间的分配与去配</h2><ol><li><strong>分配</strong>：进程装入主存时，存储管理软件进行具体的<strong>主存分配</strong>操作，并设置<strong>一个表格</strong>记录主存空间的分配情况</li><li><strong>去配</strong>：当某个进程撤离或主动归还主存资源时，存储管理软件要收回它所占用的全部或者部分存储空间，调整主存分配表信息</li></ol><h2 id="2-4-主存储器空间的共享"><a href="#2-4-主存储器空间的共享" class="headerlink" title="2.4. 主存储器空间的共享"></a>2.4. 主存储器空间的共享</h2><ol><li><strong>多个进程共享主存储器资源</strong>：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li><li><strong>多个进程共享主存储器的某些区域</strong>：若干个协作进程有共同的主存程序块或者主存数据块</li></ol><h2 id="2-5-主存储器空间的扩充"><a href="#2-5-主存储器空间的扩充" class="headerlink" title="2.5. 主存储器空间的扩充"></a>2.5. 主存储器空间的扩充</h2><ol><li><strong>存储扩充</strong>：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存：扩大多道程序设计的道数<ol><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容，对单个进程不使用对换技术完成，特点是自动化、透明</li></ol></li><li>这一工作需要软硬件协作完成<ol><li>对换进程决定对换，硬件结构完成调入</li><li>CPU处理到不在主存的地址，发出<strong>虚拟地址异常</strong>，OS将其调入，重执指令</li></ol></li><li>进程的内存为$4MB$，一个页框$4KB$，有$1024$个页框，页框表一共$16$个页框，页的压缩比是$\frac{1024}{16} &#x3D; 64$。</li></ol><h1 id="3-连续存储管理"><a href="#3-连续存储管理" class="headerlink" title="3. 连续存储管理"></a>3. 连续存储管理</h1><h2 id="3-1-单连续分区存储管理"><a href="#3-1-单连续分区存储管理" class="headerlink" title="3.1. 单连续分区存储管理"></a>3.1. 单连续分区存储管理</h2><ol><li>每个进程占用一个物理上完全连续的存储空间(区域)</li><li>单连续分区存储管理细分:<ol><li>单用户连续存储管理</li><li>固定分区存储管理</li><li>可变分区存储管理</li></ol></li><li>分区方式不能实现虚拟存储。</li></ol><h3 id="3-1-1-单用户连续分区存储管理"><a href="#3-1-1-单用户连续分区存储管理" class="headerlink" title="3.1.1. 单用户连续分区存储管理"></a>3.1.1. 单用户连续分区存储管理</h3><ol><li>适用于单用户单任务操作系统，如DOS</li><li>主存区域(内存空间)划分为<strong>系统区</strong>与<strong>用户区</strong><ol><li>系统区用于存放操作系统内核程序和数据结构等</li><li>用户区用于存放应用程序和数据</li></ol></li><li>设置一个<strong>栅栏寄存器</strong>界分两个区域，硬件用它在执行时进行存储保护</li><li>一般采用<strong>静态重定位</strong>进行地址转换</li><li>硬件实现代价低</li><li>单用户连续分区存储管理示意<ol><li>静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址全部转换成绝对地址</li><li>界限地址:放置软件访问到操作系统的部分</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/6.png"></p><h3 id="3-1-2-固定分区存储管理"><a href="#3-1-2-固定分区存储管理" class="headerlink" title="3.1.2. 固定分区存储管理"></a>3.1.2. 固定分区存储管理</h3><ol><li>固定分区存储管理又称静态分区模式</li></ol><h4 id="3-1-2-1-固定分区方式的基本思想"><a href="#3-1-2-1-固定分区方式的基本思想" class="headerlink" title="3.1.2.1. 固定分区方式的基本思想"></a>3.1.2.1. 固定分区方式的基本思想</h4><ol><li>内存空间被划分为数目固定不变的分区，各分区大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们都可以并发执行。</li><li>可用静态&#x2F;动态重定位、硬件实现代价低、被早期OS采用<br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/7.png"></li></ol><h4 id="3-1-2-2-固定分区方式的主存分配"><a href="#3-1-2-2-固定分区方式的主存分配" class="headerlink" title="3.1.2.2. 固定分区方式的主存分配"></a>3.1.2.2. 固定分区方式的主存分配</h4><ol><li>主存分配表：包含内容：起始地址、长度、占用标志</li><li>内存分配方法很简单，其任务有何时吧内存空间划分成分区：由系统管理员和操作系统初始化模块协同完成。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/8.png"></p><ol start="3"><li>作业进入分区的排队策略：<ol><li>每个分区有自己的作业等待队列，作业等待能装下自身的最小分区。</li><li>所有等待处理作业排成等待队列，每当有空闲，找到队列中能进入的最大的一个。</li></ol></li></ol><h4 id="3-1-2-3-固定分区方式的地址转换"><a href="#3-1-2-3-固定分区方式的地址转换" class="headerlink" title="3.1.2.3. 固定分区方式的地址转换"></a>3.1.2.3. 固定分区方式的地址转换</h4><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/9.png"></p><h4 id="3-1-2-4-固定分区存储管理的缺点"><a href="#3-1-2-4-固定分区存储管理的缺点" class="headerlink" title="3.1.2.4. 固定分区存储管理的缺点"></a>3.1.2.4. 固定分区存储管理的缺点</h4><ol><li>由于预先规定了分区的大小，使得大作业无法装入，而不得不采用覆盖技术，带来负担。</li><li>内存空间利用率不高，作业很少填满分区：固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存<strong>内零头</strong>，有浪费，内存内零头是因为在分区内部有零头。</li><li>如果作业在运行中要求动态扩展内存空间是困难的。</li><li>分区数目是操作系统初启动时确定的，会限制多道运行程序的道数。</li></ol><h2 id="3-2-可变分区存储管理"><a href="#3-2-可变分区存储管理" class="headerlink" title="3.2. 可变分区存储管理"></a>3.2. 可变分区存储管理</h2><ol><li>可变分区存储管理又称动态分区模式，按照作业大小划分分区，但划分的时间、大小和位置都是动态的。</li><li>创建一个进程时，根据进程所需主存量查看主存中是否有足够的连续空闲空间<ol><li>若有，则按需要量分割一个分区</li><li>若无，则令该进程等待主存资源</li></ol></li><li>由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的</li></ol><h3 id="3-2-1-可变分区方式的内存分配示例"><a href="#3-2-1-可变分区方式的内存分配示例" class="headerlink" title="3.2.1. 可变分区方式的内存分配示例"></a>3.2.1. 可变分区方式的内存分配示例</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/10.png"></p><h3 id="3-2-2-可变分区方式的主存分配表"><a href="#3-2-2-可变分区方式的主存分配表" class="headerlink" title="3.2.2. 可变分区方式的主存分配表"></a>3.2.2. 可变分区方式的主存分配表</h3><ol><li>管理的数据结构：已分配区表与未分配区表，采用链表实现</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/11.png"></p><ol start="2"><li>找一个最大的空闲的位置进行分配</li></ol><h3 id="3-2-3-可变分区方式的内存回收"><a href="#3-2-3-可变分区方式的内存回收" class="headerlink" title="3.2.3. 可变分区方式的内存回收"></a>3.2.3. 可变分区方式的内存回收</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/12.png"></p><ol><li>可变分区方式的内存回收会导致内存空间的转换</li><li>作业X撤离后有且仅有如上4种情况。</li></ol><h3 id="3-2-4-可变分区方式的内存分配"><a href="#3-2-4-可变分区方式的内存分配" class="headerlink" title="3.2.4. 可变分区方式的内存分配"></a>3.2.4. 可变分区方式的内存分配</h3><ol><li>最先适应分配算法：<ol><li>最先适应就是从上向下查找，找到第一块区域放进去，将剩下的区域分割后仍作为空闲区。</li><li>有利于大作业装入，但也使得内存低地址和搞地质两端的分区利用不均衡，回收分区麻烦。</li></ol></li><li>邻近适应分配算法：<ol><li>从上次查找结束的地方开始执行最先适应分配算法</li><li>缩短平均查找时间，且存储空间利用率更均衡，不会使得小空闲区集中在内存一侧</li></ol></li><li>最优适应分配算法：<ol><li>每次都是分配最接近需要使用大小的部分，会生成很多很小的内存内零头。</li><li>通常会将空闲区按照长度递增顺序排列，等同于最先适应分配算法，查找时间最长</li></ol></li><li>最坏适应分配算法：<ol><li>每次都是挑选最大的一块区域进行分配</li><li>有利于中小型作业。</li><li>可把空闲区按长度递减顺序排列，等同于最先适应分配算法。</li></ol></li><li>快速适应分配算法：课本补充<ol><li>为经常用到的长度的空闲区设立单独的空闲区链表，查找非常快速</li><li>归还内存空间时和邻近空闲区的合并复杂且耗时。</li></ol></li><li>最常用的是最先适应分配算法，其次是邻近适应分配算法和最优适应分配算法</li></ol><h2 id="3-3-地址转换与存储保护"><a href="#3-3-地址转换与存储保护" class="headerlink" title="3.3. 地址转换与存储保护"></a>3.3. 地址转换与存储保护</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/34.png"></p><ol><li>硬件实现机制与动态重定位</li><li>进程的程序和数据的地址由硬件完成<ol><li>基址寄存器：分配进程的起始地址</li><li>限长寄存器：进程占用的连续存储空间的长度</li></ol></li></ol><h2 id="3-4-分区方式的内存零头"><a href="#3-4-分区方式的内存零头" class="headerlink" title="3.4. 分区方式的内存零头"></a>3.4. 分区方式的内存零头</h2><ol><li>固定分区方式会产生<strong>内存内零头</strong></li><li>可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为<strong>内存外零头</strong>，内存外零头是指分区内部是没有零头的，而是在外面的零头。</li><li><strong>最优适配算法最容易产生外零头</strong></li><li>任何适配算法都<strong>不能避免</strong>产生外零头</li></ol><h2 id="3-5-内存不足的存储技术"><a href="#3-5-内存不足的存储技术" class="headerlink" title="3.5. 内存不足的存储技术"></a>3.5. 内存不足的存储技术</h2><h3 id="3-5-1-移动技术-程序浮动技术"><a href="#3-5-1-移动技术-程序浮动技术" class="headerlink" title="3.5.1. 移动技术(程序浮动技术)"></a>3.5.1. 移动技术(程序浮动技术)</h3><ol><li>碎片：内存中的小空闲区，移动分区来解决内存外零头问题。</li><li>当未分配区表中找不到足够大的空闲区来装入新进程时，我们使用移动技术来完成内存紧凑，实现方法：<ol><li>全部移动到一侧</li><li>移动直到有足够大的空闲区</li></ol></li><li>需要动态重定位支撑:静态重定位无法解决内存外零头</li><li>问题：移动技术有极大的系统开销，而且并不是任何时间下都可以进行的，比如通道或DMA等按照绝对物理地址交换信息时。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/13.png"></p><ol start="5"><li><p>移动技术的工作流程<br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/14.png"></p></li><li><p>注意如果剩余空间地方不足，那么是不会移动分区的</p></li></ol><h3 id="3-5-2-对换技术"><a href="#3-5-2-对换技术" class="headerlink" title="3.5.2. 对换技术"></a>3.5.2. 对换技术</h3><ol><li>对换技术广泛应用于分时系统的调度，用来解决内存容量不足的问题，也可以应用于批处理系统，以平衡系统负载。</li><li>如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用；同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为<strong>对换</strong>。</li><li>被对换出去的进程的状态会调整为就绪态，并且通知存储管理程序，一旦内存可用，立即将该进程对换回内存。</li><li>对换技术关键点<ol><li>被对换进程：通常系统选择时间片耗尽或优先级较低的进程对换出去。</li><li>对换的进程信息：将数据区和堆栈通过文件系统转换为特殊文件保存。</li><li>被对换的时机：<ol><li>批处理系统中：进程需要扩充内存空间但不能被满足时</li><li>分时系统：<ol><li>时间片结束时</li><li>执行I&#x2F;O操作时</li></ol></li></ol></li></ol></li><li>对换需要访问磁盘，是I&#x2F;O集中型操作，但是操作系统可以让计算型任务与对换并行，不会造成系统效率显著下降。</li><li>详见P205</li></ol><h3 id="3-5-3-覆盖技术"><a href="#3-5-3-覆盖技术" class="headerlink" title="3.5.3. 覆盖技术"></a>3.5.3. 覆盖技术</h3><ol><li>移动和对换技术解决因多个程序存在而导致内存区不足问题。</li><li>但是如果程序长度超过物理内存的总和，或者超出固定分区大小，则会出现内存永久性短缺，大程序无法运行，解决方案是覆盖技术。</li><li>覆盖是指程序执行过程中程序的不同模块在内存中相互替代，以达到小内存执行大程序的目的。</li><li>基本的实现技术是把用户空间分成固定区和一个或多个覆盖区，把控制或不可覆盖的部分放到固定区，其余按照调用结构以及先后关系分段并存放在磁盘上，运行时一次调入覆盖区。</li><li>不足是将存储管理工作转给程序员，他们必须根据可用物理内存空间来设计和编写程序。</li></ol><h1 id="4-虚拟存储器的概念"><a href="#4-虚拟存储器的概念" class="headerlink" title="4. 虚拟存储器的概念"></a>4. 虚拟存储器的概念</h1><ol><li>之前所介绍的存储管理，我们称为实存管理，必须为进程分配足够内存空间，装入其全部信息，否则无法运行。</li></ol><h2 id="4-1-虚拟存储器思想的提出"><a href="#4-1-虚拟存储器思想的提出" class="headerlink" title="4.1. 虚拟存储器思想的提出"></a>4.1. 虚拟存储器思想的提出</h2><ol><li>主存容量限制带来诸多不便<ol><li>用户编写程序必须考虑主存容量限制</li><li>多道程序设计的道数受到限制</li></ol></li><li>用户编程行为分析<ol><li>全面考虑各种情况，执行时有互斥性</li><li>顺序性和循环性等空间局部性行为</li><li>某一阶段执行的时间局部性行为</li></ol></li><li>因此可以考虑部分调入进程内容</li></ol><h3 id="4-1-1-分区存储的限制"><a href="#4-1-1-分区存储的限制" class="headerlink" title="4.1.1. 分区存储的限制"></a>4.1.1. 分区存储的限制</h3><ol><li>每个进程(每个连续逻辑地址空间)必须获得物理地址上的完全连续，突破：分区，分段</li><li>必须一次性满足满足每个进程运行时的全部内存需求，突破：虚拟存储，部分装入对换</li><li>注：一旦发生缺页，则会从运行态调整到阻塞态，可能会导致部分进程的速度被拖慢，但是整体效率会提高</li></ol><h3 id="4-1-2-程序运行的局部性原理"><a href="#4-1-2-程序运行的局部性原理" class="headerlink" title="4.1.2. 程序运行的局部性原理"></a>4.1.2. 程序运行的局部性原理</h3><ol><li>在一个周期内，这个进程在运行时会集中访问一些存储区：某存储单元被访问，改单元机器相邻存储单元很可能会被访问(空间局部性)，或者最近访问过的存储单元很快又能被访问(时间局部性)。</li><li>根据程序运行的局部性原理，会保证程序的访问效率比较高，缺页率相对低，以时间换取空间</li></ol><h2 id="4-2-虚拟存储器的基本思想"><a href="#4-2-虚拟存储器的基本思想" class="headerlink" title="4.2. 虚拟存储器的基本思想"></a>4.2. 虚拟存储器的基本思想</h2><ol><li>部分装入：存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为<strong>随用随调入</strong></li><li>按需调出：如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息<strong>调出</strong>到辅存上去</li></ol><h2 id="4-3-虚拟存储器的实现思路"><a href="#4-3-虚拟存储器的实现思路" class="headerlink" title="4.3. 虚拟存储器的实现思路"></a>4.3. 虚拟存储器的实现思路</h2><ol><li>需要建立与自动管理两个地址空间<ol><li>(辅存)<strong>虚拟地址</strong>空间：容纳进程装入</li><li>(主存)<strong>实际地址</strong>空间：承载进程执行</li></ol></li><li>对于用户，计算机系统具有一个容量大得多的主存空间，即<strong>虚拟存储器</strong></li></ol><h2 id="4-4-虚拟存储器"><a href="#4-4-虚拟存储器" class="headerlink" title="4.4. 虚拟存储器"></a>4.4. 虚拟存储器</h2><ol><li>在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理内存容量大得多的、可寻址的内存储器。</li><li>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计<ol><li>逻辑地址：进程角度看到的逻辑内存单元。</li><li>物理地址：从处理器角度看到的物理内存单元。</li></ol></li><li>对换技术以进程为单位，虚存管理以页或段为单位。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/2.png"></p><h1 id="5-存储管理的硬件支撑"><a href="#5-存储管理的硬件支撑" class="headerlink" title="5. 存储管理的硬件支撑"></a>5. 存储管理的硬件支撑</h1><h2 id="5-1-存储器的组织层次"><a href="#5-1-存储器的组织层次" class="headerlink" title="5.1. 存储器的组织层次"></a>5.1. 存储器的组织层次</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/3.png"></p><ol><li>越处于顶端，访问速度越快，容量越小，单位字节价格会越高。我们根据实际情况，选择使用什么样子的存储器。<ol><li><strong>寄存器、缓存和内存</strong>属于操作系统存储管理的范畴，掉电后信息丢失。</li><li><strong>磁盘和磁带</strong>属于稳健管理和设备管理的管辖对象，信息永久保存。</li></ol></li><li>可执行程序必须被保存在<strong>内存</strong>中，与设备交换的信息也依托于<strong>内存地址空间</strong>。</li><li>由于程序处理数据时存在<strong>顺序性和局部性</strong>，故执行时仅需调入当前运行使用的一部分，其他部分待需要时再逐步调入。</li></ol><h2 id="5-2-存储管理涉及的存储对象"><a href="#5-2-存储管理涉及的存储对象" class="headerlink" title="5.2. 存储管理涉及的存储对象"></a>5.2. 存储管理涉及的存储对象</h2><ol><li>存储管理是OS管理主存储器的<strong>软件部分</strong></li><li>为获得更好的处理性能，部分主存程序与数据(特别是关键性能数据)被调入Cache，存储管理需要对其进行管理，甚至包括对联想存储器的管理</li><li>为获得更大的虚拟地址空间，存储管理需要对存放在硬盘、固态硬盘、甚至网络硬盘上的虚拟存储器文件进行管理，首选固态硬盘</li></ol><h2 id="5-3-高速缓存存储器-Cache"><a href="#5-3-高速缓存存储器-Cache" class="headerlink" title="5.3. 高速缓存存储器(Cache)"></a>5.3. 高速缓存存储器(Cache)</h2><ol><li>Cache是介于CPU和主存储器间的高速小容量存储器，由<strong>静态存储芯片SRAM</strong>组成，容量较小但比主存DRAM技术更加昂贵而快速，接近于CPU的速度</li><li>CPU往往需要重复读取同样的数据块，Cache的引入与缓存容量的增大，可以大幅提升CPU内部读取数据的命中率，从而提高系统性能</li></ol><h3 id="5-3-1-高速缓存存储器的构成"><a href="#5-3-1-高速缓存存储器的构成" class="headerlink" title="5.3.1. 高速缓存存储器的构成"></a>5.3.1. 高速缓存存储器的构成</h3><ol><li>高速缓冲存储器通常由<strong>高速存储器、联想存储器、地址转换部件、替换逻辑</strong>等组成<ol><li><strong>联想存储器</strong>：根据内容进行寻址的存储器</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache；未命中时从内存读取放入Cache</li><li>替换逻辑部件：在缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li></ol></li><li>MMU：硬件，存储管理单元</li></ol><h3 id="5-3-2-高速缓存存储器的组织"><a href="#5-3-2-高速缓存存储器的组织" class="headerlink" title="5.3.2. 高速缓存存储器的组织"></a>5.3.2. 高速缓存存储器的组织</h3><ol><li>由于CPU芯片面积和成本，Cache很小</li><li>根据成本控制，划分为L1、L2、L3三级</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/4.png"></p><h3 id="5-3-3-高速缓存存储器的分级"><a href="#5-3-3-高速缓存存储器的分级" class="headerlink" title="5.3.3. 高速缓存存储器的分级"></a>5.3.3. 高速缓存存储器的分级</h3><ol><li>L1 Cache：分为数据缓存和指令缓存；内置；其成本最高，对CPU的性能影响最大；通常在32KB-256KB之间</li><li>L2 Cache：分内置和外置两种，后者性能低一些；通常在512KB-8MB之间</li><li>L3 Cache：多为外置，在游戏和服务器领域有效；但对很多应用来说，<strong>总线改善</strong>比<strong>设置L3</strong>更加有利于提升系统性能</li></ol><h3 id="5-3-4-早期奔腾处理器架构"><a href="#5-3-4-早期奔腾处理器架构" class="headerlink" title="5.3.4. 早期奔腾处理器架构"></a>5.3.4. 早期奔腾处理器架构</h3><ol><li>Intel在最初的奔腾处理器中只包含L1 Cache(含Code Cache和Data Cache)</li></ol><h3 id="5-3-5-奔腾4处理器架构"><a href="#5-3-5-奔腾4处理器架构" class="headerlink" title="5.3.5. 奔腾4处理器架构"></a>5.3.5. 奔腾4处理器架构</h3><ol><li>奔腾4的处理器中包含L1 Cache和L2 Cache</li></ol><h3 id="5-3-6-i5处理器架构"><a href="#5-3-6-i5处理器架构" class="headerlink" title="5.3.6. i5处理器架构"></a>5.3.6. i5处理器架构</h3><h3 id="5-3-7-i7处理器架构"><a href="#5-3-7-i7处理器架构" class="headerlink" title="5.3.7. i7处理器架构"></a>5.3.7. i7处理器架构</h3><ol><li>i7处理器中包含L1至L3三级Cache，如果是包含了三级Cache，那么意味着CPU与Cache之间的链接在CPU内部，Core i7处理器方案是将L3 Cache设计为包含在处理中的多个核心Cache</li></ol><h2 id="5-4-地址转换-x2F-存储保护的硬件支撑"><a href="#5-4-地址转换-x2F-存储保护的硬件支撑" class="headerlink" title="5.4. 地址转换&#x2F;存储保护的硬件支撑"></a>5.4. 地址转换&#x2F;存储保护的硬件支撑</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/5.png"></p><ol><li>限长寄存器来检查越界中断</li><li>相加体现了动态重定位</li><li>比较体现了存储保护</li></ol><h2 id="5-5-存储管理与硬件支撑"><a href="#5-5-存储管理与硬件支撑" class="headerlink" title="5.5. 存储管理与硬件支撑"></a>5.5. 存储管理与硬件支撑</h2><ol><li>鉴于程序执行与数据访问的<strong>局部性原理</strong>，存储管理软件使用<strong>Cache</strong>可以大幅度提升程序执行效率</li><li><strong>动态重定位、存储保护</strong>等，若无硬件支撑在效率上是无意义的，即无实现价值</li><li>无<strong>虚拟地址中断</strong>，虚拟存储器无法实现</li><li>无页面替换等硬件支撑机制，虚拟存储器在效率上是无意义的</li></ol><h2 id="5-6-虚拟存储与硬件支撑"><a href="#5-6-虚拟存储与硬件支撑" class="headerlink" title="5.6. 虚拟存储与硬件支撑"></a>5.6. 虚拟存储与硬件支撑</h2><ol><li>操作系统的存储管理依靠底层硬件支撑来完成任务，该硬件是存储管理部件(Memory Managment Unit, MMU)，提供地址转换和存储保护并支持虚存管理和多任务管理。</li><li>MMU由一组集成电路芯片组成，逻辑地址作为输入，物理地址作为输出，直接送达总线，对内存单元进行寻址。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/86.png"></p><ol start="3"><li>主要功能：P217<ol><li>管理硬件页表基址寄存器</li><li>分解逻辑地址</li><li>管理快表</li><li>访问页表</li><li>发出异常</li><li>管理特征位</li></ol></li></ol><h1 id="6-页式存储管理"><a href="#6-页式存储管理" class="headerlink" title="6. 页式存储管理"></a>6. 页式存储管理</h1><h2 id="6-1-页式存储管理的基本原理"><a href="#6-1-页式存储管理的基本原理" class="headerlink" title="6.1. 页式存储管理的基本原理"></a>6.1. 页式存储管理的基本原理</h2><ol><li>页面：金层逻辑地址空间分成大小相等的区，每个区称为页面或页，页号从0开始编号。比如出版一本书，出版受到页大小影响，最后由若干页组成，一般大小为4KB</li><li>页框：又称页帧，把内存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区都是一个页框(物理块)，块号从0开始。</li><li>逻辑地址：分页存储器的逻辑地址由页号 + 页面偏移组成(地址总线32位)<ol><li>页号：32-12 &#x3D; 20位，则包含页$2^{20}$位</li><li>页面偏移：页面大小为4KB，则需要12位</li></ol></li><li>内存页框表：该表长度取决于内存划分的物理块数，表项中给出物理块使用情况，0为空闲，1为占用，有的系统还会添加保护位、脏位等等。</li><li>页表：将页装入到内存中，<strong>页未必连续</strong>，我们需要为每一个页面设立一个重定向寄存器，这个寄存器的集合就是页表。<ol><li>数学角度：$页面号 \rightarrow 页框号$</li><li>系统设置页表基址寄存器，存放当前运行进程的页表起始地址。</li><li>$物理地址 &#x3D; 页框号 * 块长 + 页内偏移$，实际转换时，我们将页内偏移作为低地址，根据页号从页表中查找到页框号并作为高地址即可。</li><li>页表不存储<strong>页号</strong>，只存储页框号和相应标志位</li></ol></li><li>页式存储产生的碎片是内部碎片<ol><li>可以类比固定分区</li><li>比如19KB的程序，加载到页大小为4KB中，会产生1KB的内存内零头。</li></ol></li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/81.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/15.png"></th></tr></thead></table><blockquote><ol><li>页号p</li><li>页内偏移d</li><li>页框号b</li></ol></blockquote><h2 id="6-2-页式存储管理中的地址"><a href="#6-2-页式存储管理中的地址" class="headerlink" title="6.2. 页式存储管理中的地址"></a>6.2. 页式存储管理中的地址</h2><ol><li>页式存储管理的逻辑地址由两部分组成，**页号和单元号(页内偏移)**，逻辑地址形式：</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/16.png"></p><ol start="2"><li>页式存储管理的物理地址也有两部分组成：**页架号(页框号)和单元号(页内偏移)**，物理地址形式：</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/17.png"></p><ol start="3"><li>地址转换可以通过查页表完成</li><li>用户不必关心页的具体存储，系统帮助用户完成从页号&#x2F;页架号映射到物理地址来完成。</li></ol><h2 id="6-3-页式存储管理的地址转换例子"><a href="#6-3-页式存储管理的地址转换例子" class="headerlink" title="6.3. 页式存储管理的地址转换例子"></a>6.3. 页式存储管理的地址转换例子</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/18.png"></p><ol><li>逻辑地址页号，作为偏移量到页表中进行偏移，得到页架号(页框号)。</li><li>对页架号(页框号)进行二进制移位操作(补充12个0)，映射到物理空间中本页的首地址，然后根据offset(单元号)在页内进行偏移，从而获取到绝对地址(物理地址：从处理器角度看到的物理内存单元)中的值。</li></ol><h2 id="6-4-页式存储管理的内存分配-x2F-去配"><a href="#6-4-页式存储管理的内存分配-x2F-去配" class="headerlink" title="6.4. 页式存储管理的内存分配&#x2F;去配"></a>6.4. 页式存储管理的内存分配&#x2F;去配</h2><ol><li>页式存储管理，系统要建立一张内存物理块表，用来记录页框状态，管理物理内存的而分配，所包含的信息包含内存总块数、哪些为空闲块、哪些已经分配以及分配给哪个进程等。</li><li>最简单方法是用一张<strong>位示图</strong>来记录主存分配情况，使用一位来标记一个页框的使用或空闲的状态(压缩的思想)<ol><li>如果够，则去查找一个标记为0的装入</li><li>如果不够，采用一定的策略</li></ol></li><li>建立进程页表维护主存逻辑完整性</li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/19.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/82.png"></th></tr></thead></table><ol><li>分页存储管理页框分配算法：<ol><li>进行内存分配时，先检查空闲块数是否满足用户进行要求<ol><li>若不能则使进程等待。</li><li>若能则查位示图，将位0置为占用标志，从空闲块数中减去本次占用快熟，找到对应的页框号，写入页表。</li></ol></li><li>归还时逆操作。</li></ol></li></ol><h2 id="6-5-页的共享"><a href="#6-5-页的共享" class="headerlink" title="6.5. 页的共享"></a>6.5. 页的共享</h2><ol><li>页式存储管理能够实现多个进程共享程序和数据</li><li><strong>数据共享</strong>：不同进程可以使用<strong>不同</strong>页号共享数据页，但是必须解决共享信息保护问题，常用的是在页表中添加标记位。</li><li><strong>程序共享</strong>：不同进程必须使用<strong>相同</strong>页号共享代码页，共享代码页中的(<strong>JMP &lt;页内地址&gt;</strong>)指令，使用不同页号是做不到，进程一和二都要跳转到页内的位置，程序共享要求页号相同。</li></ol><h2 id="6-6-页式存储管理的地址转换"><a href="#6-6-页式存储管理的地址转换" class="headerlink" title="6.6. 页式存储管理的地址转换"></a>6.6. 页式存储管理的地址转换</h2><blockquote><p>快表TLB，Translation Look_aside Buffer</p></blockquote><h3 id="6-6-1-页式存储管理的地址转换代价"><a href="#6-6-1-页式存储管理的地址转换代价" class="headerlink" title="6.6.1. 页式存储管理的地址转换代价"></a>6.6.1. 页式存储管理的地址转换代价</h3><ol><li><strong>页表放在主存</strong>: 每次地址转换必须访问两次主存<ol><li>按页号读出页表中的相应页架号</li><li>按计算出来的绝对地址进行读写</li></ol></li><li><strong>存在问题</strong>：降低了存取速度</li><li><strong>解决办法</strong>：利用Cache存放部分页表，即快表</li></ol><h3 id="6-6-2-页式存储管理的快表"><a href="#6-6-2-页式存储管理的快表" class="headerlink" title="6.6.2. 页式存储管理的快表"></a>6.6.2. 页式存储管理的快表</h3><ol><li>为提高地址转换速度，设置一个专用的高速存储器，用来存放页表的一部分</li><li><strong>快表</strong>：存放在高速存储器中的页表部分，快表表项：<strong>页号+页架号</strong></li><li>这种高速存储器是<strong>联想存储器(TLB)<strong>，即</strong>按照内容寻址</strong>，而非按照地址访问，根据页号进行寻址。</li></ol><h3 id="6-6-3-基于快表的地址转换流程"><a href="#6-6-3-基于快表的地址转换流程" class="headerlink" title="6.6.3. 基于快表的地址转换流程"></a>6.6.3. 基于快表的地址转换流程</h3><ol><li>按逻辑地址中的页号查快表<ol><li>若该页<strong>已在快表</strong>中，则由页架号和单元号形成绝对地址</li><li>若该页<strong>不在快表</strong>中，则再查主存页表形成绝对地址，同时将该页登记到快表中</li></ol></li><li>当<strong>快表填满</strong>后，又要登记新页时，则需在快表中按一定策略<strong>淘汰</strong>一个旧登记项</li><li>快表可以理解为一个简单的账本</li></ol><h3 id="6-6-4-引入快表后的地址转换代价"><a href="#6-6-4-引入快表后的地址转换代价" class="headerlink" title="6.6.4. 引入快表后的地址转换代价"></a>6.6.4. 引入快表后的地址转换代价</h3><ol><li>采用<strong>快表</strong>后，可以加快地址转换速度</li><li>假定主存访问时间为200毫微秒，快表访问时间为40毫微秒，查快表的命中率是90%，平均地址转换代价为$(200+40)*90%+(200+200+40)*10%&#x3D;260$毫微秒</li><li>比两次访问主存的时间(400毫微秒)下降了<strong>36%</strong></li></ol><h3 id="6-6-5-多道程序环境下的进程表"><a href="#6-6-5-多道程序环境下的进程表" class="headerlink" title="6.6.5. 多道程序环境下的进程表"></a>6.6.5. 多道程序环境下的进程表</h3><ol><li>进程表中登记了每个进程的页表</li><li>进程占有处理器运行时，其<strong>页表起始地址和长度</strong>送入<strong>页表控制寄存器</strong></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/20.png"></p><blockquote><p>页表长度就是页表项的数量</p></blockquote><h3 id="6-6-6-多道程序环境下的地址转换"><a href="#6-6-6-多道程序环境下的地址转换" class="headerlink" title="6.6.6. 多道程序环境下的地址转换"></a>6.6.6. 多道程序环境下的地址转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/21.png"></p><ol><li>页表控制寄存器存储了当前的页表的地址和长度</li><li>页表控制寄存器和进程表是有关联的，所有进程在进程表中都有一项，当这个进程占据CPU时，这个进程就占据页表控制寄存器。</li><li>不使用快表:首先从逻辑地址中，提取出页号，比较页号是否出现越界中断，如果没有越界，则根据页表向下偏移到对应的块号，提取出页表信息和页框号，页框号结合单元号，得到物理地址</li><li>快表:不是从页表中查找，而是优先从快表中查询块号。</li></ol><h2 id="6-7-多级页表"><a href="#6-7-多级页表" class="headerlink" title="6.7. 多级页表"></a>6.7. 多级页表</h2><h3 id="6-7-1-多级页表的概念"><a href="#6-7-1-多级页表的概念" class="headerlink" title="6.7.1. 多级页表的概念"></a>6.7.1. 多级页表的概念</h3><ol><li>现代计算机普遍支持$2^{32}-2^{64}$容量的逻辑地址空间，采用分页存储管理时，页表相当大，以Windows为例，其运行的Intel x86平台具有32位地址，规定页面4KB($2^{12}$)时，那么，4GB($2^{32}$)的逻辑地址空间由1MB($2^{20}$)个页组成，若每个页表项占用4个字节，则需要占用4MB($2^{22}$)连续主存空间存放页表。系统中有许多进程，因此页表存储开销很大。</li><li>做法：把整个页表分割成许多小页表，每个称为<strong>页表页</strong>，它的大小与页框长度相同，于是每个页表页含有若干页表表项。<ol><li>页表项从0开始编号，允许放到不连续的页框中，为了找到页表页，建立地质索引，称为<strong>页目录表</strong>。</li><li>系统为每一个进程建立一张页目录表，他的每一个表项指出一个页表页，而页表页的每个表项给出页面和页框的对应关系。</li></ol></li><li>逻辑地址结构有三部分组成：页目录、页表页和位移</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/83.png"></p><ol start="4"><li>解决页表页如何占用内存空间的问题，解决方法：进程运行设计到的页面的页表页放置在内存中，其他页表页使用时动态调入，因此需要添加标志位指示是否调入内存。</li></ol><h3 id="6-7-2-多级页表地址转换过程"><a href="#6-7-2-多级页表地址转换过程" class="headerlink" title="6.7.2. 多级页表地址转换过程"></a>6.7.2. 多级页表地址转换过程</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/71.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/72.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/73.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/74.png"></td></tr></tbody></table><h3 id="6-7-3-多级页表结构的本质"><a href="#6-7-3-多级页表结构的本质" class="headerlink" title="6.7.3. 多级页表结构的本质"></a>6.7.3. 多级页表结构的本质</h3><ol><li>多级不连续导致多级索引。</li><li>以二级页表为例，用户程序的页面不连续存放，要有页面地址索引，该索引是进程页表；进程页表又是不连续存放的多个页表页，故页表页也要页表页地址索引，该索引就是页目录。</li><li>页目录项是页表页的索引，而页表页项是进程程序的页面索引。</li></ol><h2 id="6-8-反置页表-IPT"><a href="#6-8-反置页表-IPT" class="headerlink" title="6.8. 反置页表(IPT)"></a>6.8. 反置页表(IPT)</h2><ol><li>页表设计的一个重要缺陷是页表的大小与虚拟地址空间的大小成正比</li><li>对于一个128MB的计算机，如果页面尺寸为4KB，页表项大小为4B，那么其反置页表只占有128KB的内存。</li><li>通过这个结构，哈希表和反向表中只有一项对应于一个实存页(面向实存)，而不是虚拟页(面向虚存)。因此，不论由多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分。</li><li>正向页表(名单)、反置页表(现场坐的是谁)<ol><li>正向页表:以<strong>页号</strong>为索引(隐含)，完整连续排列，页表项中不含页号，每个进程单独一个页表</li><li>反置页表:以<strong>页框号</strong>为索引(隐含)，完整连续排列，每个页框填入的是哪个进程的哪个页号，索引进程共用一个反置页表。其页表项不包含页框号</li></ol></li></ol><h3 id="6-8-1-反置页表的提出"><a href="#6-8-1-反置页表的提出" class="headerlink" title="6.8.1. 反置页表的提出"></a>6.8.1. 反置页表的提出</h3><ol><li>页表及相关硬件机制在地址转换、存储保护、虚拟地址访问中发挥了<strong>关键作用</strong>，为页式存储管理设置专门硬件机构</li><li>内存管理单元MMU：CPU管理虚拟&#x2F;物理存储器的控制线路，把虚拟地址映射为物理地址，并提供存储保护，必要时确定淘汰页面</li><li>反置页表IPT：<strong>MMU使用的数据结构</strong></li></ol><h3 id="6-8-2-反置页表的基本设计思想"><a href="#6-8-2-反置页表的基本设计思想" class="headerlink" title="6.8.2. 反置页表的基本设计思想"></a>6.8.2. 反置页表的基本设计思想</h3><ol><li><strong>针对内存中的每个页架建立一个页表</strong>，按照块号(页架号)排序</li><li>表项包含：正在访问该页框的进程标识、页号及特征位，和<strong>哈希链指针</strong>等</li><li>用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换</li></ol><h3 id="6-8-3-反置页表的页表项"><a href="#6-8-3-反置页表的页表项" class="headerlink" title="6.8.3. 反置页表的页表项"></a>6.8.3. 反置页表的页表项</h3><ol><li>页号：虚拟地址页号</li><li>进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)</li><li>标志位：有效、引用、修改、保护和锁定等标志信息</li><li>链指针：<strong>哈希链</strong>，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。</li></ol><h3 id="6-8-4-反置页表的逻辑地址"><a href="#6-8-4-反置页表的逻辑地址" class="headerlink" title="6.8.4. 反置页表的逻辑地址"></a>6.8.4. 反置页表的逻辑地址</h3><ol><li>进程标识符：使用该页的进程。</li><li>页号：虚拟地址页号部分，页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。</li><li>页内位移</li></ol><h3 id="6-8-5-反置页表的地址转换"><a href="#6-8-5-反置页表的地址转换" class="headerlink" title="6.8.5. 反置页表的地址转换"></a>6.8.5. 反置页表的地址转换</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/75.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/76.png"></th></tr></thead></table><blockquote><p>上图4-10中，以<strong>页框号</strong>为索引，记录当前页框中存储的是哪个进程的哪个页</p></blockquote><ol><li>反置页表地址转换过程如下:<ol><li>需要访问内存地址时，地址转换机制用进程标识符与页号作为输入，由哈希函数先映射到哈希表，哈希表项存放的是指向IPT表项的指针<ol><li>此指针可能就是指向匹配的IPT表项</li><li>如果不是则遍历哈希链直至找到进程标识符与页号均匹配的IPT表项：因为多个页号通过哈希值可能得到了相同的哈希值，所以我们选择使用哈希链。</li></ol></li><li>而此表项的**序号(索引)**就是页框号，通过拼接页内位移便可生成物理地址。</li><li>若在反置页表中未能找到匹配的IPT页表项，说明此页不在内存，触发缺页异常，请求操作系统通过页表调入：发生缺页中断时需要多访问一次磁盘，速度会比较慢。</li></ol></li><li>页框号是根据公式换算出来的:$x_i &#x3D; x_0 + 4 * i$</li></ol><h3 id="6-8-6-反置页表"><a href="#6-8-6-反置页表" class="headerlink" title="6.8.6. 反置页表"></a>6.8.6. 反置页表</h3><table><thead><tr><th>线性反置页表</th><th>反置页表</th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/77.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/78.png"></td></tr><tr><td>哈希线性反置页表</td><td>主存分配的位示图和链表方法</td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/79.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/80.png"></td></tr></tbody></table><h3 id="6-8-7-反置页表下的地址转换示意"><a href="#6-8-7-反置页表下的地址转换示意" class="headerlink" title="6.8.7. 反置页表下的地址转换示意"></a>6.8.7. 反置页表下的地址转换示意</h3><ol><li>未显示选择淘汰页面，同样由MMU完成</li><li>使用哈希提高性能-&gt;不必遍历</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/26.png"></p><h1 id="7-段式存储管理"><a href="#7-段式存储管理" class="headerlink" title="7. 段式存储管理"></a>7. 段式存储管理</h1><ol><li>段式存储管理基于可变分区存储管理原理。</li></ol><h2 id="7-1-程序分段结构"><a href="#7-1-程序分段结构" class="headerlink" title="7.1. 程序分段结构"></a>7.1. 程序分段结构</h2><ol><li>高级语言采用模块化程序设计方法。应用程序由若干程序段(模块)组成，如由主程序段(M)、子程序段(X)、数据段(D)和工作区段(W)组成，每一段都从0开始编制，各有各自名字和长度且实现不同功能。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/27.png"></p><ol start="2"><li>编译后段间地址是不连续的，段内地址是连续的。</li></ol><h2 id="7-2-段式存储逻辑地址"><a href="#7-2-段式存储逻辑地址" class="headerlink" title="7.2. 段式存储逻辑地址"></a>7.2. 段式存储逻辑地址</h2><ol><li>分段存储器的逻辑地址由两部分组成:段号+段内偏移</li><li>页式存储管理中页的划分对程序员不可见。</li><li>段式存储管理中段的划分对程序员可见。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/84.png"></p><h2 id="7-3-段式存储的段表"><a href="#7-3-段式存储的段表" class="headerlink" title="7.3. 段式存储的段表"></a>7.3. 段式存储的段表</h2><ol><li>存储分配时，应该为进入内存的作业建立段表，各段在内存中的情况有段表来记录，包含了段号、段起始长度和长度。</li><li>撤销进程时，回收所占用的内存空间，并清除此进程的段表。</li><li>段表表项实际上起到了基址&#x2F;限长寄存器的作用，设置段表控制寄存器</li></ol><h2 id="7-4-段式存储管理的基本思想"><a href="#7-4-段式存储管理的基本思想" class="headerlink" title="7.4. 段式存储管理的基本思想"></a>7.4. 段式存储管理的基本思想</h2><ol><li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区</li><li>硬件需要增加一组用户可见的段地址寄存器(代码段、数据段、堆栈段，附加段)，供地址转换使用</li><li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：段始址、段限长，以及存储保护、可移动、可扩充等标志位</li></ol><h2 id="7-5-段式存储管理的地址转换流程"><a href="#7-5-段式存储管理的地址转换流程" class="headerlink" title="7.5. 段式存储管理的地址转换流程"></a>7.5. 段式存储管理的地址转换流程</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/28.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/85.png"></th></tr></thead></table><blockquote><p>使用终端来完成</p></blockquote><h2 id="7-6-段的共享"><a href="#7-6-段的共享" class="headerlink" title="7.6. 段的共享"></a>7.6. 段的共享</h2><ol><li>如果多个进程段表中的某段指向内存相同的地址，内存中以该处为起始地址的某段就可以被共享。</li><li>对共享段的信息必须进行保护，如规定只能读出不能写入，不满足保护条件则产生保护中断</li><li>为了方便共享，系统中常常建立一张共享段表记录所有共享段，包含段名、共享计数、段长、段首址、保护位等。</li></ol><h1 id="8-分页和分段的寻址计算"><a href="#8-分页和分段的寻址计算" class="headerlink" title="8. 分页和分段的寻址计算"></a>8. 分页和分段的寻址计算</h1><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/37.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/38.png"></th></tr></thead></table><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/39.png"></p><h2 id="8-1-分段和分页的比较"><a href="#8-1-分段和分页的比较" class="headerlink" title="8.1. 分段和分页的比较"></a>8.1. 分段和分页的比较</h2><ol><li>分段是信息的<strong>逻辑单位</strong>，由源程序的逻辑结构所决定，<strong>用户可见</strong><ol><li>段长可根据<strong>用户需要</strong>来规定，段起始地址可从<strong>任何主存地址</strong>开始。</li><li>分段方式中，源程序(段号，段内位移)经连结装配后地址仍保持<strong>二维结构</strong>。</li></ol></li><li>分页是信息的物理单位，与源程序的逻辑结构无关，<strong>用户不可见</strong>，<ol><li>页长由<strong>系统</strong>确定，页面只能以<strong>页大小的整倍数地址</strong>开始</li><li>分页方式中，源程序(页号，页内位移)经连结装配后地址变成了<strong>一维结构</strong></li></ol></li></ol><h2 id="8-2-分页-逻辑地址到物理地址"><a href="#8-2-分页-逻辑地址到物理地址" class="headerlink" title="8.2. 分页:逻辑地址到物理地址"></a>8.2. 分页:逻辑地址到物理地址</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/65.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/66.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/67.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/68.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/69.png"></td><td></td></tr></tbody></table><h1 id="9-段页式存储管理"><a href="#9-段页式存储管理" class="headerlink" title="9. 段页式存储管理"></a>9. 段页式存储管理</h1><h2 id="9-1-段页式存储管理的基本思想"><a href="#9-1-段页式存储管理的基本思想" class="headerlink" title="9.1. 段页式存储管理的基本思想"></a>9.1. 段页式存储管理的基本思想</h2><ol><li><strong>段式存储管理</strong>可以基于<strong>页式存储管理</strong>实现</li><li>每一段不必占据连续的存储空间，可存放在不连续的主存页架中</li><li>能够扩充为段页式虚拟存储管理</li><li>装入部分段，或者装入段中部分页面</li></ol><h2 id="9-2-段页式存储管理的段表和页表"><a href="#9-2-段页式存储管理的段表和页表" class="headerlink" title="9.2. 段页式存储管理的段表和页表"></a>9.2. 段页式存储管理的段表和页表</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/31.png"></p><ol><li>既有段表，也有页表</li><li>段表中存储的是页表和页表始址</li></ol><h2 id="9-3-段页式存储管理的地址转换"><a href="#9-3-段页式存储管理的地址转换" class="headerlink" title="9.3. 段页式存储管理的地址转换"></a>9.3. 段页式存储管理的地址转换</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/32.png"></p><h1 id="10-页式虚拟存储管理"><a href="#10-页式虚拟存储管理" class="headerlink" title="10. 页式虚拟存储管理"></a>10. 页式虚拟存储管理</h1><h2 id="10-1-页式虚拟存储管理的基本原理"><a href="#10-1-页式虚拟存储管理的基本原理" class="headerlink" title="10.1. 页式虚拟存储管理的基本原理"></a>10.1. 页式虚拟存储管理的基本原理</h2><ol><li>将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装入内存，仅装入当前使用页面，进程执行过程中访问到不再内存的页面时，再由系统自动调入。</li><li>页式虚拟存储是现代OS的<strong>主流存储管理技术</strong></li><li>请求页式存储管理：由于页面在需要时是根据进程请求装入内存的</li><li>请求页式存储管理<ol><li>优点：进程的程序和数据可按页分散存储在内存中，有利于内存利用率和多道程序运行</li><li>缺点：需要硬件支持、处理缺页中断、机器成本增加、系统开销加大，页内存在碎片。</li></ol></li></ol><h3 id="10-1-1-页式虚拟存储管理的页表"><a href="#10-1-1-页式虚拟存储管理的页表" class="headerlink" title="10.1.1. 页式虚拟存储管理的页表"></a>10.1.1. 页式虚拟存储管理的页表</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/22.png"></p><ol><li>需要扩充页表项，至少包含如上信息，指出：<ol><li>主存驻留标志：指出页面是否已经装入内存。1表示在内存中可以被正常访问，0表示不能立即访问，产生缺页异常。</li><li>修改位：被设置后，该页被调出内存前必须先写回磁盘，保障数据一致性</li><li>保护位：限制页面访问权限</li><li>引用位：在页面被引用无论是读写时设置，用来帮助系统进行页面淘汰。</li><li>内存块号：页面对应的页框号，用来地址转换。</li></ol></li><li>32位操作系统:32bit标识一个页表项</li><li>页号是隐含信息，不是直接存储的信息。</li></ol><h2 id="10-2-页式虚拟存储管理的实现"><a href="#10-2-页式虚拟存储管理的实现" class="headerlink" title="10.2. 页式虚拟存储管理的实现"></a>10.2. 页式虚拟存储管理的实现</h2><ol><li>CPU处理地址<ol><li>若页驻留，则获得块号形成绝对地址</li><li>若页不在内存，则CPU发出缺页中断</li></ol></li><li>OS处理缺页中断<ol><li>若有空闲页架，则根据辅存地址(虚存)调入页，更新页表与快表等</li><li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li></ol></li></ol><h3 id="10-2-1-页式虚拟存储管理的地址转换"><a href="#10-2-1-页式虚拟存储管理的地址转换" class="headerlink" title="10.2.1. 页式虚拟存储管理的地址转换"></a>10.2.1. 页式虚拟存储管理的地址转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/23.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/24.png"></p><ol><li>本指令没有被处理完，是在查找地址的时候发生的中断，所以要回退指令执行。<br>缺页中断完成后要<strong>重新执行被中断指令</strong>。</li></ol><h3 id="10-2-2-页式虚拟存储管理的地址转换全过程"><a href="#10-2-2-页式虚拟存储管理的地址转换全过程" class="headerlink" title="10.2.2. 页式虚拟存储管理的地址转换全过程"></a>10.2.2. 页式虚拟存储管理的地址转换全过程</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/40.png"></p><ol><li>地址转换过程<ol><li>MMU接收CPU传送来的逻辑地址并自动按页面大小把它从某位起分解成两部分:页号和页内位移。</li><li>以页号为索引快速搜索快表TLB。</li><li>如果命中，立即送出页框号，并与贾内位移拼接成物理地址，然后进行访问权限检查，如获通过，进程就可以访问物理地址。</li><li>如果不命中，由硬件以页号为索引搜索页表，页表基址由硬件页表基址寄存器指出。</li><li>如果页表被命中，说明访问页面已在内存中，可送出页框号，并与页内位移拼接成物理地址，然后进行访问权限检查，如获通过，进程就可以访问物理地址，同时要把这个页面和页框信息装入快表TLB，以备再次访问。</li><li>如果发现页表中的对应页面失效，MMU发出缺页异常，请求操作系统进行处理，MMU工作到此结束。</li></ol></li><li>MMU发现缺页并发出缺页异常，存储管理接收控制，进行缺页异常处理的过程如下：<ol><li>挂起请求调页的进程。</li><li>根据页号搜索外页表，找到存放此页的磁盘物理地址。</li><li>查看内存是否有空闲页框，如有则分配一个，转(6)。</li><li>如果内存中无空闲页框，按照替换算法选择淘汰页面，检查其是否被写过或修改过，若否则转(6)，若是则转(5)。</li></ol></li></ol><h3 id="10-2-3-TLB-快表"><a href="#10-2-3-TLB-快表" class="headerlink" title="10.2.3. TLB(快表)"></a>10.2.3. TLB(快表)</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/35.png"></p><p>Note:快表存储正在进行的进程的若干(非连续)的页表项，其意义在于：快表访问速度高于内存，减少访问内存的次数，提高也是寻址效率</p><h1 id="11-页面调度"><a href="#11-页面调度" class="headerlink" title="11. 页面调度"></a>11. 页面调度</h1><ol><li>当主存空间已满而又需要装入新页时，页式虚拟存储管理必须按照一定的算法将已在主存的一些页调出去<ol><li>选择淘汰页的工作成为<strong>页面调度</strong></li><li>选择淘汰页的算法称为<strong>页面调度算法</strong></li></ol></li></ol><h2 id="11-1-交换区"><a href="#11-1-交换区" class="headerlink" title="11.1. 交换区"></a>11.1. 交换区</h2><ol><li>操作系统需要在磁盘上定义一个交换区用来保存临时换出的页面，交换区由磁盘上的一个或多个磁盘分区组成。</li><li>简单做法：进程启动时，留出大小和进程一样大的交换分区。</li><li>与进程对应的是其交换区的磁盘地址，即进程映像所保存的位置，这一信息记录在进程的外页表中。</li><li>问题：进程启动可能会在增大，解决：将正文、数据和堆栈分别保留交换区，并且多留几块。</li><li>交换区管理重点是维护交换区映射表，记录所有的呗换出内存的页面在交换区中的位置，以便需要时换入，第二次被换出内存时，当且仅当页面修改过才再次写入，否则直接抛弃。</li></ol><h2 id="11-2-页面装入策略和清除策略"><a href="#11-2-页面装入策略和清除策略" class="headerlink" title="11.2. 页面装入策略和清除策略"></a>11.2. 页面装入策略和清除策略</h2><ol><li>页面装入策略用来解决何时将页面装入内存</li><li>请页式：当产生缺页异常时调入页面<ol><li>在替换时只有发生了更改才写回。</li><li>优点：只有被访问页面才会被调入，节省内存</li><li>缺点：缺页异常处理次数多，系统开销大。</li></ol></li><li>预调式：在使用页面前预先调入内存，操作系统根据某种算法动态预测进程最可能访问的界面，每次调入若干页面。<ol><li>在替换前需要将他们都写回磁盘，可成批进行。</li><li>优点：减少磁盘I&#x2F;O的启动次数，节省寻道和搜索时间。</li><li>缺点：如果调入的大多数界面都没有被使用则效率很低。</li></ol></li></ol><h2 id="11-3-页面分配策略"><a href="#11-3-页面分配策略" class="headerlink" title="11.3. 页面分配策略"></a>11.3. 页面分配策略</h2><ol><li>请求分页虚存管理可能在缺页方面付出很大的代价，需要确定页面调度算法的作用范围是此进程的页面，还是内存中的所有进程的页面。<ol><li>全局替换：不考虑进程属主</li><li>局部替换：仅限于进程本身</li></ol></li><li>分配方式<ol><li>固定分配：进程生命周期中保持页框数固定不变，有平均分配、比例分配、优先权分配等方式。</li><li>可变分配：进程生命周期中所分得的页框数可变。<ol><li>缺页率较高，说明局部性较差，可以适度提高分配的页框数。</li><li>缺页率较低，可以适度降低分配的页框数</li></ol></li></ol></li><li>工作集(驻留集)：每个进程维护的一组页面。</li><li>可变分配配合局部替换可以克服全局替换的缺点。</li></ol><h3 id="11-3-1-固定分配，本地范围"><a href="#11-3-1-固定分配，本地范围" class="headerlink" title="11.3.1. 固定分配，本地范围"></a>11.3.1. 固定分配，本地范围</h3><ol><li>分配给进程的帧数是固定的</li><li>从分配给过程的框架中选择要替换的页面</li></ol><h3 id="11-3-2-变量分配，全局范围"><a href="#11-3-2-变量分配，全局范围" class="headerlink" title="11.3.2. 变量分配，全局范围"></a>11.3.2. 变量分配，全局范围</h3><ol><li>分配给进程的帧数是可变的</li><li>从所有框架中选择要替换的页面</li><li>最容易实现</li><li>被许多操作系统采用</li><li>操作系统保留空闲帧列表</li><li>发生页面错误时，将空闲帧添加到驻留的进程集</li><li>课本224全局页面替换策略和229局部页面替换策略</li></ol><h3 id="11-3-3-变量分配，本地范围"><a href="#11-3-3-变量分配，本地范围" class="headerlink" title="11.3.3. 变量分配，本地范围"></a>11.3.3. 变量分配，本地范围</h3><ol><li>分配给进程的帧数是可变的</li><li>从分配给过程的框架中选择要替换的页面</li><li>添加新流程后，请根据应用程序类型，程序请求或其他条件分配页框数量</li><li>发生页面错误时，请从发生故障的进程的常驻集中选择页面。</li><li>不时重新评估分配</li></ol><h2 id="11-4-缺页中断率"><a href="#11-4-缺页中断率" class="headerlink" title="11.4. 缺页中断率"></a>11.4. 缺页中断率</h2><ol><li>页面调度算法设计不当，会出现(刚淘汰的页面立即又要调入，并如此反复)，这种现象称为<strong>抖动</strong>或<strong>颠簸</strong>，主要原因是内存中同时运行的进程太多，而分配给每个进程的页框太少。</li><li>假定进程$P$共有$n$页，系统分配页架数$m$个</li><li>$P$运行中成功访问次数为$S$，不成功访问次数为$F$，总访问次数$A &#x3D; S + F$</li><li><strong>缺页中断率</strong>定义为: $f &#x3D; \frac{F}{A}$</li><li>缺页中断率是衡量存储管理性能和用户编程水平的重要依据</li></ol><h3 id="11-4-1-缺页中断率的影响因素"><a href="#11-4-1-缺页中断率的影响因素" class="headerlink" title="11.4.1. 缺页中断率的影响因素"></a>11.4.1. 缺页中断率的影响因素</h3><ol><li>分配给进程的页框数：可用页框数越多，则缺页中断率就越低</li><li>页面的大小：页面尺寸越大，则缺页中断率就越低</li><li>页面替换算法：算法的优劣影响缺页异常次数</li><li>程序特性：程序局部性要好，它对缺页中断率有很大影响。</li></ol><h3 id="11-4-2-用户编程的例子"><a href="#11-4-2-用户编程的例子" class="headerlink" title="11.4.2. 用户编程的例子"></a>11.4.2. 用户编程的例子</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/25.png"></p><blockquote><p>不同的访问方式会到导致出现缺页情况的。</p></blockquote><h2 id="11-5-全局页面替换策略"><a href="#11-5-全局页面替换策略" class="headerlink" title="11.5. 全局页面替换策略"></a>11.5. 全局页面替换策略</h2><h3 id="11-5-1-OPT页面调度算法-Belady算法"><a href="#11-5-1-OPT页面调度算法-Belady算法" class="headerlink" title="11.5.1. OPT页面调度算法(Belady算法)"></a>11.5.1. OPT页面调度算法(Belady算法)</h3><ol><li>算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择<strong>距现在最长时间后再访问</strong>的页。</li><li>该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)</li><li>OPT只可以<strong>模拟</strong>，不可以实现，因为永远无法预知之后的事情。</li><li>这种算法可以用作衡量其他各种算法的标准。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/41.png"></p><h3 id="11-5-2-先进先出页面调度算法-FIFO"><a href="#11-5-2-先进先出页面调度算法-FIFO" class="headerlink" title="11.5.2. 先进先出页面调度算法(FIFO)"></a>11.5.2. 先进先出页面调度算法(FIFO)</h3><ol><li>算法描述：首先淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)</li><li>模拟的是程序执行的顺序性，有一定合理性，并不能很好模拟程序的循环性。</li><li>根据估计，缺页中断率也是最佳算法的2-3倍。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/42.png"></p><ol start="4"><li><strong>FIFO算法的Belady异常</strong>：更多的页框导致了更高的缺页率，页框为3和4的时候</li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/47.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/48.png"></th></tr></thead></table><h3 id="11-5-3-页面缓冲算法"><a href="#11-5-3-页面缓冲算法" class="headerlink" title="11.5.3. 页面缓冲算法"></a>11.5.3. 页面缓冲算法</h3><p>页面缓冲算法是对FIFO替换算法的一种改进</p><blockquote><p>算法策略</p></blockquote><ol start="2"><li>系统维护两个FIFO队列，被替换的页面添加到如下两个队列中<ol><li>修改页面队列</li><li>非修改(空闲)页面队列</li></ol></li><li>替换的页面仍保留在内存中<ol><li>如果再次引用，则找回的费用很少</li><li>当修改页面队列中的页面到达一定数量后，页面以群集形式写回磁盘，并把空闲页框加入非修改页面队列尾部。</li></ol></li></ol><h3 id="11-5-4-最近最少用LRU页面调度算法"><a href="#11-5-4-最近最少用LRU页面调度算法" class="headerlink" title="11.5.4. 最近最少用LRU页面调度算法"></a>11.5.4. 最近最少用LRU页面调度算法</h3><ol><li>淘汰<strong>最近一段时间较久未被访问</strong>的那一页，即那些刚被使用过的页面，可以马上还要被使用到。</li><li>模拟了程序执行的局部属性，既考虑了<strong>循环性</strong>，又兼顾了<strong>顺序性</strong></li><li>严格实现的代价大(需要维持特殊队列——页面淘汰队列)，实现需要硬件支持。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/43.png"></p><ol start="4"><li>LRU算法得到模拟实现：模拟是相当的不严谨，非常粗粒度的一个模拟。<ol><li>引用位法：每页建立一个引用标志，供硬件使用，设置一个时间间隔中断，发生时将页引用标志置0，访问页面时将引用标志置为1，页面置换的时候选择标志为0的页面，在选中淘汰页时，将所有的页的引用为全部置为0</li><li>计数法：每页添加页面引用计数器，根据计数器选择最小的，定时清空页面引用计数器</li><li>计时法：每页添加计时单元，引用时，将绝对时间记录进入计时单元，定时清空计时单元。</li><li>老化算法：设置一个多位寄存器，被访问将最左侧设置为1，定时将寄存器右移，缺页中断时找到最小值的寄存器界面淘汰，被采用较多。</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/87.png"></p><ol><li>上图使用老化算法</li><li>T3时刻替换P2页面，因为和P1他们在3时刻都没有被访问，但是2时刻P1被访问了</li></ol><h3 id="11-5-5-第二次机会页面替换算法-SCR，Second-Chance-Replacement"><a href="#11-5-5-第二次机会页面替换算法-SCR，Second-Chance-Replacement" class="headerlink" title="11.5.5. 第二次机会页面替换算法(SCR，Second Chance Replacement)"></a>11.5.5. 第二次机会页面替换算法(SCR，Second Chance Replacement)</h3><ol><li>将FIFO算法和页表中引用位结合。</li><li>算法描述：<ol><li>首先检查FIFO页面队列队首<ol><li>引用位为0，则淘汰该页面</li><li>引用位为1，将引用位清0，并将该页面移到队列尾部</li></ol></li><li>如果第一遍全为1，则循环</li></ol></li></ol><h3 id="11-5-6-最不常用LFU的页面调度算法"><a href="#11-5-6-最不常用LFU的页面调度算法" class="headerlink" title="11.5.6. 最不常用LFU的页面调度算法"></a>11.5.6. 最不常用LFU的页面调度算法</h3><ol><li>淘汰最近一段时间内<strong>访问次数较少</strong>的页面，对OPT的模拟性比LRU更好</li><li>算法过程：基于时间间隔中断，并给每一页设置一个计数器，时间间隔中断发生后，所有计数器清0，每访问页1次就给计数器加1，选择计数最小的页面淘汰</li></ol><h3 id="11-5-7-时钟CLOCK页面调度算法"><a href="#11-5-7-时钟CLOCK页面调度算法" class="headerlink" title="11.5.7. 时钟CLOCK页面调度算法"></a>11.5.7. 时钟CLOCK页面调度算法</h3><ol><li>CLOCK就是SCR结合FIFO形成循环，使用页引用标志位。</li><li>算法描述：采用循环队列机制构造页面队列，形成了一个类似钟表面的环形表，队列指针则相当于钟表面上的表针，指向可能要淘汰的页面</li></ol><h4 id="11-5-7-1-CLOCK算法的工作流程"><a href="#11-5-7-1-CLOCK算法的工作流程" class="headerlink" title="11.5.7.1. CLOCK算法的工作流程"></a>11.5.7.1. CLOCK算法的工作流程</h4><ol><li>页面调入主存时，其引用标志位置为1</li><li>访问主存页面时，其引用标志位置为1</li><li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ol><li>把所遇到的引用标志位是1的页面的引用标志位清0并跳过</li><li>把所遇到的引用标志位是0的页面淘汰，<strong>指针推进一步</strong></li></ol></li></ol><h4 id="11-5-7-2-CLOCK算法的例子"><a href="#11-5-7-2-CLOCK算法的例子" class="headerlink" title="11.5.7.2. CLOCK算法的例子"></a>11.5.7.2. CLOCK算法的例子</h4><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/44.png"></p><blockquote><p>灰色和星号代表1，蓝色和无星号代表0</p><ol><li>发生命中，指针不动</li><li>指针运动是为了寻找替换的页</li><li>1-&gt;5其实是循环一轮，如果为1，指针不替换，但是会将标志位置为0</li></ol></blockquote><ol><li>当一页被替换时，指向下一帧。虽然早就进来，但是最近使用过，所以不急着替换</li><li>当需要替换一页时，扫描缓冲区，查找使用位被置为0的一帧。</li><li>每当遇到一个使用位为1的帧时，就将该位重新置为0；</li><li>如果在这个过程开始时，所有帧的使用位均为0，选择遇到的第一个帧替换；</li><li>如果所有帧的使用位为1，则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。</li></ol><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/45.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/46.png"></th></tr></thead></table><h4 id="11-5-7-3-第三次机会时钟替换算法：结合引用位和修改位"><a href="#11-5-7-3-第三次机会时钟替换算法：结合引用位和修改位" class="headerlink" title="11.5.7.3. 第三次机会时钟替换算法：结合引用位和修改位"></a>11.5.7.3. 第三次机会时钟替换算法：结合引用位和修改位</h4><ol><li>一共四种情况：r是引用位，m是修改位<ol><li>最近未被引用，未被修改：r&#x3D;0，m&#x3D;0</li><li>最近被引用，未被修改：r&#x3D;1，m&#x3D;0</li><li>最近未被引用，被修改：r&#x3D;0，m&#x3D;1</li><li>最近被引用，被修改：r&#x3D;1，m&#x3D;1</li></ol></li><li>算法描述<ol><li>扫描，不修改引用位，找到第一个r&#x3D;0，m&#x3D;0的页面替换</li><li>如果1没有找到，则从原位置开始，<strong>修改引用位</strong>，查找r&#x3D;0，m&#x3D;1的页面替换写回</li><li>如果2没有找到，重复1或2操作。</li></ol></li></ol><h3 id="11-5-8-不同算法性能比较"><a href="#11-5-8-不同算法性能比较" class="headerlink" title="11.5.8. 不同算法性能比较"></a>11.5.8. 不同算法性能比较</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/49.png"></p><p>整体上来讲FIFO &gt; CLOCK &gt; LRU &gt; OPT</p><h2 id="11-6-局部页面替换算法-不考"><a href="#11-6-局部页面替换算法-不考" class="headerlink" title="11.6. 局部页面替换算法(不考)"></a>11.6. 局部页面替换算法(不考)</h2><p>P229-233</p><h3 id="11-6-1-局部最佳页面替换算法-MIN"><a href="#11-6-1-局部最佳页面替换算法-MIN" class="headerlink" title="11.6.1. 局部最佳页面替换算法(MIN)"></a>11.6.1. 局部最佳页面替换算法(MIN)</h3><ol><li>实现思想：进程在时刻t访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框</li><li>不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</li><li>t为一个系统常量，间隔(t, t+τ)称作滑动窗口 。例子中τ&#x3D;3，双闭区间</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/50.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/51.png"></p><h3 id="11-6-2-工作集模型和工作集置换算法-WS"><a href="#11-6-2-工作集模型和工作集置换算法-WS" class="headerlink" title="11.6.2. 工作集模型和工作集置换算法(WS)"></a>11.6.2. 工作集模型和工作集置换算法(WS)</h3><ol><li>进程工作集指”在某一段时间间隔内进程运行所需访问的页面集合”</li><li>实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，<strong>不向前查看页面引用串，而是基于程序局部性原理向后看</strong></li><li>任何给定时刻，<strong>进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计</strong></li></ol><h4 id="11-6-2-1-进程工作集"><a href="#11-6-2-1-进程工作集" class="headerlink" title="11.6.2.1. 进程工作集"></a>11.6.2.1. 进程工作集</h4><ol><li>指”在某一段时间间隔内进程运行所需访问的页面集合”，W(t，Δ)表示在时刻t-Δ到时刻t之间( (t-Δ，t))所访问的页面集合，进程在时刻t的工作集</li><li>Δ是系统定义的一个常量。变量Δ称为”工作集窗口尺寸”，可通过窗口来观察进程行为，还把工作集中所包含的页面数目称为”工作集尺寸”</li><li>Δ&#x3D;3</li></ol><h4 id="11-6-2-2-示例"><a href="#11-6-2-2-示例" class="headerlink" title="11.6.2.2. 示例"></a>11.6.2.2. 示例</h4><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/52.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/53.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/54.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/55.png"></p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/56.png"></p><blockquote><p>工作集:程序在运行过程时，程序的局部性是变更的。有的部分是比较陡的，大量调入，然后平稳期，访问替换进来的页们。</p></blockquote><h3 id="11-6-3-模拟工作集替换算法"><a href="#11-6-3-模拟工作集替换算法" class="headerlink" title="11.6.3. 模拟工作集替换算法"></a>11.6.3. 模拟工作集替换算法</h3><h3 id="11-6-4-缺页频率替换算法"><a href="#11-6-4-缺页频率替换算法" class="headerlink" title="11.6.4. 缺页频率替换算法"></a>11.6.4. 缺页频率替换算法</h3><ol><li>定义页面错误率的上限U和下限L。</li><li>如果缺页率高于U，则为进程分配更多页框。</li><li>如果缺页率低于U，则为进程分配更少页框。</li><li>驻留集的大小应该和工作集大小W紧密相关的。</li><li>如果PFF(缺页率)&gt;U并且没有更多可用帧，我们将暂停该过程，ROI(Return On Investment)</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/58.png"></p><blockquote><p>页框的大小是需要根据程序动态调整的。</p></blockquote><h3 id="11-6-5-通过工作集确定驻留集大小"><a href="#11-6-5-通过工作集确定驻留集大小" class="headerlink" title="11.6.5. 通过工作集确定驻留集大小"></a>11.6.5. 通过工作集确定驻留集大小</h3><ol><li>监视每个进程的工作集，只有属于工作集的页面才能留在主存；</li><li>定期地从进程驻留集中删去那些不在工作集中的页面；</li><li>仅当一个进程的工作集在主存时，进程才能执行。</li></ol><h1 id="12-段式虚拟存储管理"><a href="#12-段式虚拟存储管理" class="headerlink" title="12. 段式虚拟存储管理"></a>12. 段式虚拟存储管理</h1><h2 id="12-1-段式虚拟存储管理的基本思想"><a href="#12-1-段式虚拟存储管理的基本思想" class="headerlink" title="12.1. 段式虚拟存储管理的基本思想"></a>12.1. 段式虚拟存储管理的基本思想</h2><ol><li>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入</li><li>段式虚拟存储管理中段的调进调出是由OS自动实现的，<strong>对用户透明</strong></li><li>与段覆盖技术不同，它是用户控制的主存扩充技术，OS不感知</li></ol><h2 id="12-2-段式虚拟存储管理的段表扩充"><a href="#12-2-段式虚拟存储管理的段表扩充" class="headerlink" title="12.2. 段式虚拟存储管理的段表扩充"></a>12.2. 段式虚拟存储管理的段表扩充</h2><ol><li>段表的扩充</li><li>特征位: 00(不在内存)01(在内存)11(共享段)</li><li>存取权限: 00(可执行)01(可读)11(可写)</li><li>扩充位: 0(固定长)1(可扩充)</li><li>标志位: 00(未修改)01(已修改)11(不可移动)</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/29.png"></p><h2 id="12-3-段式虚拟存储管理的地址转换"><a href="#12-3-段式虚拟存储管理的地址转换" class="headerlink" title="12.3. 段式虚拟存储管理的地址转换"></a>12.3. 段式虚拟存储管理的地址转换</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/30.png"></p><h1 id="13-段页式虚拟存储管理"><a href="#13-段页式虚拟存储管理" class="headerlink" title="13. 段页式虚拟存储管理"></a>13. 段页式虚拟存储管理</h1><h2 id="13-1-段页式虚拟存储基本原理"><a href="#13-1-段页式虚拟存储基本原理" class="headerlink" title="13.1. 段页式虚拟存储基本原理"></a>13.1. 段页式虚拟存储基本原理</h2><ol><li>虚地址以程序的逻辑结构划分为段，这是段页式的段式特征。</li><li>实地址划分层位置固定、大小相同的页框(块)，这是段页式的页式特征。</li><li>将每一段的线性地址空间划分成与页框大小相同的页面，段页式的特征</li><li>逻辑地址由段号s、段内页号p和页内偏移d组成<ol><li>对用户，虚拟地址由段号s和段内位移d’组成</li><li>系统内部将d’分解为p和d，d’ &#x3D; p * 块长 + d</li></ol></li><li>请求段页式虚拟存储管理的数据结构比较复杂，包含作业表、段表和页表三部分。<ol><li>作业表：进入系统的作业和作业段表的起始地址</li><li>段表：是否在内存、段页表起始地址</li><li>页表：是否在内存、对应内存块号</li></ol></li></ol><h2 id="13-2-段页式虚拟存储管理的地址转换"><a href="#13-2-段页式虚拟存储管理的地址转换" class="headerlink" title="13.2. 段页式虚拟存储管理的地址转换"></a>13.2. 段页式虚拟存储管理的地址转换</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/33.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/88.png"></th></tr></thead></table><h1 id="14-存储管理方案以及虚存页面替换算法小结"><a href="#14-存储管理方案以及虚存页面替换算法小结" class="headerlink" title="14. 存储管理方案以及虚存页面替换算法小结"></a>14. 存储管理方案以及虚存页面替换算法小结</h1><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/89.png"></p><h1 id="15-补充：关于快表问题"><a href="#15-补充：关于快表问题" class="headerlink" title="15. 补充：关于快表问题"></a>15. 补充：关于快表问题</h1><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/1.jpg"></p><blockquote><p>有效位为0，不指引</p></blockquote><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/2.jpg"></p><ol><li>Valid并不全表示页表项是否在主存中</li><li>发生页面替换的时候，被替换的页如果在快表中，则其的valid位置0或者将该页删除。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/3.jpg"></p><h1 id="16-Linux虚拟存储管理"><a href="#16-Linux虚拟存储管理" class="headerlink" title="16. Linux虚拟存储管理"></a>16. Linux虚拟存储管理</h1><h2 id="16-1-伙伴系统-一种算法"><a href="#16-1-伙伴系统-一种算法" class="headerlink" title="16.1. 伙伴系统(一种算法)"></a>16.1. 伙伴系统(一种算法)</h2><ol><li>伙伴系统(Knuth，1973)，又称buddy算法，是一种<strong>固定分区和可变分区</strong>折中的主存管理算法</li><li>基本原理是：任何尺寸为$2^i$的空闲块都可被分为两个尺寸为$2^{i-1}$的空闲块，这两个空闲块称作<strong>伙伴</strong>，它们可以被合并成尺寸为$2^i$的原先空闲块。</li><li>伙伴通过对大块的物理主存划分而获得<ol><li>假如从第0个页面开始到第3个页面结束的主存</li><li>每次都对半划分，那么第一次划分获得大小为2页的伙伴，如0、1和2、3</li><li>进一步划分，可以获得大小为1页的伙伴，例如0和1，2和3</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/60.png"></p><h3 id="16-1-1-例子：类似二叉树的形式进行分配"><a href="#16-1-1-例子：类似二叉树的形式进行分配" class="headerlink" title="16.1.1. 例子：类似二叉树的形式进行分配"></a>16.1.1. 例子：类似二叉树的形式进行分配</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/61.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/62.png"></th></tr></thead></table><h3 id="16-1-2-Linux伙伴系统"><a href="#16-1-2-Linux伙伴系统" class="headerlink" title="16.1.2. Linux伙伴系统"></a>16.1.2. Linux伙伴系统</h3><ol><li>以page结构为数组元素的<code>mem_map[]</code>数组</li><li>以free_area_struct结构为数组元素的free_area数组</li><li>位图数组(bitmap)</li></ol><h4 id="16-1-2-1-Linux基于伙伴的slab分配器"><a href="#16-1-2-1-Linux基于伙伴的slab分配器" class="headerlink" title="16.1.2.1. Linux基于伙伴的slab分配器"></a>16.1.2.1. Linux基于伙伴的slab分配器</h4><ol><li>为什么要使用slab分配器?<ol><li>伙伴系统以<strong>页框</strong>为基本分配单位，内核在很多情况下，<strong>需要的主存量远远小于页框大小</strong>，如inode、vma、task_struct等，为了更经济地使用内核主存资源，引入<strong>SunOS操作系统中首创的基于伙伴系统的slab分配器</strong>，其基本思想是：为经常使用的小对象建立缓存，小对象的申请与释放都通过slab分配器来管理，仅当缓存不够用时才向伙伴系统申请更多空间。&#x2F;&#x2F;页内可以按2的幂次拆分。</li><li>优点：<strong>充分利用主存，减少内部碎片</strong>，对象管理局部化，尽可能少地与伙伴系统打交道，从而提高效率。</li></ol></li><li>slab的结构</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">slab</span>&#123;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>;          <span class="hljs-comment">// slab满、半满或空闲链表</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> colouoff;    <span class="hljs-comment">//slab着色偏移量</span><br>   <span class="hljs-type">void</span> * s_mem;              <span class="hljs-comment">//slab的第一个对象</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;        <span class="hljs-comment">//已分配的对象数</span><br>   <span class="hljs-type">kmem_bufctl_t</span> free;        <span class="hljs-comment">//第一个空闲对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>slab的操作</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/63.png"><br><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec3/64.png"></p><h4 id="16-1-2-2-slab分配器主要操作"><a href="#16-1-2-2-slab分配器主要操作" class="headerlink" title="16.1.2.2. slab分配器主要操作"></a>16.1.2.2. slab分配器主要操作</h4><ol><li>kmem_cache_create()函数：创建专用cache，规定对象的大小和slab的构成，并加入cache管理队列；</li><li>kmem_cache_alloc()与kmem_cache_free()函数：分别用于分配和释放一个拥有专用slab队列的对象；</li><li>kmem_cache_grow()与kmem_cache_reap()函数：<ol><li>kmem_cache_grow()它向伙伴系统申请向cache增加一个slab</li><li>kmem_cache_reap()用于定时回收空闲slab</li></ol></li><li>kmem_cache_destroy()与kmem_cache_shrink()：用于cache的销毁和收缩；</li><li>kmalloc()与kfree()函数：用来从通用的缓冲区队列中申请和释放空间；</li><li>kmem_getpages()与kmem_freepages()函数：slab与页框级分配器的接口，当slab分配器要创建新的slab或cache时，通过kmem_getpages()向内核提供的伙伴算法来获得一组连续页框。如果释放分配给slab分配器的页框，则调用kmem_freepages()函数。</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.处理器管理</title>
    <link href="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/"/>
    <url>/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/</url>
    
    <content type="html"><![CDATA[<h2 id="Lecture2-处理器管理"><a href="#Lecture2-处理器管理" class="headerlink" title="Lecture2-处理器管理"></a>Lecture2-处理器管理</h2><ol><li><strong>处理器管理</strong>是操作系统的重要组成部分<ol><li>处理器负责<strong>管理、调度和分配</strong>计算机系统的重要资源，并控制程序执行</li><li>处理器管理中最重要的是<strong>处理器调度</strong>，即进程调度，也就是控制、协调进程对处理器的竞争。</li></ol></li><li>进程与线程<ol><li>进程是资源分配和管理的单位</li><li>线程是处理器调度的基本单位。</li></ol></li><li>管态与目态<ol><li>管态又叫特权态(内核态、核心态)，可以执行特权指令，执行资源管理程序、为应用程序执行提供良好运行环境的各种原语等。</li><li>目态又叫用户态(普通态)，只能执行非特权指令</li></ol></li></ol><h1 id="1-处理器和寄存器"><a href="#1-处理器和寄存器" class="headerlink" title="1. 处理器和寄存器"></a>1. 处理器和寄存器</h1><h2 id="1-1-处理器"><a href="#1-1-处理器" class="headerlink" title="1.1. 处理器"></a>1.1. 处理器</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/1.png"></p><blockquote><p>部件简单示意图</p></blockquote><ol><li>上图各组件通过<strong>内部总线</strong>连接起来，构成一个<strong>不包含通用寄存器、I&#x2F;O相关寄存器、地址寄存器、数据寄存器和Cache</strong>的示意图。</li><li>CPU中的各组件描述<ol><li>算数逻辑单元：计算结束之后会将结果的标志放置到标志寄存器Flag中。</li><li>控制单元：包含重要的指令译码器ID，而指令是放置在指令暂存器IR中。</li><li>程序计数器PC：下一条指令的地址</li><li><strong>内存地址寄存器</strong>和<strong>内存数据寄存器</strong>：用来完成对内存数据的访问。</li></ol></li><li>通过<strong>系统总线</strong>来访问内存中的数据，首先设置地址和数据，然后通过控制来完成数据的读取和写回。</li><li>时钟等<strong>外部信号</strong>来反应到处理器线程中来。</li></ol><h2 id="1-2-寄存器"><a href="#1-2-寄存器" class="headerlink" title="1.2. 寄存器"></a>1.2. 寄存器</h2><h3 id="1-2-1-用户程序可见寄存器"><a href="#1-2-1-用户程序可见寄存器" class="headerlink" title="1.2.1. 用户程序可见寄存器"></a>1.2.1. 用户程序可见寄存器</h3><ol><li>可以使程序员减少访问主存储器的次数，提高指令执行的效率</li><li>所有程序可使用，包括应用程序和系统程序<ol><li>数据(通用)寄存器:AX、BX、CX、DX等</li><li>地址寄存器:索引(SI、DI)、栈指针(SP、BP)、段地址(CS、DS、SS、ES)、页表寄存器等</li></ol></li></ol><h3 id="1-2-2-控制和状态寄存器"><a href="#1-2-2-控制和状态寄存器" class="headerlink" title="1.2.2. 控制和状态寄存器"></a>1.2.2. 控制和状态寄存器</h3><ol><li>控制和状态寄存器用于控制处理器的操作，主要是被具有特权的操作系统程序使用，以控制程序的执行<ol><li>程序计数器PC：存储将取指令的地址</li><li>指令寄存器IR：存储最近使用的指令</li><li>条件码CC：CPU为指令操作结果设置的位，标志正&#x2F;负&#x2F;零&#x2F;溢出等结果</li></ol></li><li>标志位</li></ol><table><thead><tr><th>位</th><th>描述</th></tr></thead><tbody><tr><td>中断位</td><td>是否有中断发生了，中断源是什么</td></tr><tr><td>中断允许位</td><td>表示目前是否响应中断</td></tr><tr><td>中断屏蔽位</td><td>中断发生了，中断响应了，我们要不要屏蔽中断</td></tr><tr><td>处理器模式位</td><td>现在处理器是处于何种模式</td></tr><tr><td>内存保护位</td><td>对这段内存是只读还是读写还是不可操作</td></tr></tbody></table><h3 id="1-2-3-程序状态字PSW"><a href="#1-2-3-程序状态字PSW" class="headerlink" title="1.2.3. 程序状态字PSW"></a>1.2.3. 程序状态字PSW</h3><ol><li>PSW既是操作系统的概念，指记录当前程序运行的<strong>动态信息</strong>，通常包含：<ol><li>程序计数器、指令寄存器、条件码</li><li>中断字、中断允许&#x2F;禁止、中断屏蔽、处理器模式、内存保护、调试控制</li></ol></li><li>PSW也是计算机系统的<strong>寄存器</strong><ol><li>通常设置一组控制与状态寄存器</li><li>也可以专设一个PSW寄存器</li></ol></li><li>标志划分为三组:<strong>状态标志、控制标志和系统标志</strong>(更多见P58)<ol><li>状态标志：使得一条指令的执行结果影响其后指令的执行，比如溢出等标志</li><li>控制指令：控制操作系统行为，比如模式转换等。</li><li>系统标志：与进程管理有关，用于保护模式。</li></ol></li></ol><h1 id="2-指令与处理器模式"><a href="#2-指令与处理器模式" class="headerlink" title="2. 指令与处理器模式"></a>2. 指令与处理器模式</h1><h2 id="2-1-机器指令"><a href="#2-1-机器指令" class="headerlink" title="2.1. 机器指令"></a>2.1. 机器指令</h2><ol><li><strong>机器指令</strong>是计算机系统执行的基本命令，是中央处理器执行的基本单位。</li><li>指令由一个或多个字节组成，包括操作码字段、一个或多个操作数地址字段、以及一些表征机器状态的状态字以及特征码。</li><li>指令完成各种算术逻辑运算、数据传输、控制流跳转。</li></ol><h2 id="2-2-指令执行过程"><a href="#2-2-指令执行过程" class="headerlink" title="2.2. 指令执行过程"></a>2.2. 指令执行过程</h2><ol><li>CPU根据PC<strong>取出指令</strong>，放入IR，并对指令译码，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行</li><li><strong>一种</strong>指令执行步骤如下：(还有更加细分，这只是一种示例)<ol><li>取指：根据PC从存储器或高速缓冲存储器中取指令到IR</li><li>解码：解译IR中的指令来决定其执行行为</li><li>执行：连接到CPU部件，执行运算，产生结果并写回，同时在CC里设置运算结论标志；跳转指令操作PC，其他指令递增PC值</li></ol></li></ol><h2 id="2-3-指令执行周期与指令流水线"><a href="#2-3-指令执行周期与指令流水线" class="headerlink" title="2.3. 指令执行周期与指令流水线"></a>2.3. 指令执行周期与指令流水线</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/4.png"></p><blockquote><p>现在的操作系统不是顺序地完成指令执行，而是选择使用指令流水线的方式来执行指令</p></blockquote><h2 id="2-4-特权指令与非特权指令"><a href="#2-4-特权指令与非特权指令" class="headerlink" title="2.4. 特权指令与非特权指令"></a>2.4. 特权指令与非特权指令</h2><blockquote><p>用户程序并非能够使用全部机器指令，那些与计算机核心资源相关的特殊指令会被保护</p></blockquote><ol><li>比如：启动I&#x2F;O指令(启动打印机，打印文件会细分成按照行打印，可能导致逻辑上的失败)、置PC指令(多道程序调用)等等</li><li>核心资源相关的指令只能被操作系统程序使用(作为特权指令，不允许在用户态使用这些命令)</li></ol><h3 id="2-4-1-特权指令"><a href="#2-4-1-特权指令" class="headerlink" title="2.4.1. 特权指令"></a>2.4.1. 特权指令</h3><ol><li>只有操作系统本身可以使用的指令，在内核态才能调用的命令，不仅仅影响运行程序本身，还会干扰其他程序及操作系统。</li><li>比如改变机器状态、修改寄存器值、置中断屏蔽位、加载程序状态字等。</li><li>如果应用程序执行特权指令则会导致非法执行而产生保护中断，进而转向操作系统的”用户非法执行特权指令”的异常处理程序处理。</li></ol><h3 id="2-4-2-非特权指令"><a href="#2-4-2-非特权指令" class="headerlink" title="2.4.2. 非特权指令"></a>2.4.2. 非特权指令</h3><ol><li>所有的用户程序都能够使用的指令，在用户态和内核态都可以调用的命令。</li><li>非特权命令在目态和管态的情况下都能工作。</li></ol><h2 id="2-5-处理器模式"><a href="#2-5-处理器模式" class="headerlink" title="2.5. 处理器模式"></a>2.5. 处理器模式</h2><ol><li>计算机通过设置处理器模式实现特权指令管理</li><li>计算器一般设置0、1、2、3等四种运行模式(保护级别)<ul><li>0:内核级，操作系统内核，可以执行全部指令，包括中断处理、处理I&#x2F;O操作等命令</li><li>1:系统调用级，执行系统调用，获得特定的和受保护的程序服务</li><li>2:共享库级，可以多个运行进程共享，允许调用库函数，读取但不修改相关数据。</li><li>3:用户程序，只能执行非特权指令，收到的保护最少</li></ul></li><li>0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集</li><li>一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式</li><li>处理器模式是由处理器模式位决定的。</li></ol><h2 id="2-6-处理器模式切换"><a href="#2-6-处理器模式切换" class="headerlink" title="2.6. 处理器模式切换"></a>2.6. 处理器模式切换</h2><ol><li>简称模式切换，包括<code>用户模式-&gt;内核模式</code>和<code>内核模式-&gt;用户模式</code>的两种切换。</li><li><strong>中断、异常或系统异常</strong>等事件导致用户程序向OS内核切换，触发：<code>用户模式-&gt;内核模式</code>，以下三种方式是唯一能触发的方式:<ol><li>程序请求操作系统服务，执行系统调用</li><li>程序运行时发生异常(如发生程序性中断，或者目态执行特权指令)</li><li>程序运行时发生并响应中断(一般是I&#x2F;O中断)</li></ol></li><li>我们可以认为中断和异常是用户态到内核态转换的仅有途径。</li><li>OS内核处理完成后，调用中断返回指令(如Intel的iret)触发：<code>内核模式-&gt;用户模式</code>，操作系统将控制权转交给应用进程。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/31.png"></p><h2 id="2-7-系统调用示例"><a href="#2-7-系统调用示例" class="headerlink" title="2.7. 系统调用示例"></a>2.7. 系统调用示例</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/29.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/30.png"></th></tr></thead></table><h1 id="3-栈空间"><a href="#3-栈空间" class="headerlink" title="3. 栈空间"></a>3. 栈空间</h1><h2 id="3-1-用户栈"><a href="#3-1-用户栈" class="headerlink" title="3.1. 用户栈"></a>3.1. 用户栈</h2><ol><li>用户栈是<strong>用户进程</strong>空间中开辟的一块区域，用于保存应用程序的子程序(函数)间相互调用的参数、返回值、返回点以及子程序的局部变量。</li><li>如果只有用户栈，没有核心栈，那么操作系统则很难对核心栈的数据提供相应的保护措施。</li></ol><h2 id="3-2-核心栈"><a href="#3-2-核心栈" class="headerlink" title="3.2. 核心栈"></a>3.2. 核心栈</h2><ol><li>核心栈也叫系统栈或内核栈，是内存中属于操作系统空间的一块区域，其用途包含以下两种:<ol><li>保存中断现场，嵌套中断</li><li>保存操作系统程序(函数)间相互调用的参数、返回值、返回点以及程序局部变量。</li></ol></li><li><strong>每个进程</strong>有一个核心栈:可读可写不可执行，大小有限</li><li>硬件栈指针只有一个</li></ol><h1 id="4-中断"><a href="#4-中断" class="headerlink" title="4. 中断"></a>4. 中断</h1><p><a href="https://blog.csdn.net/yusiguyuan/article/details/23517819">(21条消息) linux内核分析–中断的分类_鱼思故渊的博客-CSDN博客</a></p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/image-20230313103109912-1680145370392.png" alt="image-20230313103109912"></p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/image-20230313103143600-1680145370393.png" alt="image-20230313103143600"></p><h2 id="4-1-中断、异常和系统异常"><a href="#4-1-中断、异常和系统异常" class="headerlink" title="4.1. 中断、异常和系统异常"></a>4.1. 中断、异常和系统异常</h2><ol><li><strong>广义的中断</strong>是指程序执行过程中，遇到急需处理的事件时，暂时<strong>中止CPU</strong>上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程</li><li><strong>狭义的中断</strong>指来源于<strong>处理器之外的中断事件</strong>，即与当前运行指令无关的中断事件，如I&#x2F;O中断(为打印机结束后进行善后)、时钟中断(计算机系统计时，多一段时间就要更新系统时间)、外部信号中断(关机)等</li><li><strong>异常</strong>指<strong>当前运行指令引起的中断事件</strong>，如地址异常(访问其他程序的内存、读写没有权利读写的内存、虚拟地址的异常)、算术异常(数字溢出、对0除法)、处理器硬件故障(奇偶校验位错误)等</li><li><strong>来自于CPU内部的广义中断事件</strong>我们称之为<strong>异常</strong>，和狭义的中断构成了广义的中断。</li><li><strong>系统异常</strong>指<strong>执行陷入指令而触发系统调用引起的中断事件</strong>，如请求设备、请求I&#x2F;O、创建进程等，与硬件无关(通过系统异常请求服务)，系统异常可以被认为是异常中的一类</li></ol><h2 id="4-2-操作系统与中断"><a href="#4-2-操作系统与中断" class="headerlink" title="4.2. 操作系统与中断"></a>4.2. 操作系统与中断</h2><ol><li>操作系统是<strong>中断驱动</strong>的；换言之，<strong>中断是激活操作系统的唯一方式</strong>。</li><li>操作系统要求计算机硬件系统为其设置相应的<strong>中断激活的硬件机制</strong>，再配合操作系统的内核程序共同完成中断驱动方式，这个是操作系统实现的<strong>最根本的基础</strong>，中断处理需要借助硬件电路</li></ol><h2 id="4-3-中断源分类"><a href="#4-3-中断源分类" class="headerlink" title="4.3. 中断源分类"></a>4.3. 中断源分类</h2><p>由硬件发出或产生的中断称为硬中断，按硬中断事件的来源和实现手段可将终端划分为外中断和内中断。</p><h3 id="4-3-1-外中断"><a href="#4-3-1-外中断" class="headerlink" title="4.3.1. 外中断"></a>4.3.1. 外中断</h3><ol><li>外中断又称中断或异步中断，是指来自处理器之外的中断信号，包括时钟中断、键盘中断、它机中断和外部设备等、</li><li>外中断又可以分为可屏蔽中断和不可屏蔽中断，各个中断具有不同中断优先级。</li></ol><h3 id="4-3-2-内中断"><a href="#4-3-2-内中断" class="headerlink" title="4.3.2. 内中断"></a>4.3.2. 内中断</h3><ol><li>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于程序执行过程中，发现与当前指令相关的、不正常或错误的时间，内中断可分为:<ol><li>访管中断，由执行系统调用而引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点溢出等。</li></ol></li></ol><h2 id="4-4-中断和异常区别-P60"><a href="#4-4-中断和异常区别-P60" class="headerlink" title="4.4. 中断和异常区别(P60)"></a>4.4. 中断和异常区别(P60)</h2><table><thead><tr><th>中断</th><th>异常</th></tr></thead><tbody><tr><td>CPU异步</td><td>CPU同步</td></tr><tr><td>内核态、用户态</td><td>大部分在用户态，内核态唯一的异常是”缺页异常”</td></tr><tr><td>一般中断处理程序提供的服务不是当前进程需要的</td><td>是当前的进程需要的</td></tr><tr><td>快速处理，不可以被打断</td><td>可以被阻塞</td></tr><tr><td>允许嵌套</td><td>大多为一重等</td></tr><tr><td>不可以被异常打断</td><td>可以被中断中断</td></tr></tbody></table><h1 id="5-中断事件处理原则"><a href="#5-中断事件处理原则" class="headerlink" title="5. 中断事件处理原则"></a>5. 中断事件处理原则</h1><h2 id="5-1-中断源-处理器硬件故障中断事件-硬中断"><a href="#5-1-中断源-处理器硬件故障中断事件-硬中断" class="headerlink" title="5.1. 中断源:处理器硬件故障中断事件(硬中断)"></a>5.1. 中断源:处理器硬件故障中断事件(硬中断)</h2><ol><li>由处理器、内存储器、总线等硬件故障引起，除了极少类的校验错误可以恢复以外，是<strong>非常严重</strong>的中断。</li><li>处理原则为：保护现场，停止设备，停止CPU，向操作员报告，等待人工干预</li><li>电脑会配置一个小电容保证尽可能较少硬件损伤</li></ol><h2 id="5-2-中断源-程序性中断事件"><a href="#5-2-中断源-程序性中断事件" class="headerlink" title="5.2. 中断源:程序性中断事件"></a>5.2. 中断源:程序性中断事件</h2><blockquote><p>处理器执行机器指令引起</p></blockquote><ol><li>语法错误：由编译程序发现</li><li>逻辑错误：由测试程序发现</li><li>程序运行过程中产生异常<ol><li>除数为零、操作数溢出等算术异常：简单处理，报告用户；也可以由用户编写中断续元程序处理</li><li>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程</li><li>终止进程指令：终止进程</li><li>虚拟地址异常：指令和数据不在内存当中，调整内存后重新执行指令</li></ol></li></ol><h2 id="5-3-中断源-I-x2F-O中断事件"><a href="#5-3-中断源-I-x2F-O中断事件" class="headerlink" title="5.3. 中断源:I&#x2F;O中断事件"></a>5.3. 中断源:I&#x2F;O中断事件</h2><ol><li>来源于外围设备报告I&#x2F;O状态的中断事件<ol><li>I&#x2F;O完成：调整进程状态，释放等待进程</li><li>I&#x2F;O出错：先向设备发命令索取状态字，分析产生故障的确切原因，再执行复执或请求人工干预，</li><li>I&#x2F;O异常：等待人工干预，缺纸，人工加纸</li><li>设备报道或设备结束:表示有设备接入可供使用或设备断开暂停使用</li></ol></li><li>狭义中断事件</li></ol><h2 id="5-4-中断源-自愿性中断事件-访管中断"><a href="#5-4-中断源-自愿性中断事件-访管中断" class="headerlink" title="5.4. 中断源:自愿性中断事件(访管中断)"></a>5.4. 中断源:自愿性中断事件(访管中断)</h2><ol><li>处理器执行陷入指令请求OS服务引起；在操作系统中，它一般又被称作系统调用，比如请求分配外设、请求I&#x2F;O等等</li><li>处理流程是：<ol><li>程序执行访管指令，并通过适当方式指明系统调用号。</li><li>通过中断机制进入访管中断处理程序，现场信息被保护到<strong>核心栈</strong>，按功能号实现跳转。</li><li>通过系统调用入口地址表找到对应中断服务历程的入口地址</li><li>执行终端服务例程</li></ol></li></ol><h2 id="5-5-中断源-外部中断事件"><a href="#5-5-中断源-外部中断事件" class="headerlink" title="5.5. 中断源:外部中断事件"></a>5.5. 中断源:外部中断事件</h2><ol><li>由外围设备发出的信号引起的中断事件<ol><li>时钟中断、间隔时钟中断：记时与时间片处理，最常见</li><li>设备报到与结束中断：调整设备表</li><li>键盘&#x2F;鼠标信号中断：根据信号作出相应反应</li><li>关机&#x2F;重启动中断：写回文件，停止设备与CPU</li></ol></li><li>时钟可以分为绝对时钟和间隔时钟<ol><li>绝对时钟:固定周期发出中断请求</li><li>间隔时钟:每个时间切换点,将间隔时钟的内容减1，其值为0的时候，产生间隔时钟中断。</li></ol></li><li>时钟间隔定时器<ol><li>real:按照实际经过的时间计时</li><li>virtual:仅在用户态下执行才计时</li><li>profile:进程执行用户态或用户态时都计时，当计时到达发送信号</li></ol></li></ol><h1 id="6-中断系统"><a href="#6-中断系统" class="headerlink" title="6. 中断系统"></a>6. 中断系统</h1><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/image-20230313104119877-1680145370393.png" alt="image-20230313104119877"></p><ol><li>中断系统是计算机系统中响应和处理中断的系统，包括硬件子系统和软件子系统两部分<ol><li><strong>中断响应</strong>由硬件子系统完成</li><li><strong>中断处理</strong>由软件子系统完成</li></ol></li><li>中断系统是操作系统的基础，中断系统也是软硬件协同系统的典型例子</li></ol><h2 id="6-1-中断响应处理与指令执行周期"><a href="#6-1-中断响应处理与指令执行周期" class="headerlink" title="6.1. 中断响应处理与指令执行周期"></a>6.1. 中断响应处理与指令执行周期</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/11.png"></p><blockquote><p>在指令执行周期最后增加一个微操作，以响应中断，CPU在完成执行阶段后，如果允许中断，则进入中断阶段</p><p>注意是指令周期的最后检查中断</p></blockquote><h2 id="6-2-中断装置"><a href="#6-2-中断装置" class="headerlink" title="6.2. 中断装置"></a>6.2. 中断装置</h2><ol><li>计算机系统中<strong>发现并响应中断&#x2F;异常</strong>的硬件装置称为中断装置</li><li>由于中断源的多样性，硬件实现的中断装置有多种，分别处理不同类型的中断</li><li>这些中断装置因计算机而异，通常有：<ol><li>处理器外的中断：由<strong>中断控制器</strong>发现和响应</li><li>处理器内的异常：由<strong>指令的控制逻辑和实现线路</strong>发现和响应，相应机制称为<strong>陷阱</strong></li><li>请求OS服务的系统异常：处理器执行<strong>陷入指令</strong>时直接触发，相应机制称为<strong>系统陷阱</strong></li></ol></li></ol><h2 id="6-3-中断控制器"><a href="#6-3-中断控制器" class="headerlink" title="6.3. 中断控制器"></a>6.3. 中断控制器</h2><ol><li><strong>中断控制器</strong>：CPU中的一个控制部件，包括中断控制逻辑线路和中断寄存器，中断控制器会记录中断是<strong>来自哪里</strong><ol><li>狭义中断:(异步过程)外部设备向其发出中断请求IRQ，在中断寄存器中设置已发生的中断</li><li>(同步过程)指令处理结束前，会检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作的顺序，引出操作系统中的中断处理程序</li></ol></li><li>狭义中断是异步进程，CPU正在做的事情和中断可能是两个不同部分</li></ol><h2 id="6-4-陷阱与系统陷阱"><a href="#6-4-陷阱与系统陷阱" class="headerlink" title="6.4. 陷阱与系统陷阱"></a>6.4. 陷阱与系统陷阱</h2><blockquote><p>陷阱与系统陷阱：指令的逻辑和实现线路的一部分</p></blockquote><ol><li>执行指令出现异常后，会根据异常情况转向操作系统的异常处理程序</li><li>出现虚拟地址异常后，需要重新执行指令，往往越过陷阱独立设置页面异常处理程序</li><li>执行陷入指令后，越过陷阱处理，触发系统陷阱，激活系统调用处理程序</li></ol><h2 id="6-5-中断程序的处理-amp-中断-x2F-异常响应过程"><a href="#6-5-中断程序的处理-amp-中断-x2F-异常响应过程" class="headerlink" title="6.5. 中断程序的处理&amp;中断&#x2F;异常响应过程"></a>6.5. 中断程序的处理&amp;中断&#x2F;异常响应过程</h2><ol><li>中断处理程序：操作系统处理中断事件的控制程序, 主要任务是处理<strong>中断事件和恢复正常</strong>操作。</li><li>是一个软件过程</li><li>中断&#x2F;异常响应过程<ol><li>发现中断源，提出中断请求(选择响应哪一个程序)<ol><li>发现中断寄存器中记录的中断</li><li>决定这些中断是否被屏蔽</li><li>当有多个要响应的中断源时，根据规定的优先级选择一个</li></ol></li><li>中断当前程序的执行(保护现场):保存当前程序的PSW(程序状态字)&#x2F;PC到核心栈</li><li>转向操作系统的中断处理程序:处理器状态已从用户态转换至内核态。</li><li>恢复现场:恢复原运行程序的PSW，重新返回中断点，以便执行后续指令。</li></ol></li></ol><h2 id="6-6-恢复正常操作"><a href="#6-6-恢复正常操作" class="headerlink" title="6.6. 恢复正常操作"></a>6.6. 恢复正常操作</h2><ol><li>情况一：对于某些中断，在处理完毕后，直接返回刚刚被中断的进程，比如计时中断。</li><li>情况二：对于其他一些中断，需要中断当前进程的运行，调整进程队列，启动进程调度，选择下一个执行的进程并恢复其执行，比如请求输入输出。</li><li>无论是哪个都是从内核态到用户态。</li></ol><h2 id="6-7-中断系统处理流程"><a href="#6-7-中断系统处理流程" class="headerlink" title="6.7. 中断系统处理流程"></a>6.7. 中断系统处理流程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/12.png"></p><ol><li>硬件设计受到操作系统的要求。</li><li>操作系统:大型软件系统，大型紧密结合软硬件设备的系统。</li></ol><h1 id="7-多中断的响应与处理"><a href="#7-多中断的响应与处理" class="headerlink" title="7. 多中断的响应与处理"></a>7. 多中断的响应与处理</h1><h2 id="7-1-中断优先级"><a href="#7-1-中断优先级" class="headerlink" title="7.1. 中断优先级"></a>7.1. 中断优先级</h2><ol><li>当计算机同时检测到多个中断时, 中断装置响应中断的顺序。</li><li>有优先度的响应中断：将紧迫程度相当的中断源归为同一级别，将紧迫程度差距较大的中断源归为不同级别。</li><li>一种可能的处理次序：(对几十个人使用的大型计算机系统很合理)，可以借助软硬件分别来完成实现。<ol><li>处理机硬件故障中断事件。</li><li>自愿性中断事件。</li><li>程序性中断事件。</li><li>时钟中断等外部中断事件。</li><li>输入输出中断事件。</li><li>重启动和关机中断事件。</li></ol></li><li>不同类型的操作系统有不同的中断优先级:PC做出关机操作表示放弃当前的所有的操作，所以重启动和关机中断是优先级最高的中断。</li></ol><h2 id="7-2-中断屏蔽"><a href="#7-2-中断屏蔽" class="headerlink" title="7.2. 中断屏蔽"></a>7.2. 中断屏蔽</h2><ol><li>当计算机检测到中断时, 中断装置通过中断屏蔽位决定是否响应已发生的中断。</li><li>有选择的响应中断：由计算机决定。<ol><li>延迟或禁止某些中断的响应以避免共享数据结构受到破坏。</li><li>协调中断响应与终端处理的关系，保证优先级顺序。</li><li>防止同级中断互相干扰。</li></ol></li><li>计算机均配置可编程中断控制器。</li></ol><h2 id="7-3-中断的嵌套处理"><a href="#7-3-中断的嵌套处理" class="headerlink" title="7.3. 中断的嵌套处理"></a>7.3. 中断的嵌套处理</h2><ol><li>当计算机响应中断后，在中断处理过程中，可以再响应其他中断</li><li>操作系统是性能攸关的程序系统，且中断响应处理有硬件要求，考虑系统效率和实现代价问题，中断的嵌套处理应限制在一定层数内，如3层</li><li>中断的嵌套处理改变中断处理次序，<strong>先响应的有可能后处理</strong></li></ol><h2 id="7-4-多中断的响应与处理"><a href="#7-4-多中断的响应与处理" class="headerlink" title="7.4. 多中断的响应与处理"></a>7.4. 多中断的响应与处理</h2><blockquote><p>决定了中断处理次序的因素</p></blockquote><ol><li>中断<strong>屏蔽</strong>可以使中断装置不响应某些中断</li><li>中断<strong>优先级</strong>决定了中断装置响应中断的次序</li><li>中断可以<strong>嵌套</strong>处理, 但嵌套的层数应有限制</li><li>中断的嵌套处理改变了中断处理的次序</li></ol><h2 id="7-5-多重中断处理"><a href="#7-5-多重中断处理" class="headerlink" title="7.5. 多重中断处理"></a>7.5. 多重中断处理</h2><h3 id="7-5-1-顺序中断处理-串行处理"><a href="#7-5-1-顺序中断处理-串行处理" class="headerlink" title="7.5.1. 顺序中断处理(串行处理)"></a>7.5.1. 顺序中断处理(串行处理)</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/2.png"></p><blockquote><p>X、Y两个中断同时发生，如下图所以，系统先响应X，屏蔽Y，待X响应完成后，系统再响应并处理Y</p></blockquote><h3 id="7-5-2-嵌套中断处理-嵌套处理"><a href="#7-5-2-嵌套中断处理-嵌套处理" class="headerlink" title="7.5.2. 嵌套中断处理(嵌套处理)"></a>7.5.2. 嵌套中断处理(嵌套处理)</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/3.png"></p><blockquote><p>X、Y两个中断同时发生，根据中断有限级，先响应中断X，因为没有屏蔽Y，则响应并处理Y，处理Y完成后，再处理X。</p></blockquote><h3 id="7-5-3-即时处理"><a href="#7-5-3-即时处理" class="headerlink" title="7.5.3. 即时处理"></a>7.5.3. 即时处理</h3><ol><li>在运行中断处理程序时，如果出现程序性中断事件，在一般情况下，表明此时中断程序有异常，应对其立即响应并处理。</li></ol><h2 id="7-6-中断处理的例子：Linux内核处理流程"><a href="#7-6-中断处理的例子：Linux内核处理流程" class="headerlink" title="7.6. 中断处理的例子：Linux内核处理流程"></a>7.6. 中断处理的例子：Linux内核处理流程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/25.png"></p><ol><li>中断信号源:中断向量<ol><li>中断，分为所有外部设备产生的屏蔽中断请求，和硬件故障等紧迫时间引发的非屏蔽中断。</li><li>异常:CPU发出的中断信号，主要有故障、陷阱、终止和编程异常等</li></ol></li><li>更多见P66-71页</li></ol><h1 id="8-进程及其状态"><a href="#8-进程及其状态" class="headerlink" title="8. 进程及其状态"></a>8. 进程及其状态</h1><h2 id="8-1-进程的提出"><a href="#8-1-进程的提出" class="headerlink" title="8.1. 进程的提出"></a>8.1. 进程的提出</h2><ol><li>操作系统必须全方位地管理计算机系统中运行的程序。因此，操作系统为正在运行程序建立一个管理实体:<strong>进程</strong></li></ol><h2 id="8-2-进程的概念"><a href="#8-2-进程的概念" class="headerlink" title="8.2. 进程的概念"></a>8.2. 进程的概念</h2><ol><li><strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。<ol><li>具有一定独立功能的程序:进程是相对独立的</li><li>关于某个数据集合:对于不同数据集合的操作不是同一个进程。</li><li>一次运行活动:有生命周期</li></ol></li><li><strong>进程是操作系统进行资源分配和调度的一个独立单位</strong>:这只限于单线程单进程的情况下<ol><li>资源分配:除了CPU之外的资源的分配，比如内存和外设等</li><li>单线程情况下，进程的资源分配和调度就是处理器的。</li><li>调度特指处理器的调度</li></ol></li><li>有的将进程叫做process，Linux以及一些企业中，把进程称为Task。</li><li>进程可以看为可运行程序加载到内存，配合相应的数据集，在操作系统中的一个实例，程序可以多次被加载进入成为进程。</li></ol><h2 id="8-3-进程的属性"><a href="#8-3-进程的属性" class="headerlink" title="8.3. 进程的属性"></a>8.3. 进程的属性</h2><ol><li><strong>动态性</strong>:进程是程序在数据结合上的一次执行过程，是动态概念，同时它有声明周期，而程序是一组有序指令序列，是静态概念，所以程序作为系统中的一种资源是永久存在的。</li><li><strong>共享性</strong>:同一程序同时运行于不同数据集合上时都是不同的进程，即不同的进程可以运行相同的程序。</li><li><strong>独立性</strong>:每个进程是操作系统中的一个独立实体。有自己的虚存空间、程序计数器和内部状态.</li><li><strong>制约性</strong>:进程因共享资源或协同工作产生相互制约关系，造成进程执行速度的不可预测性，必须对进程的执行次序或相对执行速度予以协调。</li><li><strong>并发性</strong>:多个进程的执行在时间上可以重叠。</li></ol><h2 id="8-4-进程的组成"><a href="#8-4-进程的组成" class="headerlink" title="8.4. 进程的组成"></a>8.4. 进程的组成</h2><blockquote><p>一个进程包括五个实体部分，分别是：</p></blockquote><ol><li>(OS管理运行程序的)数据结构P</li><li>(运行程序的)内存代码C</li><li>(运行程序的)内存数据D</li><li>(运行程序的)通用寄存器信息R</li><li>(OS控制程序执行的)程序状态字信息PSW</li></ol><h2 id="8-5-单线程结构进程和多线程结构进程"><a href="#8-5-单线程结构进程和多线程结构进程" class="headerlink" title="8.5. 单线程结构进程和多线程结构进程"></a>8.5. 单线程结构进程和多线程结构进程</h2><ol><li>单线程结构进程:进程级别，负责完成资源分配和CPU调度。</li><li>多线程结构进程:线程级别，负责完成资源分配(进程完成)和CPU调度(代表一个执行流)，并且一个进程中可以包含很多线程。</li><li>操作系统最开始设计的时候并没有设计多线程。</li></ol><h2 id="8-6-进程举例"><a href="#8-6-进程举例" class="headerlink" title="8.6. 进程举例"></a>8.6. 进程举例</h2><ol><li>以下的程序与数据集都是内存级的。</li><li>不同时段针对同一个外存数据文件运行同一个外存程序文件意味着完全不同的(P, C, D, R, Psw)</li></ol><h3 id="8-6-1-无关进程"><a href="#8-6-1-无关进程" class="headerlink" title="8.6.1. 无关进程"></a>8.6.1. 无关进程</h3><p>不同程序在不同数据集上运行：构成两个无关进程</p><h3 id="8-6-2-共享数据的交往进程"><a href="#8-6-2-共享数据的交往进程" class="headerlink" title="8.6.2. 共享数据的交往进程"></a>8.6.2. 共享数据的交往进程</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/5.png"></p><blockquote><p>不同程序在相同数据集上运行：构成两个共享数据的交往进程</p></blockquote><h3 id="8-6-3-共享代码的无关进程"><a href="#8-6-3-共享代码的无关进程" class="headerlink" title="8.6.3. 共享代码的无关进程"></a>8.6.3. 共享代码的无关进程</h3><ol><li>相同代码在不同数据集上运行：构成两个共享代码的无关进程</li><li>共享的代码称为<strong>可再入</strong>程序，如编辑器<strong>可再入程序</strong>是<strong>纯代码</strong>的，可再入程序必须是纯代码的</li></ol><h3 id="8-6-4-共享代码和数据的进程"><a href="#8-6-4-共享代码和数据的进程" class="headerlink" title="8.6.4. 共享代码和数据的进程"></a>8.6.4. 共享代码和数据的进程</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/6.png"></p><blockquote><p>可以共享代码或者共享数据</p></blockquote><h1 id="9-进程状态和转换"><a href="#9-进程状态和转换" class="headerlink" title="9. 进程状态和转换"></a>9. 进程状态和转换</h1><h2 id="9-1-进程三态模型"><a href="#9-1-进程三态模型" class="headerlink" title="9.1. 进程三态模型"></a>9.1. 进程三态模型</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/7.png"></p><ol><li>只要操作系统支持多道程序设计，就必须要设计进程转换模型来管理，必须实现<strong>三个进程状态和四个跳转关系</strong>，进程状态转换一定有<strong>内核</strong>的参与。</li><li>运行被中断进程时需要找到被中断时的信息并恢复。</li></ol><h3 id="9-1-1-三种状态"><a href="#9-1-1-三种状态" class="headerlink" title="9.1.1. 三种状态"></a>9.1.1. 三种状态</h3><ol><li><strong>运行态</strong>:进程占有处理器正在运行的状态。</li><li><strong>就绪态</strong>:进程具备运行条件，等待系统分配处理器以便运行的状态，面向调度的，处理器只会挑选就绪态进程(就绪队列进程)</li><li><strong>等待态</strong>:又称阻塞态或睡眠态，指进程不具备运行条件，正在等待某个事件完成的状态，暂时被剥夺处理机会。</li><li>处于运行态个数不能大于处理器个数。</li><li>进程创建后一般是处于就绪态</li><li>单线程， 处理器的调度体现在(3)</li></ol><h3 id="9-1-2-四种状态转换"><a href="#9-1-2-四种状态转换" class="headerlink" title="9.1.2. 四种状态转换"></a>9.1.2. 四种状态转换</h3><ol><li>运行态$\rightarrow$等待态：等待资源、I&#x2F;O、信号量</li><li>等待态$\rightarrow$就绪态：资源满足、I&#x2F;O结束、信号量完成</li><li>运行态$\rightarrow$就绪态：运行时间片到(倒计时到，不缺少其他东西，只缺少CPU，退回就绪态)、有更高优先权进程，低级调度问题</li><li>以上四个状态转换，一个不能少，一个也不能多，其他的转换不存在的原因如下：<ol><li>没有就绪态到等待态:到等待态需要内核参与。</li><li>没有等待态到运行态:等待的资源还没有就绪，无法进入运行态。</li></ol></li></ol><h3 id="9-1-3-时间片与进程转换"><a href="#9-1-3-时间片与进程转换" class="headerlink" title="9.1.3. 时间片与进程转换"></a>9.1.3. 时间片与进程转换</h3><ol><li>时间片用完，计算没有做完，被抢占的进程<code>运行态-&gt;就绪态</code>：启动内核的处理器调度算法.</li><li>时间片内，用户进程发生中断或系统调用，<code>运行态-&gt;等待态</code></li><li>时间片内，用户进程完成全部计算完成退出系统，<code>运行态-&gt;终止态</code>，激活内核，时间片被撤销。</li></ol><h3 id="9-1-4-进程三态模型总结与扩展"><a href="#9-1-4-进程三态模型总结与扩展" class="headerlink" title="9.1.4. 进程三态模型总结与扩展"></a>9.1.4. 进程三态模型总结与扩展</h3><ol><li>进程映像定义其数据结构和存储结构</li><li>状态转化模型(队列模型)定义其生命周期和状态转换</li><li>然后围绕以上两部分开发出相应的操作和算法</li><li>进程状态和模型与信号量同样相关，后续深入讨论。</li></ol><h2 id="9-2-进程七态模型-P74"><a href="#9-2-进程七态模型-P74" class="headerlink" title="9.2. 进程七态模型(P74)"></a>9.2. 进程七态模型(P74)</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/26.png"></p><h3 id="9-2-1-新添加的状态"><a href="#9-2-1-新添加的状态" class="headerlink" title="9.2.1. 新添加的状态"></a>9.2.1. 新添加的状态</h3><ol><li><strong>新建态</strong>:对应于进程被创建的状态，尚未进入就绪队列，创建进程的两个步骤<ol><li>为新进程分配所需资源和建立必要的管理信息</li><li>设置进程为就绪态，等待被调度执行</li></ol></li><li>终止态:<ol><li>进程完成认为到达正常结束点</li><li>出现无法克服的错误而异常终止</li><li>操作系统及有终止权的进程所终止时所处的状态，处于终止态的进程不再被调度执行</li><li>下一步就将被系统撤销，最终从系统中消失。</li></ol></li><li>挂起就绪态:表明进程具备运行条件，但目前在外存中，只有它被对换到内存才能调度执行。</li><li>挂起等待态:表明进程正在等待某一个事件发生且在外存中。</li></ol><h3 id="9-2-2-进程挂起的源头"><a href="#9-2-2-进程挂起的源头" class="headerlink" title="9.2.2. 进程挂起的源头"></a>9.2.2. 进程挂起的源头</h3><ol><li>到目前为止:随着不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起，对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度，起到平滑系统负荷的目的；也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再接触挂起并恢复进程运行。</li><li>进程挂起的原因是多种多样的。</li></ol><h2 id="9-3-进程挂起"><a href="#9-3-进程挂起" class="headerlink" title="9.3. 进程挂起"></a>9.3. 进程挂起</h2><h3 id="9-3-1-进程挂起的概念"><a href="#9-3-1-进程挂起的概念" class="headerlink" title="9.3.1. 进程挂起的概念"></a>9.3.1. 进程挂起的概念</h3><ol><li>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况</li><li>运行资源不足表现为<strong>性能低</strong>和<strong>死锁</strong>两种情况。</li><li>解决办法：剥夺某些进程的<strong>内存及其他资源</strong>，调入OS管理的<strong>对换区</strong>，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行，这就是<strong>进程挂起</strong></li><li>挂起态与等待态有着本质区别<ol><li>进程挂起:<strong>没有任何资源</strong></li><li>进程等待:<strong>占有已申请到的资源处于等待</strong></li></ol></li><li>结束挂起状态的命令只能由<strong>操作系统和父进程</strong>发出。</li></ol><h3 id="9-3-2-进程挂起的选择与恢复"><a href="#9-3-2-进程挂起的选择与恢复" class="headerlink" title="9.3.2. 进程挂起的选择与恢复"></a>9.3.2. 进程挂起的选择与恢复</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/8.png"></p><ol><li>挂起的选择：<ol><li>一般选择<strong>等待态</strong>进程进入<strong>挂起等待态</strong></li><li>也可选择<strong>就绪态</strong>进程进入<strong>挂起就绪态</strong></li><li><strong>运行态</strong>进程还可以挂起自己</li></ol></li><li>挂起的恢复<ol><li>等待事件结束后，<strong>挂起等待态</strong>进入<strong>挂起就绪态</strong></li><li>一般选择<strong>挂起就绪态</strong>进程予以恢复</li><li>操作系统极其空闲才会选择调入<strong>挂起等待态</strong>的进程</li></ol></li></ol><h3 id="9-3-3-挂起进程的特点"><a href="#9-3-3-挂起进程的特点" class="headerlink" title="9.3.3. 挂起进程的特点"></a>9.3.3. 挂起进程的特点</h3><ol><li>进程不能被立即执行</li><li>进程可能会有等待事件，但是等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li><li>由于操作系统、父进程或进程自身阻止其运行</li></ol><h2 id="9-4-补充：SVR4-进程状态模型"><a href="#9-4-补充：SVR4-进程状态模型" class="headerlink" title="9.4. 补充：SVR4 进程状态模型"></a>9.4. 补充：SVR4 进程状态模型</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/33.png"></p><blockquote><p>preempted:抢占，虚线表示合为一体。</p></blockquote><h1 id="10-进程的描述与组成"><a href="#10-进程的描述与组成" class="headerlink" title="10. 进程的描述与组成"></a>10. 进程的描述与组成</h1><p>进程的设计时要考虑进程的声明周期，从而引入三态模型</p><h2 id="10-1-进程映像，Process-Image"><a href="#10-1-进程映像，Process-Image" class="headerlink" title="10.1. 进程映像，Process Image"></a>10.1. 进程映像，Process Image</h2><ol><li>某一时刻进程的内容及其执行状态集合：<ol><li>进程控制块: 每个进程捆绑一个，保存进程的标识信息、现场信息和控制信息。进程创建时创建进程控制块，进程撤销时回收进程控制块，与进程一一对应。</li><li>进程程序块: 进程执行的程序空间，规定进程一次运行所应完成的功能。</li><li>进程数据块: 进程处理的数据空间，是进程的私有地址空间，包括各类私有数据、处理函数的用户栈和可修改的程序</li><li>进程核心栈: 每个进程捆绑一个，进程在<strong>内核模式</strong>下运行时使用的堆栈，中断或系统过程使用，保存函数调用的参数、局部变量和返回地址等。</li></ol></li><li>进程运行时如果遇到要执行操作系统内核函数，此时则保存应用程序的全部现场信息及其用户栈，使其不被内核程序破坏。而内核函数运行时使用进程的核心栈来放置工作信息。</li><li>进程映像是<strong>内存级</strong>的物理实体，又称为进程的内存映像</li><li>进程的内存映像示意图</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/14.png"></p><h2 id="10-2-进程控制块，Process-Control-Block，PCB，又称进程描述符"><a href="#10-2-进程控制块，Process-Control-Block，PCB，又称进程描述符" class="headerlink" title="10.2. 进程控制块，Process Control Block，PCB，又称进程描述符"></a>10.2. 进程控制块，Process Control Block，PCB，又称进程描述符</h2><ol><li>进程控制块PCB是OS用于记录和刻画<strong>进程状态及环境信息</strong>的数据结构，是进程存在的唯一标识，是操作系统刻画进程的执行状态及环境信息的数据结构，是进程动态特征的汇集，是操作系统掌握进程的唯一资料结构和进程调度的主要依据</li><li>包括标识信息、现场信息和控制信息。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/13.png"></p><h3 id="10-2-1-标识信息"><a href="#10-2-1-标识信息" class="headerlink" title="10.2.1. 标识信息"></a>10.2.1. 标识信息</h3><blockquote><p>用于存放唯一标识该进程的信息</p></blockquote><ol><li>系统分配的标识号</li><li>系统分配的进程组标识号</li><li>用户定义的进程名</li><li>用户定义的进程组名</li></ol><h3 id="10-2-2-现场信息"><a href="#10-2-2-现场信息" class="headerlink" title="10.2.2. 现场信息"></a>10.2.2. 现场信息</h3><blockquote><p>用于存放该进程运行时的处理器现场信息</p></blockquote><ol><li>用户可见寄存器内容：数据寄存器、地址寄存器</li><li>控制与状态寄存器内容：PC、IR、PSW</li><li>栈指针内容：核心栈与用户栈指针</li></ol><h3 id="10-2-3-控制信息"><a href="#10-2-3-控制信息" class="headerlink" title="10.2.3. 控制信息"></a>10.2.3. 控制信息</h3><blockquote><p>用于存放与管理、调度进程相关的信息</p></blockquote><ol><li>调度相关信息：状态、等待事件&#x2F;原因、优先级</li><li>进程组成信息：代码&#x2F;数据地址、外存映像地址</li><li>队列指引元：进程队列指针、父子兄弟进程指针</li><li>通信相关信息：消息队列、信号量、锁</li><li>进程特权信息：如内存访问权限、处理器特权</li><li>处理器使用信息：占用的处理器、时间片、处理器使用时间&#x2F;已执行总时间、记账信息</li><li>资源清单信息：如正占有的资源、已使用的资源</li></ol><h2 id="10-3-进程上下文，Process-context"><a href="#10-3-进程上下文，Process-context" class="headerlink" title="10.3. 进程上下文，Process context"></a>10.3. 进程上下文，Process context</h2><ol><li>进程的执行需要环境支持，包括CPU现场和Cache中的执行信息。</li><li>在操作系统中，进程物理实体和支持进程运行的环境合称<strong>进程上下文</strong>。</li><li>OS中的进程物理实体和支持进程运行的环境合成进程上下文，包括以下：<ol><li>用户级上下文：<ol><li>用户程序块(可执行的机器指令序列)</li><li>用户数据区(进程可访问的信息)</li><li>用户栈(存放函数调用过程中的信息)</li><li>用户共享内存(进程通信使用的内存区)</li><li>对换至磁盘的分段或页面仍然是用户级上下文的组成部分。</li></ol></li><li>寄存器上下文(存储在进程控制块中)：<ol><li>处理器状态寄存器(进程当前状态)</li><li>指令计数器(下一条该执行的指令地址)</li><li>PSW&#x2F;栈指针(指向用户栈或核心栈当前地址)</li><li>通用寄存器等</li></ol></li><li>系统级上下文<ol><li>PCB(Process Control Block，进程的状态)</li><li>内存区管理信息(进程页表或段表)</li><li>核心栈(进程内核态运行时的工作区)</li></ol></li></ol></li><li>进程上下文刻画了进程的执行情况</li></ol><h2 id="10-4-进程队列及其管理"><a href="#10-4-进程队列及其管理" class="headerlink" title="10.4. 进程队列及其管理"></a>10.4. 进程队列及其管理</h2><ol><li>进程队列分类<ol><li>运行队列：通常只有一个进程</li><li>等待(阻塞)队列:也是有机会被调入，他等待的资源或事件完成后，调入就绪队列。</li><li>就绪队列:从就绪队列中挑选进程调入运行，按照优先级或FCFS的原则排队</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/9.png"></p><blockquote><p>最后通过系统调用结束处理，进程实现的队列模型不适合使用堆栈(堆栈是先进后出的)</p></blockquote><ol start="2"><li>进程队列组织方式<ol><li>链接方式：采用单向链接或双向链接。</li><li>索引方式：利用索引表记录不同状态进程的PCB地址或在PCB表中的编号</li><li>核心是完成入队和出队操作</li><li>进程与资源调度围绕进程队列展开</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/32.png"></p><h1 id="11-进程的管理"><a href="#11-进程的管理" class="headerlink" title="11. 进程的管理"></a>11. 进程的管理</h1><h2 id="11-1-概念级的OS进程管理软件"><a href="#11-1-概念级的OS进程管理软件" class="headerlink" title="11.1. 概念级的OS进程管理软件"></a>11.1. 概念级的OS进程管理软件</h2><blockquote><p>关键的进程管理软件包括：</p></blockquote><ol><li>系统调用&#x2F;中断&#x2F;异常处理程序:</li><li>队列管理模块:操作系统用来管理进程控制块的信息，核心程序包，是操作系统实现进程管理的核心模块</li><li>进程控制程序:操作系统用于控制进程状态转换用到的程序包</li><li>进程调度程序(独立进程居多)</li><li>进程通信程序(多个程序包)</li><li>终端登录与作业控制程序、性能监控程序、审计程序等外围程序</li></ol><h2 id="11-2-部分进程管理原语-P81"><a href="#11-2-部分进程管理原语-P81" class="headerlink" title="11.2. 部分进程管理原语(P81)"></a>11.2. 部分进程管理原语(P81)</h2><ol><li><strong>进程创建</strong>：<ol><li>操作系统初始启动时会创建承担系统资源分配和控制管理的一些系统进程，同时会创建一个所有用户集成的祖先，其他用户进程实在用户程序被提价与选中运行时被创建的。</li><li>操作系统通常将创建关系通过父子进程的关系来表示。</li><li>创建原语：进程表加一项、申请PCB(进程控制块)并初始化、生成唯一进程标识、建立进程映像、分配各种资源、移入就绪队列、通知操作系统某些模块</li></ol></li><li><strong>进程撤销</strong>：<ol><li>完成特定工作或出现严重错误后需要撤销，分为正常撤销和非正常撤销。</li><li>产生原因：运行结束、执行非法指令、用户态执行特权指令、时间配额到、等待时间超时、越界错误、共享内存区非法使用、程序性故障等。</li><li>撤销原语：从队列中移除、归还资源、撤销标识、回收PCB、移除进程表项</li></ol></li><li><strong>进程阻塞</strong>：<ol><li>使得进程让出处理器转而等待一个事件，比如等待资源等，阻塞是同步时间。</li><li>阻塞原语：保存现场信息、修改PCB、移入等待队列、调度其他进程执行</li></ol></li><li><strong>进程唤醒</strong>：<ol><li>等待时间完成时产生一个中断，激活操作系统，在系统的控制下将被阻塞进程唤醒</li><li>唤醒原语：等待队列中移出、修改PCB、移入就绪队列(该进程优先级高于运行进程触发抢占)</li></ol></li><li><strong>进程挂起</strong>：<ol><li>出现引起挂起的事件时，系统或进程会利用挂起原语把指定进程或处于等待态的进程挂起。</li><li>挂起原语：修改状态并出入相关队列、收回内存等资源送至对换区。</li><li>挂起原语可以由进程自己或其他进程调起。</li></ol></li><li><strong>进程激活</strong>：<ol><li>当系统资源尤其是内存资源充裕或请求激活进程时，系统或相关进程会调用激活原语将指定进车行激活。</li><li>激活原语：分配内存，修改状态并出入相关队列。</li><li>激活原语只能由其他进程调用。</li></ol></li><li>其他：如修改进程特权，以上是一个进程控制的流程</li></ol><h2 id="11-3-原语与进程控制原语-Primitive"><a href="#11-3-原语与进程控制原语-Primitive" class="headerlink" title="11.3. 原语与进程控制原语(Primitive)"></a>11.3. 原语与进程控制原语(Primitive)</h2><ol><li>进程控制过程中<strong>涉及对OS核心数据结构</strong>(进程表&#x2F;PCB池&#x2F;队列&#x2F;资源表)的修改，不是进程处理的所有指令都是。</li><li>为防止与时间有关的错误，应使用<strong>原语</strong></li><li><strong>原语是由若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性</strong>(保证对核心资源的访问是正确的，原语涉及到的资源都是共享核心资源，只能是唯一的)，进入原语区间，立刻关闭中断完成，然后再开中断响应。</li><li>原语的执行可以通过<strong>关中断实现</strong>，进程控制使用的原语被称为<strong>进程控制原语</strong>，另一类常用原语是<strong>进程通信原语</strong></li></ol><h2 id="11-4-进程切换与模式切换-状态转换"><a href="#11-4-进程切换与模式切换-状态转换" class="headerlink" title="11.4. 进程切换与模式切换(状态转换)"></a>11.4. 进程切换与模式切换(状态转换)</h2><h3 id="11-4-1-进程切换"><a href="#11-4-1-进程切换" class="headerlink" title="11.4.1. 进程切换"></a>11.4.1. 进程切换</h3><ol><li>进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行</li><li>进程切换实质上就是被中断运行进程与待运行进程的上下文切换。</li><li>进程切换必然发生在内核态而非用户态。</li></ol><h3 id="11-4-2-进程切换的工作过程"><a href="#11-4-2-进程切换的工作过程" class="headerlink" title="11.4.2. 进程切换的工作过程"></a>11.4.2. 进程切换的工作过程</h3><ol><li>(中断&#x2F;异常等触发)正向模式切换并压入PSW&#x2F;PC</li><li>保存被中断进程的现场信息</li><li>处理具体中断&#x2F;异常</li><li>把被<strong>中断进程</strong>的系统堆栈指针SP值保存到PCB</li><li>调整被中断进程的PCB信息，如进程状态</li><li>把被中断进程的<strong>PCB</strong>加入相关队列</li><li>选择下一个占用CPU运行的进程</li><li>修改被选中进程的PCB信息，如进程状态</li><li>设置被选中进程的地址空间，恢复存储管理信息</li><li>恢复被选中进程的SP值到处理器寄存器SP</li><li>恢复被选中进程的现场信息进入处理器</li><li>(中断返回指令触发)逆向模式转换并弹出PSW&#x2F;PC</li></ol><h3 id="11-4-3-进程切换的发生时机"><a href="#11-4-3-进程切换的发生时机" class="headerlink" title="11.4.3. 进程切换的发生时机"></a>11.4.3. 进程切换的发生时机</h3><blockquote><p>进程切换一定发生在<strong>中断&#x2F;异常&#x2F;系统调用处理</strong>过程中，常见的情况是：</p></blockquote><ol><li>阻塞式系统调用、虚拟地址异常导致被中断进程进入等待态</li><li>时间片中断、I&#x2F;O中断后发现更高优先级进程，导致被中断进程转入就绪态</li><li>终止用系统调用、不能继续执行的异常导致被中断进程进入终止态</li></ol><h3 id="11-4-4-内核不能执行调度和切换的情况"><a href="#11-4-4-内核不能执行调度和切换的情况" class="headerlink" title="11.4.4. 内核不能执行调度和切换的情况"></a>11.4.4. 内核不能执行调度和切换的情况</h3><ol><li>内核正在处理中断的过程中</li><li>进程运行在内核临界区</li><li>内核处在需要屏蔽中断的原子操作过程中。</li></ol><h3 id="11-4-5-模式切换-状态转换"><a href="#11-4-5-模式切换-状态转换" class="headerlink" title="11.4.5. 模式切换(状态转换)"></a>11.4.5. 模式切换(状态转换)</h3><ol><li>进程切换必须在操作系统内核模式下完成，这就需要用到模式切换。</li><li>模式切换又称处理器状态切换，包括：<ol><li>用户模式到内核模式由<strong>中断&#x2F;异常&#x2F;系统调用</strong>中断用户进程执行而触发</li><li>内核模式到用户模式OS执行<strong>中断返回指令</strong>将控制权交还用户进程而触发</li></ol></li></ol><h3 id="11-4-6-模式切换-状态转换-的基本工作任务"><a href="#11-4-6-模式切换-状态转换-的基本工作任务" class="headerlink" title="11.4.6. 模式切换(状态转换)的基本工作任务"></a>11.4.6. 模式切换(状态转换)的基本工作任务</h3><ol><li>中断装置完成正向模式切换，包括：<ol><li>处理器模式转为内核模式</li><li>保存当前进程的PC&#x2F;PSW值到核心栈</li><li>转向中断&#x2F;异常&#x2F;系统调用处理程序</li></ol></li><li>中断返回指令完成逆向模式转换，包括：<ol><li>从<strong>待运行进程核心栈</strong>中弹出PSW&#x2F;PC值</li><li>处理器模式转为用户模式</li></ol></li></ol><h3 id="11-4-7-模式切换-状态转换-的处理器情况"><a href="#11-4-7-模式切换-状态转换-的处理器情况" class="headerlink" title="11.4.7. 模式切换(状态转换)的处理器情况"></a>11.4.7. 模式切换(状态转换)的处理器情况</h3><ol><li>用户空间中，处于进程上下文，应用进程在用户态下运行，使用用户栈。</li><li>内核空间中，处于进程上下文，内核代表进程在内核态下运行，使用核心栈。</li><li>内核空间中，处于中断上下文，与任何进程无关，中断服务例程在内核态下处理特定中断。</li><li>内核空间中，内核线程(无用户地址空间的进程)运行于内核态。</li></ol><h3 id="11-4-8-进程切换与模式切换-状态转换"><a href="#11-4-8-进程切换与模式切换-状态转换" class="headerlink" title="11.4.8. 进程切换与模式切换(状态转换)"></a>11.4.8. 进程切换与模式切换(状态转换)</h3><ol><li>一些中断&#x2F;异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：<ol><li>(中断&#x2F;异常触发)正向模式切换压入PSW&#x2F;PC</li><li>保存被中断进程的现场信息</li><li>处理中断&#x2F;异常</li><li>恢复被中断进程的现场信息</li><li>(中断返回指令触发)逆向模式转换弹出PSW&#x2F;PC</li></ol></li><li>比如计时中断，中断处理完成后直接恢复</li><li>模式切换是进程仍在自己的上下文进行处理，仅仅是处理器状态发生了变化，内核仍然被中断进程的上下文中进行处理。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/80.png"></p><h1 id="12-多线程技术概述"><a href="#12-多线程技术概述" class="headerlink" title="12. 多线程技术概述"></a>12. 多线程技术概述</h1><ol><li>最开始设计进程的时候并没有体现线程的概念</li></ol><h2 id="12-1-单线程结构"><a href="#12-1-单线程结构" class="headerlink" title="12.1. 单线程结构"></a>12.1. 单线程结构</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/10.png"></p><blockquote><p>传统进程是单线程结构进程</p></blockquote><h3 id="12-1-1-单线程结构进程的问题"><a href="#12-1-1-单线程结构进程的问题" class="headerlink" title="12.1.1. 单线程结构进程的问题"></a>12.1.1. 单线程结构进程的问题</h3><blockquote><p>单线程结构进程在并发程序设计上存在的问题</p></blockquote><ol><li>进程<strong>切换</strong>开销大:10个人干100天的活动-&gt;开会等活动产生的开销，进程切换要进行模式切换，然后再启动进程调度，选择一个就绪进程占用处理器，恢复现场，然后再反向进行。</li><li>进程<strong>通信</strong>开销大:指令流如果分布在不同进程中，那么每次交互都需要由内核完成。</li><li>限制了进程<strong>并发的粒度</strong>:如果没有线程概念，那么进程中本身不可以并发，粒度比较高</li><li>降低了<strong>并行计算的效率</strong></li></ol><h3 id="12-1-2-解决问题的思路"><a href="#12-1-2-解决问题的思路" class="headerlink" title="12.1.2. 解决问题的思路"></a>12.1.2. 解决问题的思路</h3><ol><li>把进程的两项功能分离开来<ol><li>独立分配资源(进程概念上)，进程作为系统资源分配和保护的<strong>独立单位</strong>，不需要频繁地切换</li><li>被调度分派执行(线程概念上)，线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换</li></ol></li><li>线程的出现会减少进程并发执行所付出的时空开销，使得并发粒度更细、并发性更好</li><li>两项功能绑定就是单线程进程，两项功能分离就是多线程进程。</li></ol><h2 id="12-2-多线程结构进程"><a href="#12-2-多线程结构进程" class="headerlink" title="12.2. 多线程结构进程"></a>12.2. 多线程结构进程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/15.png"></p><h3 id="12-2-1-多线程环境下进程的概念"><a href="#12-2-1-多线程环境下进程的概念" class="headerlink" title="12.2.1. 多线程环境下进程的概念"></a>12.2.1. 多线程环境下进程的概念</h3><ol><li>在多线程环境中，进程是操作系统中除处理器以外的资源分配和保护的<strong>独立单位</strong>。具有:<ol><li>用来容纳进程映像的虚拟地址空间</li><li>对进程、文件和设备的存取保护机制</li></ol></li></ol><h3 id="12-2-2-多线程环境下线程的概念"><a href="#12-2-2-多线程环境下线程的概念" class="headerlink" title="12.2.2. 多线程环境下线程的概念"></a>12.2.2. 多线程环境下线程的概念</h3><ol><li>线程是进程能够并发执行的实体，是进程的组成单位，也是处理器调度和分派的基本单位。</li><li>进程是一条执行路径，有独立的程序计数器，未运行时保护线程上下文。</li><li>同一个进程中的所有线程共享进程获得的主存空间和资源。它具有：<ol><li>线程执行状态</li><li>受保护的线程上下文，当线程不运行时，用于存储现场信息</li><li>独立的程序指令计数器</li><li>执行堆栈</li><li>容纳局部变量的静态存储器</li><li>线程控制块</li></ol></li></ol><h3 id="12-2-3-多线程结构进程中的进程与线程"><a href="#12-2-3-多线程结构进程中的进程与线程" class="headerlink" title="12.2.3. 多线程结构进程中的进程与线程"></a>12.2.3. 多线程结构进程中的进程与线程</h3><ol><li>于是，进程可以分为两部分:<ol><li>资源集合</li><li>线程集合。</li></ol></li><li>进程要支撑线程运行，为线程提供虚拟地址空间和各种资源。</li><li>进程封装管理信息，包括对指令代码、全局数据、打开的文件和信号量等共享部分的管理。</li><li>线程封装执行信息，包括状态信息、寄存器、执行栈（用户栈指针与核心栈指针）和局部变量、过程调用参数、返回值等私有部分的管理。</li><li>由于线程具有传统进程的许多特征，所以也把线程称为轻量级进程(Light Weight Process,LWP)</li></ol><h3 id="12-2-4-多线程环境下线程的状态与调度"><a href="#12-2-4-多线程环境下线程的状态与调度" class="headerlink" title="12.2.4. 多线程环境下线程的状态与调度"></a>12.2.4. 多线程环境下线程的状态与调度</h3><ol><li>线程状态有运行、就绪和等待和终止，(没有挂起状态时因为挂起和资源有关，而进程是资源管理的单位，与线程无关)</li><li>与线程状态变化有关的线程操作有：孵化、封锁、活化、剥夺、指派、结束</li><li>OS感知线程环境下：<ol><li>处理器调度的对象是线程</li><li>线程的存在、状态等都需要被操作系统内核感知到，进程没有三状态，或者说只有挂起状态。</li></ol></li><li>OS不感知线程环境下：<ol><li>处理器调度的单位仍然是进程</li><li>用户空间中的用户调度程序调度线程，内核不参加线程调度。</li></ol></li><li>状态转换模型<ol><li>运行态-&gt;终止态(撤销Return)</li><li>运行态-&gt;就绪态(中断系统)</li><li>运行态-&gt;就绪态(时间片用完)</li><li>就绪态-&gt;运行态</li></ol></li><li>DBMS:Client(请求方，Request)和Server(应答，Response)，Client频繁请求，Server频繁响应，Jacketing避免阻塞</li></ol><h2 id="12-3-并发多线程程序设计的优点"><a href="#12-3-并发多线程程序设计的优点" class="headerlink" title="12.3. 并发多线程程序设计的优点"></a>12.3. 并发多线程程序设计的优点</h2><ol><li>快速线程切换：改变堆栈和寄存器，不需要改变地址空间</li><li>减少(系统)管理开销：线程的创建和撤销要简单很多</li><li>(线程)通信易于实现：自动共享进程的内存和文件</li><li>并行程度提高</li><li>节省内存空间</li></ol><h2 id="12-4-多线程技术的应用"><a href="#12-4-多线程技术的应用" class="headerlink" title="12.4. 多线程技术的应用"></a>12.4. 多线程技术的应用</h2><ol><li>前台和后台工作:word的输入和拼写检查</li><li>C&#x2F;S应用模式:用户和服务器，其他线程调用</li><li>加快执行速度</li><li>设计用户接口</li></ol><h1 id="13-KLT与ULT"><a href="#13-KLT与ULT" class="headerlink" title="13. KLT与ULT"></a>13. KLT与ULT</h1><h2 id="13-1-内核级线程-KLT-Kernel-Level-Threads"><a href="#13-1-内核级线程-KLT-Kernel-Level-Threads" class="headerlink" title="13.1. 内核级线程 KLT, Kernel-Level Threads"></a>13.1. 内核级线程 KLT, Kernel-Level Threads</h2><ol><li>线程管理的所有工作由<strong>OS内核</strong>来做，并提供了一个应用程序设计接口API，供开发者使用KLT，</li><li>创建时：内核为其创建进程和一个基线程，线程实行过程中通过内核的创建线程原语来创建其他线程。</li><li>OS直接调度KLT，KLT用于解决物理并行性问题，内核可以感知到所有的内核级线程，可以控制器其数据结构，内核调度在线程的基础上进行。</li></ol><h3 id="13-1-1-内核级线程示意图"><a href="#13-1-1-内核级线程示意图" class="headerlink" title="13.1.1. 内核级线程示意图"></a>13.1.1. 内核级线程示意图</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/16.png"></p><h3 id="13-1-2-内核级线程的特点"><a href="#13-1-2-内核级线程的特点" class="headerlink" title="13.1.2. 内核级线程的特点"></a>13.1.2. 内核级线程的特点</h3><ol><li>优点：<ol><li>在多处理器上内核可以同时调度统一进程的多个线程运行。</li><li>进程中的某一线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行，也可以运行其他进程。</li><li>由于内核比较小，内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率。</li></ol></li><li>缺陷：<ol><li>应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大。</li><li>线程调度开销大，线程通信开销小。</li></ol></li></ol><h2 id="13-2-用户级线程ULT-User-Level-Threads"><a href="#13-2-用户级线程ULT-User-Level-Threads" class="headerlink" title="13.2. 用户级线程ULT, User-Level Threads"></a>13.2. 用户级线程ULT, User-Level Threads</h2><ol><li>用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境。任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行</li><li>线程管理的所有工作都由<strong>应用程序</strong>完成，<strong>内核没有</strong>感知到线程的存在，内核感知到的单位是进程。</li></ol><h3 id="13-2-1-用户级线程示意图"><a href="#13-2-1-用户级线程示意图" class="headerlink" title="13.2.1. 用户级线程示意图"></a>13.2.1. 用户级线程示意图</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/17.png"></p><h3 id="13-2-2-用户级线程的特点"><a href="#13-2-2-用户级线程的特点" class="headerlink" title="13.2.2. 用户级线程的特点"></a>13.2.2. 用户级线程的特点</h3><ol><li>优点：<ol><li>节省开销和内核资源:所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能<strong>节省模式切换开销和内核的宝贵资源</strong>。</li><li>允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法。</li><li>可移植性好:能运行在任何OS上，内核在支持ULT方面不需要做任何工作。</li><li>ULT可以解决逻辑并行性问题。</li></ol></li><li>缺点：<ol><li>不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行。</li><li>一个ULT的阻塞，将引起整个进程的阻塞:不能完成切换线程，因为内核感知不到进程中的线程的存在。</li></ol></li><li>ULT可以解决逻辑并行性问题。</li></ol><h2 id="13-3-Jacketing技术"><a href="#13-3-Jacketing技术" class="headerlink" title="13.3. Jacketing技术"></a>13.3. Jacketing技术</h2><ol><li>把阻塞式系统调用改造成非阻塞式的:解决一个ULT的阻塞导致整个进程阻塞，避免进程因此从运行态$\rightarrow$阻塞态，如此的频繁切换会带来比较大的开销。</li><li>当线程陷入系统调用时，执行Jacketing程序。</li><li>由Jacketing程序来检查资源使用情况，以决定是否执行<strong>进程切换</strong>或<strong>传递控制权给另一个线程</strong></li></ol><h2 id="13-4-用户级线程-vs-内核级线程"><a href="#13-4-用户级线程-vs-内核级线程" class="headerlink" title="13.4. 用户级线程 vs. 内核级线程"></a>13.4. 用户级线程 vs. 内核级线程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/18.png"></p><ol><li>受限条件下的并行:受限条件是同步关系(等待)</li><li>ULT适用于解决逻辑并行性问题</li><li>KLT适用于解决物理并行性问题</li></ol><h2 id="13-5-多线程实现的混合式策略"><a href="#13-5-多线程实现的混合式策略" class="headerlink" title="13.5. 多线程实现的混合式策略"></a>13.5. 多线程实现的混合式策略</h2><ol><li>在用户空间完成所有的线程的创建工作。</li><li>单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果。</li><li>在混合式线程中，内核必须支持内核级多线程的建立、调度和管理，同时也允许应用程序建立、调度和管理用户级线程。</li><li>用户级线程的切换仅在用户空间中且仅需要少量机器指令，而内核级线程需要用户态到内核态到用户态的完整上下文切换，修改内存映像，使得高速缓存失效，导致数量级的延迟。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/19.png"></p><h3 id="13-5-1-多线程实现混合式策略的特点"><a href="#13-5-1-多线程实现混合式策略的特点" class="headerlink" title="13.5.1. 多线程实现混合式策略的特点"></a>13.5.1. 多线程实现混合式策略的特点</h3><ol><li>合并了用户级线程&#x2F;内核级线程设施</li><li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li><li>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上</li><li>程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果</li><li>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点</li></ol><h3 id="13-5-2-线程混合式策略下的线程状态"><a href="#13-5-2-线程混合式策略下的线程状态" class="headerlink" title="13.5.2. 线程混合式策略下的线程状态"></a>13.5.2. 线程混合式策略下的线程状态</h3><ol><li>KLT的三态模型，由系统调度负责</li><li>ULT的三态模型，由用户调度负责</li><li>活跃态的ULT代表绑定KLT的三态</li><li>活跃态的ULT运行时可激活用户调度，非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/20.png"></p><ol><li>为什么是活跃态绑定KLT的三态？</li><li>因为如果绑定的KLT不再运行，则也不再运行。活跃态代表了KLT，可能是运行态、可运行态、阻塞态</li></ol><h3 id="13-5-3-多线程实现的各种策略总结"><a href="#13-5-3-多线程实现的各种策略总结" class="headerlink" title="13.5.3. 多线程实现的各种策略总结"></a>13.5.3. 多线程实现的各种策略总结</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/21.png"></p><blockquote><p>混合式多线程合并了内核级多线程和用户级多线程的优势，甚至可以指派到CPU，或由操作系统绑定。</p></blockquote><h3 id="13-5-4-Solris-多线程技术"><a href="#13-5-4-Solris-多线程技术" class="headerlink" title="13.5.4. Solris 多线程技术"></a>13.5.4. Solris 多线程技术</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/28.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/34.png"></th></tr></thead></table><blockquote><p>包含了多种情况，上图引入了轻量级线程，将轻量级线程与内核级线程映射，原来的多线程设计是Process2，只有一个处理进程，允许给一个进程配置超过一个处理器。</p></blockquote><ol><li>进程一:单进程单线程，内核级多线程</li><li>进程二:单进程双线程，进程映射到两个轻量级线程，相当于用户级多线程</li><li>进程三:两进程三线程，内核级多线程</li><li>进程四:两进程两线程，内核级多线程</li><li>进程五:三进程四线程，混合级线程，直接做指派意味着线程非常重要，需要单独指派。</li></ol><blockquote><p>一个进程的线程可以被分发到各个位置上并行完成，处理器只能感知进程，不能感知线程，并且只会将一个处理器分配给线程，然后用户空间将得到的处理器分配给线程。</p></blockquote><h1 id="14-处理器调用"><a href="#14-处理器调用" class="headerlink" title="14. 处理器调用"></a>14. 处理器调用</h1><h2 id="14-1-处理器调度层次"><a href="#14-1-处理器调度层次" class="headerlink" title="14.1. 处理器调度层次"></a>14.1. 处理器调度层次</h2><ol><li>高级调度：又称长程调度、作业调度，决定能否加入到执行的进程池中，管理从创建进程到调度运行再到结束阶段后的善后部分的全过程。</li><li>中级调度，又称平衡调度、中程调度，根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作。</li><li>低级调度：又称短程调度、进程调度&#x2F;线程调度，根据某种原则决定就绪队列中哪个进程&#x2F;线程获得处理器，并将处理器让出给它使用。</li></ol><h3 id="14-1-1-处理器调度层次与进程状态转换"><a href="#14-1-1-处理器调度层次与进程状态转换" class="headerlink" title="14.1.1. 处理器调度层次与进程状态转换"></a>14.1.1. 处理器调度层次与进程状态转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/22.png"></p><blockquote><p>这个说明录入各级调度和七态模型的情况，三个框分别表明不同调度层次，如上图所示。资源紧张时挂起，资源空闲时解挂</p></blockquote><h3 id="14-1-2-处理器调度层次与关键状态转换"><a href="#14-1-2-处理器调度层次与关键状态转换" class="headerlink" title="14.1.2. 处理器调度层次与关键状态转换"></a>14.1.2. 处理器调度层次与关键状态转换</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/23.png"></p><h3 id="14-1-3-高级调度"><a href="#14-1-3-高级调度" class="headerlink" title="14.1.3. 高级调度"></a>14.1.3. 高级调度</h3><ol><li>在分时操作系统中，高级调度决定：<ol><li>是否接受一个终端用户的连接</li><li>命令能否被系统接纳并构成进程</li><li>新建态进程是否加入就绪进程队列</li></ol></li><li>批处理OS中，高级调度又称为作业调度，功能是按照某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备工作和完成后的善后工作</li></ol><h3 id="14-1-4-中级调度"><a href="#14-1-4-中级调度" class="headerlink" title="14.1.4. 中级调度"></a>14.1.4. 中级调度</h3><ol><li>引进中级调度是为了提高内存利用率和作业吞吐量</li><li>中级调度决定那些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用</li><li>中级调度把一些进程换出主存，从而使之进入”挂起”状态，不参与进程调度，以平顺系统的负载</li></ol><h3 id="14-1-5-低级调度"><a href="#14-1-5-低级调度" class="headerlink" title="14.1.5. 低级调度"></a>14.1.5. 低级调度</h3><ol><li>低级调度：又称处理器调度、进程调度、短程调度，按照某种原则把处理器分配给就绪态进程或内核级线程</li><li>进程调度程序：又称分派程序，操作系统中实现处理器调度的程序，是操作系统的最<strong>核心部分</strong></li><li>处理器<strong>调度策略</strong>的优劣直接影响到整个系统的性能，这个进程被很多操作系统称为0号进程，所有进程的<strong>父进程</strong></li><li>低级调度主要是负责记录进程或内核级线程的状态、决定某个进程或内核级线程什么时候获得处理器以及占用时间、将处理器分配给进程或内核级线程、回收处理器。</li></ol><h3 id="14-1-6-综述三级调度"><a href="#14-1-6-综述三级调度" class="headerlink" title="14.1.6. 综述三级调度"></a>14.1.6. 综述三级调度</h3><ol><li>一般操作系统都配置了高级调度和低级调度，而功能完善的操作系统为了提高内存利用率和作业吞吐率引进了中级调度。</li><li>因此，从处理器调度的层次来讲，可以划分为三级调度模型和两级调度模型。</li></ol><h2 id="14-2-CPU从进程到进程的切换"><a href="#14-2-CPU从进程到进程的切换" class="headerlink" title="14.2. CPU从进程到进程的切换"></a>14.2. CPU从进程到进程的切换</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/35.png"></p><ul><li>内核态进程占用时间不应该过多，应当尽量避免频繁的模式切换<ol><li>正向切换(从用户态转换到内核态):Trap、系统调用、中断</li><li>反向切换(从内核态转换到用户态):ret</li></ol></li></ul><h2 id="14-3-进程抽象"><a href="#14-3-进程抽象" class="headerlink" title="14.3. 进程抽象"></a>14.3. 进程抽象</h2><p>我们需要不断完善中断处理子系统，内核态是将特权指令和非特权指令混搭使用。</p><h1 id="15-处理器调度算法"><a href="#15-处理器调度算法" class="headerlink" title="15. 处理器调度算法"></a>15. 处理器调度算法</h1><h2 id="15-1-选择处理器调度算法的原则"><a href="#15-1-选择处理器调度算法的原则" class="headerlink" title="15.1. 选择处理器调度算法的原则"></a>15.1. 选择处理器调度算法的原则</h2><blockquote><p>在以下的五个方面进行巧妙的平衡来完成操作系统的设计。</p></blockquote><ol><li>资源利用率：使得CPU或其他资源的使用率尽可能高且能够并行工作</li></ol><p>$$<br>\begin{aligned}<br>   &amp;CPU利用率 &#x3D; \frac{CPU有效工作时间}{CPU总运行时间} \<br>   &amp;CPU总运行时间 &#x3D; CPU有效工作时间 + CPU空闲等待时间 \<br>\end{aligned}<br>$$</p><ol start="2"><li>吞吐量：单位事假内CPU处理作业的个数，服务器的TPS，例如12306或淘宝</li><li>公平性：确保每个用户每个进程获得合理的CPU份额或其他资源份额</li><li>响应时间：<ol><li>使交互式用户的响应时间尽可能小，或尽快处理实时任务</li><li>细分包含输入的程序命令传送到CPU时间、CPU处理请求命令的时间、处理所形成的响应回送到终端显示器的时间。</li></ol></li><li>周转时间：提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短。</li></ol><p>$$<br>\begin{aligned}<br>   &amp;作业i周转时间t_i &#x3D; 完成时刻t_f - 提交时刻t_s \<br>   &amp;平均作业周转时间T &#x3D; \frac{\sum\limits_{i&#x3D;1}\limits^nt_i}{n}\<br>   &amp;作业带权周转时间w_i &#x3D; \frac{周转时间t_i}{运行时间t_k} \<br>   &amp;平均带权做作业周转时间W &#x3D;\frac{\sum\limits_{i&#x3D;1}\limits^nw_i}{n}<br>\end{aligned}<br>$$</p><h2 id="15-2-短程调度准则"><a href="#15-2-短程调度准则" class="headerlink" title="15.2. 短程调度准则"></a>15.2. 短程调度准则</h2><ol><li>与性能相关<ol><li>面向用户：周转时间、响应时间、最后期限</li><li>面向系统：吞吐量、处理器利用率</li></ol></li><li>与性能无关<ol><li>面向用户：可预测性</li><li>面向系统：公平、强制优先级、平衡资源</li></ol></li></ol><h2 id="15-3-低级调度的主要功能"><a href="#15-3-低级调度的主要功能" class="headerlink" title="15.3. 低级调度的主要功能"></a>15.3. 低级调度的主要功能</h2><ol><li>调度：实现调度策略，确定就绪态进程&#x2F;线程竞争使用处理器的次序的裁决原则。</li><li>分派：实现调度机制，确定如何时分复用CPU，处理上下文切换，完成进程&#x2F;线程同CPU的绑定以及放弃的实际工作</li></ol><h2 id="15-4-调度的模式"><a href="#15-4-调度的模式" class="headerlink" title="15.4. 调度的模式"></a>15.4. 调度的模式</h2><ol><li>抢占式(剥夺式)调度：当前正在运行的进程可能被操作系统中断，并转移到就绪态。处理器剥夺原则：<ol><li>高优先级进程&#x2F;线程可剥夺低优先级进程&#x2F;线程。</li><li>运行进程&#x2F;线程时间片用完后被剥夺。</li></ol></li><li>非抢占式(非剥夺式)调度：一个进程一旦处于运行态，它就不断执行直到终止，或者为等待I&#x2F;O或请求某些操作系统服务而阻塞自己。</li><li>与非抢占式调度相比，抢占式调度可能会导致较大的开销，但是可能对所有进程提供更好的服务，可以避免任何一个进程独占处理器太长时间</li></ol><h2 id="15-5-优先数调度算法"><a href="#15-5-优先数调度算法" class="headerlink" title="15.5. 优先数调度算法"></a>15.5. 优先数调度算法</h2><ol><li>操作系统往往无法判断进程会使用CPU多久，所以现代操作系统一般会使用时间片轮转来完成调度。</li><li>排列论:随机过程(Stochastic Process，Markor)</li></ol><h3 id="15-5-1-根据分配给进程的优先数决定运行进程"><a href="#15-5-1-根据分配给进程的优先数决定运行进程" class="headerlink" title="15.5.1. 根据分配给进程的优先数决定运行进程"></a>15.5.1. 根据分配给进程的优先数决定运行进程</h3><ol><li>抢占式(Preemptive)优先数调度算法，出现高优先级则中断，抢占一定是从运行态到就绪态的转换，抢占点的安排可能不一样，在实时系统中将抢占点提前，不等一个进程使用完时间片，而是新进程到达就发生抢占，或者时间片用完抢占。</li><li>非抢占式(non-preemptive)优先数调度算法，出现CPU空闲再选择。</li></ol><h3 id="15-5-2-优先数的确定准则"><a href="#15-5-2-优先数的确定准则" class="headerlink" title="15.5.2. 优先数的确定准则"></a>15.5.2. 优先数的确定准则</h3><ol><li>进程负担任务的紧迫程度</li><li>进程的交互性</li><li>进程使用外设的频度:使用外设的优先</li><li>进程进入系统的时间长短:公平性和周转的问题</li></ol><h3 id="15-5-3-调度算法分类"><a href="#15-5-3-调度算法分类" class="headerlink" title="15.5.3. 调度算法分类"></a>15.5.3. 调度算法分类</h3><ol><li>FCFS (先来先服务) 非抢占</li><li>RR (时间片轮转) 抢占</li><li>SPN (最短进程优先) 非抢占，真正操作系统没有办法使用</li><li>SRT (最短剩余时间优先) 抢占，真正操作系统没有办法使用</li><li>HRRF (最高响应比优先) 非抢占，真正操作系统没有办法使用</li><li>Feedback (多级反馈调度) 抢占</li></ol><h2 id="15-6-与进入系统时间相关的优先数"><a href="#15-6-与进入系统时间相关的优先数" class="headerlink" title="15.6. 与进入系统时间相关的优先数"></a>15.6. 与进入系统时间相关的优先数</h2><ol><li>计算时间短(作业&#x2F;进程)优先</li><li>剩余计算时间短进程优先：商业操作系统可以这么处理，但是别的可能有一定的问题。</li><li>响应比高者(作业&#x2F;进程)优先：</li></ol><p>$$<br>\begin{aligned}<br>   &amp;响应比 &#x3D; \frac{等待时间 + 期待服务时间}{期待服务时间}\<br>   &amp;\qquad\qquad &#x3D; 1 + \frac{等待时间}{期待服务时间} \<br>\end{aligned}<br>$$</p><ol start="4"><li>先来先服务：先进队先被选择：多用于高级调度；低级调度中，以<strong>计算</strong>为主的进程过于优越</li></ol><h1 id="16-具体调度算法"><a href="#16-具体调度算法" class="headerlink" title="16. 具体调度算法"></a>16. 具体调度算法</h1><h2 id="16-1-FCFS-先来先服务"><a href="#16-1-FCFS-先来先服务" class="headerlink" title="16.1. FCFS (先来先服务)"></a>16.1. FCFS (先来先服务)</h2><ol><li>当某个进程就绪时，就加入就绪队列(ready queue)，当前正在运行的进程停止执行时，选择在就绪队列到达时间最长的进程运行</li><li>平均作业周转时间与作业提交和调度顺序有关。</li><li>两个弊端<ol><li>一个短进程可能不得不等待很长时间才能获得执行，导致吞吐率很难提高，加权中转时间会上升，最差的情况就是计算型死循环，导致完全无法调度。</li><li>偏袒计算为主的进程:I&#x2F;O多的进程不得不等待计算为主的进程做完，因为需要等待资源，离开后需要重新排队。</li></ol></li><li>性能会非常差，不被现在的操作系统使用。</li><li>先来先服务算法示例：</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/38.png"></p><ol start="6"><li>平均作业周转时间$T + \frac{3 + 7 + 9 + 12 + 12}{5} &#x3D; 8.6$</li><li>平均带权作业周转时间$T + \frac{\frac{3}{3} + \frac{7}{6} + \frac{9}{4} + \frac{12}{5} + \frac{12}{2}}{5} \approx 2.563$</li></ol><h2 id="16-2-SPN-最短进程优先"><a href="#16-2-SPN-最短进程优先" class="headerlink" title="16.2. SPN (最短进程优先)"></a>16.2. SPN (最短进程优先)</h2><ol><li>SPN是一种<strong>非抢占式</strong>调度，会选择处理时间最短的进程，短进程将会越过长进程，优先获得调度，又称为SJF。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/47.png"></p><ol start="2"><li>平均作业周转时间$T &#x3D; \frac{3 + 7 + 11 + 14 + 3}{5} &#x3D; 7.6$</li><li>平均带权作业周转时间$W &#x3D; \frac{\frac{3}{3} + \frac{7}{6} + \frac{11}{4} + \frac{14}{5} + \frac{3}{2}}{5} \approx 1.843$</li><li>问题:<ol><li>需要预知作业所需的CPU运行时间</li><li>忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。</li><li>分时、实时处理仍然不理想。</li></ol></li></ol><h2 id="16-3-SRT，Shortest-Remaining-Time，最短剩余时间优先"><a href="#16-3-SRT，Shortest-Remaining-Time，最短剩余时间优先" class="headerlink" title="16.3. SRT，Shortest Remaining Time，最短剩余时间优先"></a>16.3. SRT，Shortest Remaining Time，最短剩余时间优先</h2><ol><li>SRT是一种<strong>抢占式</strong>调度，调度器总是选择预期剩余时间更短的进程</li><li>当一个新进程加入就绪队列，他可能比当前运行的进程具有更短的剩余时间，只要新进程进入就绪队列，调度器就可能抢占当前正在运行的进程</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/48.png"></p><ol start="3"><li>平均等待时间$&#x3D;\frac{(3 - 3 - 0) + (15 - 6 - 2) + (8 - 4 - 4) + (20 - 5 - 6) + (10 - 2 - 8)}{5} &#x3D; 3.2$</li><li>平均周转时间$&#x3D;\frac{(3 - 0) + (15 - 2) + (8 - 4) + (20 - 6) + (10 - 8)}{5} &#x3D; 7.2$</li></ol><h2 id="16-4-HRRN-最高响应比优先-Highest-Response-Ratio-Next"><a href="#16-4-HRRN-最高响应比优先-Highest-Response-Ratio-Next" class="headerlink" title="16.4. HRRN (最高响应比优先)Highest Response Ratio Next"></a>16.4. HRRN (最高响应比优先)Highest Response Ratio Next</h2><ol><li>非抢占式算法，性能略差与SPN(SJF)</li><li>选择响应比最高的进程：出发点是兼顾公平，对于短进程有利</li><li>每当需要调度时，计算出所有的响应比，选择最高的。</li></ol><p>$$<br>\begin{aligned}<br>   &amp;响应比 &#x3D; \frac{等待时间 + 期待服务时间}{期待服务时间}\<br>   &amp;\qquad\qquad &#x3D; 1 + \frac{等待时间}{期待服务时间} \<br>\end{aligned}<br>$$</p><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/49.png"></p><table><thead><tr><th>时刻</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>0时刻</td><td>$1$</td><td>未到</td><td>未到</td><td>未到</td><td>未到</td></tr><tr><td>3时刻</td><td>完成</td><td>$1 + \frac{1}{6} \approx 1.17$</td><td>未到</td><td>未到</td><td>未到</td></tr><tr><td>9时刻</td><td>完成</td><td>完成</td><td>$1 + \frac{5}{4} &#x3D; 2.25$</td><td>$1 + \frac{3}{5} &#x3D; 1.6$</td><td>$1 + \frac{1}{2} &#x3D; 1.5$</td></tr><tr><td>13时刻</td><td>完成</td><td>完成</td><td>完成</td><td>$1 + \frac{7}{5} &#x3D; 2.6$</td><td>$1 + \frac{5}{2} &#x3D; 3.5$</td></tr><tr><td>15时刻</td><td>完成</td><td>完成</td><td>完成</td><td>$1 + \frac{12}{5} &#x3D; 3.4$</td><td>万&#x3D;完成</td></tr></tbody></table><h2 id="16-5-优先级调度"><a href="#16-5-优先级调度" class="headerlink" title="16.5. 优先级调度"></a>16.5. 优先级调度</h2><ol><li>调度器总是选择优先级较高的进程，提供多个就绪队列(一组就绪队列)，代表各个级别的优先级。</li><li>低优先级的进程可能很难被执行到？一个进程的优先级应该随着它的时间或执行的历史而变化。</li><li>如果就绪队列中出现优先级高的进程&#x2F;线程，系统可以预先规定策略为非剥夺式和剥夺式策略。</li><li>优先级的确定<ol><li>用户给出优先级</li><li>系统综合考虑各因素，包括打开文件数、资源申请情况等等</li></ol></li><li>优先级确定方式<ol><li>静态：生命周期内不改变，容易造成饥饿问题。</li><li>动态：生命周期内可能会发生改变，正在运行的进程逐渐降低优先级，正在等待的进程逐渐提高优先级。</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/36.png"></p><h2 id="16-6-RR-时间片轮转调度算法"><a href="#16-6-RR-时间片轮转调度算法" class="headerlink" title="16.6. RR(时间片轮转调度算法)"></a>16.6. RR(时间片轮转调度算法)</h2><p>以时间片轮转为基本策略的调度算法不需要预知就绪进程所需cpu时长</p><ol><li>本质也是<strong>先来先服务</strong>，但是要按照时间片来进行调度。</li><li>根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片，基于时钟做抢占式调度。</li><li>时间片中断：以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列队尾，然后基于FCFS策略选择下一个就绪进程运行</li><li>时间片的确定：选择长短合适的时间片，一般为10ms到200ms<ol><li>过长则退化为先来先服务算法</li><li>过短则调度开销显著增大</li></ol></li><li>时间片分为单时间片、多时间片和动态时间片三种</li><li>使用时间片轮转调度算法，在给一个进程分配处理器的时候，不需要知道进程需要多长时间</li><li>很多的调度都会结合时间片轮转调度算法来实现</li><li>如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。</li></ol><h3 id="16-6-1-使用情况"><a href="#16-6-1-使用情况" class="headerlink" title="16.6.1. 使用情况"></a>16.6.1. 使用情况</h3><ol><li>先进先出&#x2F;最短时间&#x2F;剩余时间&#x2F;响应比优先算法，无法判断进程需要占用多长时间的CPU</li><li>有预估时间的调度，用在作业调度、云计算调度中比较合适，在低级调度中不合适</li></ol><h3 id="16-6-2-进程分类"><a href="#16-6-2-进程分类" class="headerlink" title="16.6.2. 进程分类"></a>16.6.2. 进程分类</h3><ol><li>以计算为主的进程：不需要内核参与，没有从运行态到阻塞态的情况，如果出现死循环进程也必须要遵循时间片轮换，如果进程比较多，就可以淡化死循环的影响</li><li>I&#x2F;O(外设)频繁的进程：发生运行态到阻塞态的可能性比较大，根据各个进程进入就绪队列的时间先后轮流占用CPU一个时间片，时间片到即发生时间片中断。</li></ol><h3 id="16-6-3-时间片轮转调度算法示例"><a href="#16-6-3-时间片轮转调度算法示例" class="headerlink" title="16.6.3. 时间片轮转调度算法示例"></a>16.6.3. 时间片轮转调度算法示例</h3><table><thead><tr><th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/39.png"></th><th><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/39.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/40.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/41.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/42.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/43.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/44.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/45.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/46.png"></td><td></td></tr></tbody></table><blockquote><p>务必关注就绪队列</p></blockquote><h2 id="16-7-多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度"><a href="#16-7-多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度" class="headerlink" title="16.7. 多级反馈调度 (Multi-level Feedback Queue，MLFQ)，又称分级调度"></a>16.7. 多级反馈调度 (Multi-level Feedback Queue，MLFQ)，又称分级调度</h2><ol><li>基本思想<ol><li>建立多个不同优先级的就绪进程队列</li><li>多个就绪进程队列之间按照优先数调度</li><li>高优先级的就绪进程, 分配的时间片短</li><li>单个就绪进程队列中的进程的优先数和时间片相同,按照先来先服务算法调度</li></ol></li><li>分级原则：外设访问、交互性、时间紧迫程度、系统效率、用户立场</li><li>现代操作系统的实现模型<ol><li>多个高优先级的实时进程队列，如：硬实时、网络、软实时</li><li>多个分时任务的进程队列，根据基准优先数和执行行为调整</li><li>队列数可能多达32-128个</li></ol></li><li>如果没做完会惩罚降级，做题目要至少画一下前几个RQ。如果进程掉出去的同时，有新的进程进入，那么新的进程优先进入就绪队列</li><li>对以计算为主的长进程不友好，就绪队列越深获得调度的机会越小</li><li>不同的进程可以设置不同的时间片长度:$q &#x3D; 2^i$，i是层数，所以第一层时间片长为1，第二层长为2</li><li>多级队列更能够发现先到达的，时间片比较短的处理完。</li><li>除了极少数的硬实时操作系统使用抢占式调度算法，绝大多数操作系统有效地组合时间片调度算法和优先数调度算法，采用分级调度算法的策略加以实现</li><li>如果没有竞争不掉下去，时刻1(根据考试具体情况决定)</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/50.png"></p><h3 id="16-7-1-q-x3D-1-时的多级反馈调度的示例"><a href="#16-7-1-q-x3D-1-时的多级反馈调度的示例" class="headerlink" title="16.7.1. q &#x3D; 1 时的多级反馈调度的示例"></a>16.7.1. q &#x3D; 1 时的多级反馈调度的示例</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/51.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/52.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/53.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/54.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/55.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/56.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/57.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/58.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/59.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/60.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/61.png"></td><td></td></tr></tbody></table><h3 id="16-7-2-q-x3D-2-i-时的多级反馈调度的示例"><a href="#16-7-2-q-x3D-2-i-时的多级反馈调度的示例" class="headerlink" title="16.7.2. q &#x3D; $2^i$时的多级反馈调度的示例"></a>16.7.2. q &#x3D; $2^i$时的多级反馈调度的示例</h3><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/62.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/63.png"></th></tr></thead><tbody><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/64.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/65.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/66.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/67.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/68.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/69.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/70.png"></td><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/71.png"></td></tr><tr><td><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/72.png"></td><td></td></tr></tbody></table><h3 id="16-7-3-多级反馈调度的示意图"><a href="#16-7-3-多级反馈调度的示意图" class="headerlink" title="16.7.3. 多级反馈调度的示意图"></a>16.7.3. 多级反馈调度的示意图</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/24.png"></p><ol><li>如果没有进程竞争，那么会不会导致进程掉下去，根据具体情况分析，可能掉下去也可能没有掉下去。</li><li>此时RQ0是A，RQ2是C，当前A在做，那么A掉下来后是运行A还是C，可以考虑运行A进程：因为掉到了RQ1，也可以考虑运行C进程，具体情况要看操作系统时间中的细节</li><li>刚好做完的时刻，B同步进入也需要细规则来完善。</li></ol><h2 id="16-8-彩票调度算法"><a href="#16-8-彩票调度算法" class="headerlink" title="16.8. 彩票调度算法"></a>16.8. 彩票调度算法</h2><ol><li>基本思想：为进程发放针对<strong>系统各种资源</strong>(如CPU时间)的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源</li><li>功能比保证调度好的多，服务器和客户：客户需要调用服务器服务，则将彩票交给服务器</li><li>合作进程之间的彩票交换</li><li>一般不会在实时操作系统中使用，但是可以在服务器端进行使用，特别是视频点播服务器</li></ol><h2 id="16-9-传统Unix系统的调度-例"><a href="#16-9-传统Unix系统的调度-例" class="headerlink" title="16.9. 传统Unix系统的调度(例)"></a>16.9. 传统Unix系统的调度(例)</h2><ol><li>多级反馈队列，每个优先级队列使用时间片轮转</li><li>每秒重新计算每个进程的优先级</li><li>给每个进程赋予基本优先级的目的是把所有进程划分成固定的优先级区</li><li>可控调节因子</li></ol><h2 id="16-10-Unix-SVR4调度算法-例"><a href="#16-10-Unix-SVR4调度算法-例" class="headerlink" title="16.10. Unix SVR4调度算法(例)"></a>16.10. Unix SVR4调度算法(例)</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/74.png"></p><ol><li><p>100-159是实时部分任务</p></li><li><p>60-99是内核部分任务</p></li><li><p>0-59是分时部分任务</p></li><li><p>多级反馈队列，每一个优先数都对应于一个就绪进程队列</p><ol><li>实时优先级层次：优先数和时间片都是固定的，在抢占点执行抢占</li><li>分时优先级层次：优先数和时间片是可变的，从0优先数的100ms到59优先数的10ms</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/75.png"></p><h2 id="16-11-Bands"><a href="#16-11-Bands" class="headerlink" title="16.11. Bands"></a>16.11. Bands</h2><blockquote><p>优先级递减：对换、块I&#x2F;O设备控制、文件操作、字符I&#x2F;O设备控制、用户进程</p></blockquote><h2 id="16-12-Windows调度算法-例"><a href="#16-12-Windows调度算法-例" class="headerlink" title="16.12. Windows调度算法(例)"></a>16.12. Windows调度算法(例)</h2><ol><li>主要设计目标：基于内核级线程的可抢占式调度，向单个用户提供交互式的计算环境，并支持各种服务器程序</li><li>优先级和优先数</li><li>实时优先级层次(优先数为31-16)：用于通信任务和实时任务，优先数不可变</li><li>可变优先级层次(优先数为15-0)：用于用户提交的交互式任务，优先数可动态调整</li><li>多级反馈队列，每一个优先数都对应于一个就绪进程队列</li><li>优先数可动态调整原则<ol><li>线程所属的进程对象有一个进程基本优先数，取值范围从0到15</li><li>线程对象有一个线程基本优先数，取值范围从-2到2</li><li>线程的初始优先数为进程基本优先数加上线程基本优先数，但必须在0到15的范围内</li><li>线程的动态优先数必须在初始优先数到15的范围</li></ol></li><li>当存在N个处理器时，N-1个处理器上将运行N-1个最高<br>先级的线程，其他线程将共享剩下的一个处理器</li></ol><h1 id="17-批处理作业的调度"><a href="#17-批处理作业的调度" class="headerlink" title="17. 批处理作业的调度"></a>17. 批处理作业的调度</h1><h2 id="17-1-批处理作业的管理"><a href="#17-1-批处理作业的管理" class="headerlink" title="17.1. 批处理作业的管理"></a>17.1. 批处理作业的管理</h2><ol><li>作业说明语言和作业说明书</li><li>脱机控制方式(批处理控制方式)</li><li>作业控制块JCB</li><li>作业状态<ol><li>输入状态：作业正在从输入设备上预输入信息</li><li>后备状态：作业预输入结束但尚未被选中执行</li><li>执行状态：作业已经被选中并构成进程去竞争处理器资源以获得运行</li><li>完成状态：作业运行结束，正在等待缓输出</li></ol></li><li>作业默认所有的资源调度都是静态调度(静态分配)完成的，输出井来完成。</li></ol><h2 id="17-2-批处理作业的状态作业调度与进程调度"><a href="#17-2-批处理作业的状态作业调度与进程调度" class="headerlink" title="17.2. 批处理作业的状态作业调度与进程调度"></a>17.2. 批处理作业的状态作业调度与进程调度</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/78.png"></p><ol><li>作业调度：按一定的策略选取若干个作业让它们进入内存、构成进程去竞争处理器以获得运行机会</li><li>用户立场：自己作业的周转时间尽可能的小</li><li>系统立场：希望进入系统的作业的平均周转时间尽可能的小</li><li>适当的作业调度算法必须既考虑用户的要求又有利于系统效率的提高</li></ol><h1 id="18-补充"><a href="#18-补充" class="headerlink" title="18. 补充"></a>18. 补充</h1><h2 id="18-1-习题-进程管理的fork系统调用"><a href="#18-1-习题-进程管理的fork系统调用" class="headerlink" title="18.1. 习题(进程管理的fork系统调用)"></a>18.1. 习题(进程管理的fork系统调用)</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/76.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/77.png"></th></tr></thead></table><ol><li>fork会克隆出一个新的进程，但是是同一个PC，也就是从父进程的当前步骤开始往下做</li><li>第一次fork A -&gt; B</li><li>第二次fork A -&gt; C, B -&gt; D</li><li>到三次fork A -&gt; E, B -&gt; F, C -&gt; G, D -&gt; H</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec2/78.png"></p><h2 id="18-2-阿里云平台"><a href="#18-2-阿里云平台" class="headerlink" title="18.2. 阿里云平台"></a>18.2. 阿里云平台</h2><ol><li>章文嵩:Linux集群，LVS，尽量节能</li><li>使用了灵动处理器</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.计算机系统概述</title>
    <link href="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/"/>
    <url>/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1. 计算机系统概述"></a>1. 计算机系统概述</h1><ol><li>电子数字计算机，是一种能够自行<strong>按照已设定的程序</strong>进行<strong>数据处理</strong>的电子设备；是软件与硬件相结合、面向系统、侧重应用的<strong>自动化求解</strong>工具</li><li>1946年，首台计算机ENIAC诞生于美国。</li><li>短短70年，计算机技术迅猛发展，从<strong>科学计算、数据处理</strong>等应用领域，迅速扩展到<strong>实时控制、辅助设计、智能模拟</strong>等诸多领域</li><li>今天计算机无所不在，深入社会生活的各个领域，深深改变了当今人类社会的组织行为</li><li>计算机系统包括<strong>计算机硬件系统和计算机软件系统</strong></li></ol><h2 id="1-1-计算机历史"><a href="#1-1-计算机历史" class="headerlink" title="1.1. 计算机历史"></a>1.1. 计算机历史</h2><ol><li>1945：电子真空管、机器语言，应用于科学计算</li><li>1956：晶体管、批处理控制、Fortran(科学计算的高级语言)&#x2F;COBOL(数据处理的高级语言)，扩展到数据处理领域</li><li>1959：集成电路、多道程序、操作系统&#x2F;数据库&#x2F;高级语言，应用领域继续扩展</li><li>1976：大规模&#x2F;超大规模集成电路，向快速化&#x2F;小型化&#x2F;系统化&#x2F;网络化&#x2F;智能化等方面发展</li><li>1980：微机出现，廉价化促使应用领域快速膨胀</li><li>1990：图形化人机交互技术，友善化推动了应用人群的快速扩展</li><li>2003：移动计算的出现，计算无处不在</li></ol><h2 id="1-2-计算机系统的组成"><a href="#1-2-计算机系统的组成" class="headerlink" title="1.2. 计算机系统的组成"></a>1.2. 计算机系统的组成</h2><blockquote><p>计算机系统：包括硬件子系统和软件子系统</p></blockquote><ol><li><strong>硬件</strong>：借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统工作的实体，包括CPU，主存储器，I&#x2F;O控制系统，外围设备等</li><li><strong>软件</strong>：各种程序和文件，用于指挥计算机系统按指定的要求进行协同工作<ol><li>包括系统软件、支撑软件和应用软件</li><li>关键系统软件是操作系统与语言处理程序</li></ol></li><li>系统软件(操作系统)层是最靠近硬件的一层软件。</li><li>操作系统和支撑软件、应用软件之间的主要区别<ol><li>操作系统有权利分配资源，支撑软件以及应用软件只能通过操作系统使用资源，两者为控制和被控制的关系。</li><li>操作系统直接作用在硬件上，隔离其他上层软件，并为其提供接口和服务。</li></ol></li></ol><h2 id="1-3-计算机系统的用户视图"><a href="#1-3-计算机系统的用户视图" class="headerlink" title="1.3. 计算机系统的用户视图"></a>1.3. 计算机系统的用户视图</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/10.png"></p><blockquote><p>系统程序员:面向硬件编程的程序员</p></blockquote><h1 id="2-计算机硬件系统"><a href="#2-计算机硬件系统" class="headerlink" title="2. 计算机硬件系统"></a>2. 计算机硬件系统</h1><h2 id="2-1-计算机硬件系统的组成"><a href="#2-1-计算机硬件系统的组成" class="headerlink" title="2.1. 计算机硬件系统的组成"></a>2.1. 计算机硬件系统的组成</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/11.png"></p><ol><li>中央处理器<ol><li>运算单元</li><li>控制单元</li></ol></li><li>主存储器</li><li>外围设备<ol><li>输出设备:显示器</li><li>输入设备:键盘、鼠标</li><li>存储设备:硬盘</li><li>网络通信设备:机机通信</li></ol></li><li>总线:连接硬件系统的部件</li></ol><h2 id="2-2-冯·诺依曼计算机特点"><a href="#2-2-冯·诺依曼计算机特点" class="headerlink" title="2.2. 冯·诺依曼计算机特点"></a>2.2. 冯·诺依曼计算机特点</h2><blockquote><p>冯·诺伊曼等人在1946年总结并明确提出，被称为冯·诺伊曼计算机模型</p></blockquote><ol><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h2 id="2-3-存储程序计算机的结构"><a href="#2-3-存储程序计算机的结构" class="headerlink" title="2.3. 存储程序计算机的结构"></a>2.3. 存储程序计算机的结构</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/12.png"></p><ol><li>当前计算机硬件的<strong>经典结构和主流组织</strong>方式</li><li><strong>存储器</strong>是这个模型的核心部分</li></ol><h2 id="2-4-总线及其组成"><a href="#2-4-总线及其组成" class="headerlink" title="2.4. 总线及其组成"></a>2.4. 总线及其组成</h2><h3 id="2-4-1-总线定义"><a href="#2-4-1-总线定义" class="headerlink" title="2.4.1. 总线定义"></a>2.4.1. 总线定义</h3><ol><li><strong>总线</strong>是计算机各种功能部件之间发送信息的<strong>公共通信干线</strong>，它是CPU、内存、输入输出设备传递信息的<strong>公用通道</strong></li><li>计算机的各个部件通过<strong>总线</strong>相连接，<strong>外围设备</strong>通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</li><li>按照所传输的信息种类，总线包括<ol><li>控制线</li><li>数据线</li><li>地址线</li></ol></li></ol><h3 id="2-4-2-总线分类"><a href="#2-4-2-总线分类" class="headerlink" title="2.4.2. 总线分类"></a>2.4.2. 总线分类</h3><p>各部件的速度差异很大</p><ol><li>内部总线:用于CPU芯片内部连接各元件</li><li>系统总线:用于连接CPU、存储器和各种I&#x2F;O模块等主要部件<ol><li>PCI总线用来连接块设备</li><li>E(ISA)主要是用来处理字符型输入设备，输入速度较慢</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/13.png"></p><ol start="3"><li>通信总线:用于计算机系统之间通信</li></ol><h3 id="2-4-3-补充知识"><a href="#2-4-3-补充知识" class="headerlink" title="2.4.3 补充知识"></a>2.4.3 补充知识</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/image-20230227104516179.png" alt="image-20230227104516179"></p><h2 id="2-5-中央处理器-CPU"><a href="#2-5-中央处理器-CPU" class="headerlink" title="2.5. 中央处理器 CPU"></a>2.5. 中央处理器 CPU</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1. 定义"></a>2.5.1. 定义</h3><p>中央处理器是计算机的<strong>运算核心</strong>(Core)和<strong>控制单元</strong>(Control Unit)</p><h3 id="2-5-2-CPU的组成"><a href="#2-5-2-CPU的组成" class="headerlink" title="2.5.2. CPU的组成"></a>2.5.2. CPU的组成</h3><ol><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：<ol><li>通用寄存器</li><li>控制与状态寄存器</li><li>高速缓冲存储器(Cache)   cache由SRAM(静态随机存储器)组成，比DRAM(动态随机存储器)实现的主存储器要快</li></ol></li><li>控制部件<ol><li>实现各部件间联系的数据、控制及状态的内部总线</li><li>负责对指令译码、发出为完成每条指令所要执行操作的控制信号、实现数据传输等功能的部件</li></ol></li></ol><h2 id="2-6-处理器和寄存器"><a href="#2-6-处理器和寄存器" class="headerlink" title="2.6. 处理器和寄存器"></a>2.6. 处理器和寄存器</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/14.png"></p><ol><li>运算单元:算术逻辑单元</li><li>控制单元:包括指令译码和中断的处理，以及一些重要的控制寄存器</li><li>内部总线</li><li>PC&#x2F;IR&#x2F;Flag:重要的控制寄存器</li><li>MAR&#x2F;MDR:和主存进行沟通的存储器</li><li>不包括的部分<ol><li>通用寄存器</li><li>Cache</li><li>IOAR&#x2F;IODR</li></ol></li></ol><h2 id="2-7-存储器的组织层次"><a href="#2-7-存储器的组织层次" class="headerlink" title="2.7. 存储器的组织层次"></a>2.7. 存储器的组织层次</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/15.png"></p><blockquote><p>主存及以上都是易失型设备</p></blockquote><h2 id="2-8-外围设备"><a href="#2-8-外围设备" class="headerlink" title="2.8. 外围设备"></a>2.8. 外围设备</h2><h3 id="2-8-1-设备类型"><a href="#2-8-1-设备类型" class="headerlink" title="2.8.1. 设备类型"></a>2.8.1. 设备类型</h3><ol><li>输入设备</li><li>输出设备</li><li>存储设备</li><li>网络设备:机机通信</li></ol><h3 id="2-8-2-控制方式"><a href="#2-8-2-控制方式" class="headerlink" title="2.8.2. 控制方式"></a>2.8.2. 控制方式</h3><ol><li>轮询方式:CPU忙式控制，CPU执行内存数据交换</li><li>中断方式:CPU启动外设，外设中断CPU，CPU执行内存数据交换</li><li>DMA方式:直接存储器访问(direct memory access)CPU启动DMA，DMA执行输入输出与内存数据交换，处理完成后，DMA中断CPU</li></ol><h3 id="2-8-3-SoC片上系统"><a href="#2-8-3-SoC片上系统" class="headerlink" title="2.8.3. SoC片上系统"></a>2.8.3. SoC片上系统</h3><ol><li>片上系统(SoC, System ona Chip)</li><li>在单个芯片上集成一个完整的系统，对所有或部分必要的电子电路进行包分组的技术</li><li>所谓完整的系统一般包括中央处理器(CPU)、存储器、以及外围电路等</li><li>SoC是与其它技术并行发展的，如绝缘硅(SOI)，它可以提供增强的时钟频率，从而降低微芯片的功耗</li></ol><h2 id="2-9-用户态和内核态"><a href="#2-9-用户态和内核态" class="headerlink" title="2.9. 用户态和内核态"></a>2.9. 用户态和内核态</h2><ol><li>用户态和内核态之间可以相互转化</li><li>内核态可以进行系统调用，完成中断处理</li></ol><h1 id="3-计算机软件系统"><a href="#3-计算机软件系统" class="headerlink" title="3. 计算机软件系统"></a>3. 计算机软件系统</h1><p>计算机系统三个抽象：进程抽象，虚存抽象，文件抽象</p><h2 id="3-1-计算机软件系统组成"><a href="#3-1-计算机软件系统组成" class="headerlink" title="3.1. 计算机软件系统组成"></a>3.1. 计算机软件系统组成</h2><ol><li>系统软件<ol><li>操作系统：实施对各种软硬件资源的管理控制（文件系统，进程的管理）</li><li>应用程序：为方便用户所设，如文本编辑等</li><li>语言处理程序：把用汇编语言&#x2F;高级语言编写的程序，翻译成可执行的机器语言程序</li><li>数据库管理系统</li></ol></li><li>支撑软件：支持用户使用计算机的环境，提供开发工具，也可以认为是系统软件的一部分。<ol><li>接口软件</li><li>工具软件</li><li>环境数据库等</li></ol></li><li>应用软件：是用户按其需要自行编写的专用程序</li></ol><h2 id="3-2-程序员的计算机系统视图"><a href="#3-2-程序员的计算机系统视图" class="headerlink" title="3.2. 程序员的计算机系统视图"></a>3.2. 程序员的计算机系统视图</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/16.png"></p><ol><li>计算机硬件系统:机器指令</li><li>操作系统与实用软件:扩展机器指令,系统调用、操作系统与应用软件</li><li>数据库语言:数据库管理系统，可以不再对流进行处理，而是处理对象式和关系式</li><li>语言处理系统:高级语言，变向对目标进行解决</li><li>支撑软件:使用软件工程工具</li></ol><h2 id="3-3-软件开发的不同层次"><a href="#3-3-软件开发的不同层次" class="headerlink" title="3.3. 软件开发的不同层次"></a>3.3. 软件开发的不同层次</h2><ol><li>计算机硬件系统：机器语言</li><li>操作系统之资源管理：机器语言+广义指令(扩充了硬件资源管理)</li><li>操作系统之文件系统：机器语言+系统调用(扩充了信息资源管理)</li><li>数据库管理系统：+数据库语言(扩充了功能更强的信息资源管理)</li><li>语言处理程序：面向问题的语言</li></ol><h2 id="3-4-计算机程序执行过程"><a href="#3-4-计算机程序执行过程" class="headerlink" title="3.4. 计算机程序执行过程"></a>3.4. 计算机程序执行过程</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/1.png"></p><blockquote><p>源程序是如何在硬件平台上进行处理如上图进行描述</p></blockquote><h1 id="4-计算机操作技术的发展"><a href="#4-计算机操作技术的发展" class="headerlink" title="4. 计算机操作技术的发展"></a>4. 计算机操作技术的发展</h1><h2 id="4-1-操作平台与操作系统"><a href="#4-1-操作平台与操作系统" class="headerlink" title="4.1. 操作平台与操作系统"></a>4.1. 操作平台与操作系统</h2><ol><li>任意一台机器都有其操作平台与操作系统<ol><li>例子: 洗衣机<ol><li>确定水量、洗衣时间、洗涤强度、洗衣粉</li><li>启动按钮</li><li>指示灯显示工作状态</li></ol></li><li>这一方式可以总结为:开关表示，按钮控制，亮灯显示操作平台的精细化和系统化，产生了操作系统</li></ol></li><li>计算机也不例外，由此产生了极为系统的计算机操作平台——计算机操作 系统</li><li>使用汇编语言的程序的编译运行程序为：汇编、执行</li><li>使用高级语言的程序的编译运行程序为：编译、链接、执行</li></ol><h2 id="4-2-计算机的手工操作"><a href="#4-2-计算机的手工操作" class="headerlink" title="4.2. 计算机的手工操作"></a>4.2. 计算机的手工操作</h2><ol><li>开关表示，按钮控制，亮灯显示</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/18.png"></p><ol start="2"><li>问题：手工操作速度与电子计算速度不匹配</li><li>最简单的操作系统的操作，非常复杂并且容易出错。</li></ol><h2 id="4-3-装入程序的引进"><a href="#4-3-装入程序的引进" class="headerlink" title="4.3. 装入程序的引进"></a>4.3. 装入程序的引进</h2><ol><li>引入卡片和纸带描述程序指令与数据</li><li>引入装入程序(Loader)<ol><li>自动化执行程序装入，必要时进行地址转换</li><li>通常存放在ROM中</li></ol></li><li>一般执行顺序是从机器语言程序到装入程序，再到内存储器。</li><li>装入程序的数据是非常麻烦的</li></ol><h2 id="4-4-引入汇编语言后的计算机控制"><a href="#4-4-引入汇编语言后的计算机控制" class="headerlink" title="4.4. 引入汇编语言后的计算机控制"></a>4.4. 引入汇编语言后的计算机控制</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/20.png"></p><p>添加进入高级语言之后，对计算机的操作变成了：编译、链接、执行。链接步骤很有价值，将一些共有的操作进行封装，引入库函数，使用链接器来解决共性问题。</p><h2 id="4-5-引入高级语言后的计算机控制"><a href="#4-5-引入高级语言后的计算机控制" class="headerlink" title="4.5. 引入高级语言后的计算机控制"></a>4.5. 引入高级语言后的计算机控制</h2><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/21.png"></p><blockquote><p>磁带相对更加不容易断裂</p></blockquote><h2 id="4-6-简单批处理系统的操作控制"><a href="#4-6-简单批处理系统的操作控制" class="headerlink" title="4.6. 简单批处理系统的操作控制"></a>4.6. 简单批处理系统的操作控制</h2><ol><li>简单批处理系统的处理过程<ol><li>引入作业控制语言，用户编写作业说明书，描述对一次计算机求解(作业)的控制</li><li>操作员控制计算机成批输入作业，成批执行作业</li></ol></li><li>这一方式明显<strong>缩短</strong>了手工操作的时间，提高了<strong>计算机系统利用率</strong></li><li>这一阶段，磁带的出现，使得卡片与纸带等机械输入方式得以进一步提高</li><li>简单批处理系统本质上是一种<strong>半自动化</strong>的操作方式，不算操作系统<ol><li>解决了<strong>手工操作和计算机机械操作</strong>不匹配的矛盾</li><li>没有解决了<strong>手工操作与中央处理器电子操作速度</strong>不匹配的矛盾</li><li>进一步减少了慢速外设的影响</li></ol></li><li>简单批处理系统的解决方案是允许多道程序同时运行，但是没有达到真正的多道程序设计</li></ol><h2 id="4-7-操作系统与自动化操作控制"><a href="#4-7-操作系统与自动化操作控制" class="headerlink" title="4.7. 操作系统与自动化操作控制"></a>4.7. 操作系统与自动化操作控制</h2><ol><li>电子计算速度与机械I&#x2F;O速度的矛盾：你在输，我在等</li><li>在程序执行过程中能否同时输入作业重叠时间<ol><li>需要多道程序同时执行</li><li>程序切换需要高速的外存储设备</li></ol></li><li>磁盘设备出现：计算机操作系统浓墨登场，实现了计算机系统的自动化控制</li><li>机械I&#x2F;O速度是难以显著提升的。</li><li>为什么随机存储可以成为计算机操作系统出现的基础?(课本267页)<ol><li>随机存储</li><li>线性存储:线性存储</li></ol></li><li>为什么随机存取很重要呢？<ol><li>因为操作系统引入了虚拟存储，虚拟分页，虚拟的地址空间需要1000个页框，但是我只给了100个页框进行使用，命中即为是这100个。</li><li>如果没有命中，则缺页，启动缺页中断处理，然后到磁盘中查找对应的页调入，寻找相对于磁带的形式而言非常大。让用户感觉不到有磁带的延时。</li></ol></li></ol><h1 id="5-计算机操作系统-OS"><a href="#5-计算机操作系统-OS" class="headerlink" title="5. 计算机操作系统 OS"></a>5. 计算机操作系统 OS</h1><h2 id="5-1-计算机操作系统-OS-Operating-System-的定义"><a href="#5-1-计算机操作系统-OS-Operating-System-的定义" class="headerlink" title="5.1. 计算机操作系统(OS, Operating System)的定义 *"></a>5.1. 计算机操作系统(OS, Operating System)的定义 *</h2><ol><li>OS是计算机系统<strong>最基础</strong>的系统软件，管理软硬件资源、控制程序执行，改善人机界面，提供各种服务，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。<ol><li>定位(<strong>计算机系统最基础的系统软件</strong>):处于硬件之上(最接近硬件)的系统软件</li><li>用途(<strong>管理软硬件资源</strong>):<ol><li>管理硬件资源，首先进行抽象，提供系统调用和中断等服务给上层资源使用。</li><li>管理软件资源，管理文件抽象的数据资源以及在操作系统环境下可能被启动运行的应用程序，并创建成进程，然后再为进程分配相应的资源，包括CPU资源、处理器资源、外设资源和程序运行中的文件系统需要的资源。也可以映射为三个基本抽象。</li></ol></li><li>用途(<strong>控制程序的执行</strong>):在操作系统环境下，加入的软件系统的实体，要被创建成一些进程，并由操作系统来统管所有的进程。</li><li>用途(<strong>改善人机界面</strong>):操作系统最终是呈现给终端用户使用，必须改善用户界面，方便人群使用。由于操作系统定位的人群不同，则风格不同，比如服务器的命令行控制。</li><li>用途(<strong>合理组织计算机工作流程</strong>):体现资源调度和管理</li><li>总结(<strong>为用户使用计算机提供良好运行环境</strong>)</li></ol></li><li>简而言之，操作系统是方便用户、管理和控制计算机软硬件资源的系统程序集合<ol><li>从<strong>用户角度</strong>看，OS管理计算机系统的各种资源，扩充硬件的功能，控制程序的执行</li><li>从<strong>人机交互</strong>看，OS是用户与机器的接口，提供良好的人机界面，方便用户使用计算机，在整个计算机系统中具有承上启下的地位</li><li>从<strong>系统结构</strong>看，OS是一个大型软件系统，其功能复杂，体系庞大，采用层次式、模块化的程序结构</li></ol></li><li>操作系统是软件系统的核心，与硬件一同构成了各种软件的基础服务平台。</li><li>操作系统在计算机系统中的作用(P11)：<ol><li>服务用户：操作系统作为用户接口和公共服务程序。</li><li>进程交互：操作系统作为进程执行的控制者和协调者。</li><li>系统实现：操作系统作为扩展机或虚拟机。</li><li>资源管理：操作系统作为资源你的管理者和控制者。</li></ol></li></ol><h2 id="5-2-操作系统的组成"><a href="#5-2-操作系统的组成" class="headerlink" title="5.2. 操作系统的组成"></a>5.2. 操作系统的组成</h2><blockquote><p>文件系统的核心目标是实现按名存取</p></blockquote><table><thead><tr><th>操作系统组成的子系统</th><th>描述</th></tr></thead><tbody><tr><td>进程调度子系统</td><td>负责管理调度进程</td></tr><tr><td>进程通信子系统</td><td>负责进程间的通信解决方案</td></tr><tr><td>内存管理子系统</td><td>负责管理内存与虚存</td></tr><tr><td>设备管理子系统</td><td>负责管理我们的外围设备</td></tr><tr><td>文件管理子系统</td><td>负责管理文件信息，提供系统调用，Linux需要考虑如何在线性的地址空间，如何建立非线性的层次式目录结构以实现按名存储</td></tr><tr><td>网络通信子系统</td><td>实现网络操作系统，涉及到分布式等</td></tr><tr><td>作业控制子系统</td><td>提供用户操作控制计算机系统，在服务器、云计算等资源虚拟化环境下</td></tr></tbody></table><h2 id="5-3-操作系统的类型"><a href="#5-3-操作系统的类型" class="headerlink" title="5.3. 操作系统的类型"></a>5.3. 操作系统的类型</h2><h3 id="5-3-1-从控制方式来看"><a href="#5-3-1-从控制方式来看" class="headerlink" title="5.3.1. 从控制方式来看"></a>5.3.1. 从控制方式来看</h3><ol><li>多道批处理操作系统<ol><li>采用<strong>脱机控制</strong>方式</li><li>程序员通过作业说明来描述对作业的控制方式</li><li>操作员根据说明书来成批加载作业和控制计算机系统</li><li>优点：资源利用率高，作业吞吐量大</li><li>缺点：作业周转周期长、不具备交互式计算能力，不利于程序的开发和测试</li></ol></li><li>分时(Time Sharing)操作系统:交互控制，核心是划分CPU的时间<ol><li>时间片调度思想:CPU的时间等分</li><li>在终端上进行交互式会话，具有同时性、独立性、及时性和交互性的特点。</li><li>和批处理操作系统区别：追求目标、适应作业、资源利用率不同。</li><li>Eg:100MHz的CPU，如果有10个终端用户使用，那么一个终端用户大概使用10MHz的CPU来使用</li></ol></li><li>实时(Real Timing)操作系统:支持分时交互，又有大量的进程处理突发任务<ol><li>硬实时:最严格的实时操作系统</li><li>软实时:可以在某些地方不严格</li></ol></li><li>如果某个操作系统兼具批处理、分时和实时处理的全部或两种功能，则可以被称为通用操作系统。</li></ol><h3 id="5-3-2-从应用领域领域来看"><a href="#5-3-2-从应用领域领域来看" class="headerlink" title="5.3.2. 从应用领域领域来看"></a>5.3.2. 从应用领域领域来看</h3><ol><li>服务器操作系统:并行操作系统</li><li>网络操作系统:分布式操作系统</li><li>个人机操作系统:手机操作系统</li><li>嵌入式操作系统:传感器操作系统</li></ol><h2 id="5-4-操作系统功能和特性"><a href="#5-4-操作系统功能和特性" class="headerlink" title="5.4. 操作系统功能和特性"></a>5.4. 操作系统功能和特性</h2><h3 id="5-4-1-操作系统功能"><a href="#5-4-1-操作系统功能" class="headerlink" title="5.4.1. 操作系统功能"></a>5.4.1. 操作系统功能</h3><ol><li>处理器管理：对处理器的管理和调度最终归结为对进程和线程的管理和调度，最大限度提高处理器利用率。</li><li>存储管理：管理内存资源，提供存储空间利用率。</li><li>设备管理：管理各种外部设备，完成用户提出的I&#x2F;O请求;加快数据传输速度，发挥设备的并行性，提高设备的利用率;提供设备驱动程序和中断处理程序,为用户隐蔽硬件操作细节，提供简单的设备使用方法</li><li>文件管理：针对信息资源的管理。</li><li>联网与通信管理：<ol><li>网络资源管理</li><li>数据通信管理</li><li>应用服务</li><li>网络管理</li></ol></li></ol><h3 id="5-4-2-操作系统特性"><a href="#5-4-2-操作系统特性" class="headerlink" title="5.4.2. 操作系统特性"></a>5.4.2. 操作系统特性</h3><ol><li>并发性：<ol><li>并发性指两个或两个以上的活动或事件在同一时间间隔内发生。</li><li>采用并发技术的系统又称多任务处理系统</li><li>并行性指两个或两个以上的活动或事件在同一时刻发生，存在于多CPU系统中。</li><li>并行一定并发，并发不一定并行</li><li>并发的关键技术是对系统的多个运行程序(进程)进行切换的技术。</li></ol></li><li>共享性：<ol><li>计算机系统中的资源可以被多个并发执行的程序共同使用，而不是被某个程序独占</li><li>划分：<ol><li>透明资源共享：必须处理好资源隔离和授权访问问题</li><li>独占资源共享：排他性地使用一类资源</li></ol></li></ol></li><li>并发性和共享性互相依存，没有并发就不必讨论共享，做不到共享也就导致做不到并发。</li><li>异步性(随机性)：并发活动导致随机事件的产生。操作系统需要保证只要运行环境相同，多次运行同一程序，都会获得完全相同的计算结果。</li></ol><h2 id="5-5-操作系统的形成"><a href="#5-5-操作系统的形成" class="headerlink" title="5.5. 操作系统的形成"></a>5.5. 操作系统的形成</h2><ol><li>中断和通道技术的出现使得硬件具备并行工作的能力。</li></ol><h1 id="6-操作系统资源管理"><a href="#6-操作系统资源管理" class="headerlink" title="6. 操作系统资源管理"></a>6. 操作系统资源管理</h1><blockquote><ol><li>解决物理资源数量不足的问题</li><li>合理分配资源</li><li>实现资源的易用性</li></ol></blockquote><ol><li>硬件资源：处理器、内存和外设(字符型设备等)</li><li>信息资源(可以理解为软件资源)：数据和程序</li></ol><h2 id="6-1-管理计算机系统的软硬件资源"><a href="#6-1-管理计算机系统的软硬件资源" class="headerlink" title="6.1. 管理计算机系统的软硬件资源"></a>6.1. 管理计算机系统的软硬件资源</h2><ol><li>处理器资源：哪个程序占有处理器运行？</li><li>内存资源：程序&#x2F;数据在内存中如何分布？</li><li>设备管理：如何分配、去配和使用设备？</li><li>信息资源管理：如何访问文件信息？</li><li>信号量资源：如何管理进程之间的通信？信号量(-&gt;数据结构)与PV原理(-&gt;原语操作):重要</li></ol><h2 id="6-2-资源管理最重要的是：屏蔽资源使用的底层细节"><a href="#6-2-资源管理最重要的是：屏蔽资源使用的底层细节" class="headerlink" title="6.2. 资源管理最重要的是：屏蔽资源使用的底层细节"></a>6.2. 资源管理最重要的是：屏蔽资源使用的底层细节</h2><ol><li>驱动程序：最底层的、直接控制和监视各类硬件(或文件)资源的部分</li><li>职责是<strong>隐藏底层硬件的具体细节</strong>，并向<strong>其他部分提供一个抽象的、通用的接口</strong></li><li>比如说：打印一段文字或一个文件，既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节</li></ol><h2 id="6-3-资源管理技术"><a href="#6-3-资源管理技术" class="headerlink" title="6.3. 资源管理技术"></a>6.3. 资源管理技术</h2><ol><li>复用<ol><li>空分复用共享，例如内存和外存资源是空分复用的关系、磁盘上进行空分复用</li><li>时分复用共享<ol><li>按照资源物理特性分为<ol><li>独占式</li><li>时分共享式</li></ol></li><li>例如：磁带机与磁盘机</li></ol></li></ol></li><li>虚拟(虚拟性)<ol><li>本质：对资源进行转化、模拟或整合，将一个物理资源变成多个逻辑上的对应物，也可以将多个物理资源编程单个逻辑上的对应物，达到多个用户共享一套计算机物理资源的目的。</li><li>复用划分实际存在的物理资源，虚拟则实现假想的虚拟同类资源。</li><li>例子：虚拟内存、虚拟文件系统(VFS)。</li></ol></li><li>抽象：<ol><li>目的：为了处理系统复杂性，重点解决资源易用性。</li><li>资源抽象：不考虑物理细节而对资源执行操作的技术。</li><li>抽象层次越高，使用越方便。</li></ol></li><li>组合使用多种资源管理技术</li></ol><h2 id="6-4-重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象"><a href="#6-4-重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象" class="headerlink" title="6.4. 重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象"></a>6.4. 重要：操作系统的基础抽象——进程抽象、虚存抽象和文件抽象</h2><ol><li>计算机物理资源划分：<ol><li>计算及存储类：包含处理器和内存等</li><li>接口类：包含外存和外部处理器等</li></ol></li><li>为方便对物理资源的管理和控制，现代操作系统引入了：进程、虚拟和文件，形成了三种最基础的抽象。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/3.png"></p><h3 id="6-4-1-进程抽象"><a href="#6-4-1-进程抽象" class="headerlink" title="6.4.1. 进程抽象"></a>6.4.1. 进程抽象</h3><ol><li>进程是对进入内存的执行程序在处理器上操作的状态集的一个抽象。</li><li>进程是并发和并行操作的基础。</li><li>进程可以使用fork()、wait()、exec()等系统调用。</li><li>进程的执行依赖于内存和设备上的信息资源。</li></ol><h3 id="6-4-2-虚存抽象"><a href="#6-4-2-虚存抽象" class="headerlink" title="6.4.2. 虚存抽象"></a>6.4.2. 虚存抽象</h3><ol><li>虚拟内存的本质是在物理内存的基础上创建一个新的抽象概念。</li><li>虚存抽象保证了安全性</li><li>进程的执行还依赖于存放在内存中的程序和数据，而他们往往存储在设备上，所以我们需要对设备进行抽象。</li></ol><h3 id="6-4-3-文件抽象"><a href="#6-4-3-文件抽象" class="headerlink" title="6.4.3. 文件抽象"></a>6.4.3. 文件抽象</h3><ol><li>文件是设备的一种抽象，通过将文件的字节映射到存储设备的物理块中来实现文件抽象。</li><li>提供了open()、read()和write()等方法来控制和使用文件。</li><li>磁盘、光盘等外存设备都有极其复杂的物理接口，通常我们将其抽象，使得所存放柜的信息可以表示为一个命名的逻辑字节流，称其为文件，这是资源抽象的一个特例。</li><li>为了管理方便，操作系统将除处理器和内存以外，将磁盘和其他外部设备资源都抽象为文件，减少系统开销，复用系统调用。</li></ol><h3 id="6-4-4-三种抽象综述"><a href="#6-4-4-三种抽象综述" class="headerlink" title="6.4.4. 三种抽象综述"></a>6.4.4. 三种抽象综述</h3><ol><li>操作系统基本任务<ol><li>防止硬件资源被失控的应用程序滥用。</li><li>屏蔽复杂的硬件操作细节。</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/2.png"></p><h3 id="6-4-5-其他资源抽象"><a href="#6-4-5-其他资源抽象" class="headerlink" title="6.4.5. 其他资源抽象"></a>6.4.5. 其他资源抽象</h3><ol><li>与设备抽象相似，操作系统还对其他底层硬件资源进行了抽象。</li><li>资源抽象也可以用于没有特定基础硬件的软甲资源，如信息、信号量和共享数据结构。</li><li>对象和抽象数据类型是常用于创建抽象资源的软件机制。</li></ol><h2 id="6-5-操作系统虚拟机"><a href="#6-5-操作系统虚拟机" class="headerlink" title="6.5. 操作系统虚拟机"></a>6.5. 操作系统虚拟机</h2><ol><li>物理CPU：时分共享复用，实现虚处理器</li><li>物理内存：虚拟存储技术，实现虚内存</li><li>独占型I&#x2F;O设备：SPOOLing技术，实现虚设备</li><li>磁盘设备：通过文件抽象，实现虚外存</li></ol><h2 id="6-6-资源的共享与分配方式"><a href="#6-6-资源的共享与分配方式" class="headerlink" title="6.6. 资源的共享与分配方式"></a>6.6. 资源的共享与分配方式</h2><ol><li>资源共享方式<ol><li><strong>独占</strong>使用方式:只能被一个程序使用</li><li><strong>并发</strong>使用方式:在同一时段可以被多个程序使用，虚拟共享Spooling</li></ol></li><li>资源分配策略:对于独占使用方式的分配方式<ol><li><strong>静态</strong>分配方式，运行程序进入内存前已经将所有的内存完成分配，好处是不会死锁，坏处是效率低，使用效率低</li><li><strong>动态</strong>分配方式，随用随分配，可能导致死锁</li><li><strong>资源抢占</strong>方式，如果你在使用，我的优先级高，我可以抢过来使用，但是涉及到保存状态的问题</li></ol></li></ol><h1 id="7-程序控制角度"><a href="#7-程序控制角度" class="headerlink" title="7. 程序控制角度"></a>7. 程序控制角度</h1><h2 id="7-1-多道程序同时计算"><a href="#7-1-多道程序同时计算" class="headerlink" title="7.1. 多道程序同时计算"></a>7.1. 多道程序同时计算</h2><ol><li>CPU速度与I&#x2F;O速度不匹配的矛盾，非常突出</li><li>只有让多道程序同时进入内存争抢CPU运行，才可以够使得CPU和外围设备充分并行，从而提高计算机系统的使用效率</li><li>例如：百度的搜索引擎</li></ol><h2 id="7-2-多道程序同时计算例子"><a href="#7-2-多道程序同时计算例子" class="headerlink" title="7.2. 多道程序同时计算例子"></a>7.2. 多道程序同时计算例子</h2><table><thead><tr><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/5.png"></th><th><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/23.png"></th></tr></thead></table><ol><li>对于甲、乙两道程序，如果两个程序的操作之间是没有冲突的<ol><li>独占计算机单道运行时均需1小时，占用CPU时间18分钟，CPU利用率为30％</li><li>按多道程序设计方法同时运行，CPU利用率50%，由于要提供36分钟的CPU时间，大约运行72分钟。考虑到OS调度开销，实际花费时间还要长些，如80分钟</li></ol></li><li>就处理两道作业而言，提高效率33％，整体的系统的吞吐率会高</li><li>就单道作业而言，延长执行时间20分钟，即延长了33％的时间</li><li>可以采用概率方法计算CPU的利用率，假设程序平均等待I&#x2F;O 操作的时间占其运行时间的比例为P，当内存中有n道程序时，所有程序都等待I&#x2F;O操作的概率是$P^n$，即此时CPU利用率&#x3D;$1-P^n$，其中n称为多道程序的道数或度数</li></ol><h2 id="7-3-多道程序设计及优点"><a href="#7-3-多道程序设计及优点" class="headerlink" title="7.3. 多道程序设计及优点"></a>7.3. 多道程序设计及优点</h2><ol><li>多道程序设计：<strong>指允许多个作业(程序)同时进入计算机系统的内存并启动交替计算的方法</strong></li><li>多道程序设计的特点<ol><li>CPU与外部设备充分并行</li><li>外部设备之间充分并行</li><li>发挥CPU、内存和设备的使用效率</li><li>提高单位时间的算题量(吞吐率)</li></ol></li><li>多道程序设计的主要缺点：延长了作业的周转时间。</li></ol><h2 id="7-4-多道程序系统的实现"><a href="#7-4-多道程序系统的实现" class="headerlink" title="7.4. 多道程序系统的实现"></a>7.4. 多道程序系统的实现</h2><ol><li>进入内存执行的程序建立管理实体：<strong>进程</strong>动态概念，驻留在操作系统中</li><li>OS应该能管理与控制进程程序的执行</li><li>OS协调管理各类资源在进程间的使用<ol><li>处理器的管理和调度</li><li>主存储器的管理和调度</li><li>其他资源的管理和调度</li><li>信号量的管理和调度</li></ol></li></ol><h2 id="7-5-多道程序系统的实现要点"><a href="#7-5-多道程序系统的实现要点" class="headerlink" title="7.5. 多道程序系统的实现要点"></a>7.5. 多道程序系统的实现要点</h2><ol><li>如何使用资源：调用操作系统提供的服务例程(如何陷入操作系统)</li><li>如何复用CPU：调度程序(在CPU空闲时让其他程序运行)</li><li>如何使CPU与I&#x2F;O设备充分并行：设备控制器与通道(专用的I&#x2F;O处理器)</li><li>如何让正在运行的程序让出CPU：中断(中断正在执行的程序，引入OS处理)，能够恢复现场而不是从头运行</li><li>需要注意的是道数是受到物理资源的制约的。</li></ol><h2 id="7-6-多道程序系统需要处理的问题"><a href="#7-6-多道程序系统需要处理的问题" class="headerlink" title="7.6. 多道程序系统需要处理的问题"></a>7.6. 多道程序系统需要处理的问题</h2><ol><li>存储保护与程序浮动</li><li>处理器管理与分配</li><li>资源管理与调度</li></ol><h1 id="8-操作系统控制计算机的角度"><a href="#8-操作系统控制计算机的角度" class="headerlink" title="8. 操作系统控制计算机的角度"></a>8. 操作系统控制计算机的角度</h1><h2 id="8-1-计算机系统操作方式"><a href="#8-1-计算机系统操作方式" class="headerlink" title="8.1. 计算机系统操作方式"></a>8.1. 计算机系统操作方式</h2><ol><li>OS规定了合理操作计算机的工作流程</li><li>OS的操作接口——系统程序：OS提供给用户的功能级接口，为用户提供的解决操作计算机和计算共性问题的所有服务的集合</li><li>OS的两类作业级接口<ol><li>脱机作业控制方式：作业控制语言，比如批处理</li><li>联机作业控制方式：操作控制命令</li></ol></li></ol><h3 id="8-1-1-脱机作业控制方式"><a href="#8-1-1-脱机作业控制方式" class="headerlink" title="8.1.1. 脱机作业控制方式"></a>8.1.1. 脱机作业控制方式</h3><ol><li>脱机作业控制的各角色工作<ol><li>OS提供<strong>作业说明语言</strong>，通过作业控制程序自动控制作业的执行</li><li>用户编写<strong>作业说明书</strong>，确定作业加工控制步骤，并与程序数据一并提交</li><li>操作员通过控制台输入作业</li></ol></li><li>例：批处理OS的作业控制方式，UNIX的shell程序，DOS的bat文件</li><li>多道批处理：可以多道作业交替占用处理器运行</li></ol><h3 id="8-1-2-联机作业控制方式"><a href="#8-1-2-联机作业控制方式" class="headerlink" title="8.1.2. 联机作业控制方式"></a>8.1.2. 联机作业控制方式</h3><ol><li>联机作业控制方式的各角色工作<ol><li>计算机提供终端</li><li>用户登录系统</li><li>OS提供命令解释程序</li><li>用户进行联机输入命令，直接控制作业步的执行</li></ol></li><li>例：分时OS的交互控制方式</li><li>图形化无非就是把上述操作图形化了而已</li></ol><h2 id="8-2-命令解释程序"><a href="#8-2-命令解释程序" class="headerlink" title="8.2. 命令解释程序"></a>8.2. 命令解释程序</h2><ol><li>命令解释程序：接受和执行一条用户提出的对作业的加工处理命令</li><li>当一个新的批作业被启动，或新的交互型用户登录进系统时，系统就自动地执行命令解释程序，负责读入控制卡或命令行，作出相应解释，并予以执行</li><li>实现方式<ol><li>命令解释语言包含命令的执行代码，一旦收到命令后，就转向相应的命令处理代码执行，执行过程中往往会使用到系统调用</li><li>由专用的实用程序实现，执行时将命令所对应的命令处理文件装入内存</li></ol></li><li>会话语言：可编程的命令解释程序，UNIX的Shell</li><li>图形化的命令控制方式</li><li>多通道交互的命令控制方式</li></ol><h2 id="8-3-命令解释程序的处理过程"><a href="#8-3-命令解释程序的处理过程" class="headerlink" title="8.3. 命令解释程序的处理过程"></a>8.3. 命令解释程序的处理过程</h2><ol><li>OS启动命令解释程序，输出命令提示符，等待键盘中断&#x2F;鼠标点击&#x2F;多通道识别</li><li>每当用户输入一条命令(暂存在命令缓冲区)并按回车换行时，申请中断</li><li>CPU响应后，将控制权交给命令解释程序，接着读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li><li>前台命令执行结束后，再次输出命令提示符，等待下一条命令</li><li>后台命令处理启动后，即可接收下条命令</li></ol><h2 id="8-4-OS内核是中断驱动的"><a href="#8-4-OS内核是中断驱动的" class="headerlink" title="8.4. OS内核是中断驱动的"></a>8.4. OS内核是中断驱动的</h2><blockquote><p>等价表述</p></blockquote><ol><li>OS内核是中断驱动的</li><li>中断是激活操作系统的唯一方式</li></ol><h1 id="9-人机交互的角度"><a href="#9-人机交互的角度" class="headerlink" title="9. 人机交互的角度"></a>9. 人机交互的角度</h1><ol><li>OS改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括<strong>传统的终端设备</strong>和<strong>新型的模式识别设备</strong></li><li>OS的人机交互部分用于<strong>控制有关设备运行</strong>和<strong>理解执行设备传来的命令</strong></li><li>人机交互功能是决定计算机系统<strong>友善性</strong>的重要因素，是当今OS<strong>研发热点</strong></li></ol><h2 id="9-1-人机交互的初期发展"><a href="#9-1-人机交互的初期发展" class="headerlink" title="9.1. 人机交互的初期发展"></a>9.1. 人机交互的初期发展</h2><ol><li>交互式控制方式<ol><li>行命令控制方式：1960年代开始使用，一行一行进行编辑</li><li>全屏幕控制方式：1970年代开始使用</li></ol></li><li>斯坦福研究所提出的发展计划<ol><li>始于1960年代，1980年代广泛应用</li><li>强调<strong>人</strong>而不是<strong>技术</strong>是<strong>人机交互</strong>的中心</li><li>代表性成果：鼠标、菜单与窗口控制(单窗口)</li></ol></li></ol><h2 id="9-2-人机交互发展-WIMP界面"><a href="#9-2-人机交互发展-WIMP界面" class="headerlink" title="9.2. 人机交互发展-WIMP界面"></a>9.2. 人机交互发展-WIMP界面</h2><ol><li>缘起：70年代后期Xerox的原型机Star</li><li>特征：窗口(Windows) (多窗口)、图标(Icons)、菜单(Menu) 和指示装置(Pointing Devices)为基础的图形用户界面WIMP</li><li>得益：Apple最初采用并大力推动</li><li>时间：1990年代开始广泛使用</li><li>不足：不允许同时使用多个交互通道，从而产生人-机交互的不平衡</li><li>Apple的界面是WIWP的顶峰</li></ol><h2 id="9-3-人机交互发展-多媒体计算机"><a href="#9-3-人机交互发展-多媒体计算机" class="headerlink" title="9.3. 人机交互发展-多媒体计算机"></a>9.3. 人机交互发展-多媒体计算机</h2><ol><li>缘起：1985年的MPC</li><li>把音频视屏、图形图像和人机交互控制结合起来，进行综合处理的计算机系统</li><li>构成：多媒体硬件平台、多媒体OS 、图形用户接口、多媒体数据开发工具</li><li>提供与时间有关的<strong>时变媒体(何时体现感觉更好)<strong>界面，既控制</strong>信息呈现</strong>，也控制何<strong>时呈现&#x2F;如何呈现</strong></li><li>人机交互界面需要使用多种媒体，同时支持多通道交互整合，改善用户体验</li></ol><h2 id="9-4-人机交互发展-虚拟现实系统-临境系统"><a href="#9-4-人机交互发展-虚拟现实系统-临境系统" class="headerlink" title="9.4. 人机交互发展-虚拟现实系统(临境系统)"></a>9.4. 人机交互发展-虚拟现实系统(临境系统)</h2><ol><li>缘起：1980年代的虚拟现实新型用户界面</li><li>VR通过计算机模拟三维虚拟世界，根据<strong>观察点</strong>、观察点改变的<strong>导航</strong>和对周围对象的操作，来模拟<strong>临境</strong>(身临其境)的感觉</li><li>支持多通道交互整合，改善用户体验</li><li>支持用户主动参与的高度自然的<strong>三维</strong>HCI，以及<strong>语音识别、头部跟踪、视觉跟踪、姿势识别</strong>等新型HCI</li><li>容许用户产生含糊和不精确的输入</li></ol><h1 id="10-程序接口的角度"><a href="#10-程序接口的角度" class="headerlink" title="10. 程序接口的角度"></a>10. 程序接口的角度</h1><h2 id="10-1-系统调用"><a href="#10-1-系统调用" class="headerlink" title="10.1. 系统调用"></a>10.1. 系统调用</h2><ol><li>操作系统的程序接口：系统调用<ol><li>操作系统实现的完成某种特定功能的过程</li><li>为所有运行程序提供访问操作系统的接口</li></ol></li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/24.png"></p><ol start="3"><li>为什么会出现系统调用？对上层如果暴露过于细粒度的操作，违背了<strong>软件复用</strong>的原则，所以我们将一系列的操作封装起来，作为系统调用来暴露。</li><li>为什么操作系统不能使用名空间?(没有高级语言，为什么不可以通过名字来调用):操作系统处于系统底层之上，是不可以将高阶的名字，翻译成计算机操作系统可以理解的地址。底层是通过地址号来调用，而我们的按名访问本质上也只是完成了从名空间到地址空间的映射而已<ol><li>操作系统诞生了名空间</li><li>文件系统需要使用名空间</li></ol></li><li>以32位系统为例，每个地址占4字节，以入口地址表的起地址$x_0$作为起点，依据功能号向下偏移$4*i$，读取系统调用处理子程序$Sub_i$的入口地址，然后执行$SUB_i$，执行完成之后，再返回用户空间。</li><li>没有名称空间 -&gt; 通过指针的地址计算做定位，表驱动按号索引，按号索引的前提是:<ol><li>数据必须是按号连续排列的</li><li>表中的各数据结构的规格是一致的</li></ol></li></ol><h2 id="10-2-系统调用的实现机制"><a href="#10-2-系统调用的实现机制" class="headerlink" title="10.2. 系统调用的实现机制"></a>10.2. 系统调用的实现机制</h2><ol><li>陷入处理机制：计算机系统中控制和实现系统调用的机制</li><li>陷入指令：也称<strong>访管指令</strong>，或<strong>异常中断指令</strong>，计算机系统为实现系统调用而引起处理器中断的指令</li><li>每个系统调用都事先规定了<strong>编号</strong>，并在<strong>约定</strong>寄存器中规定了传递给内部处理程序的参数</li><li>参数传递方法<ol><li>访管指令或自陷指令自带参数，参数放置在指令后的若干单元，叫直接参数</li><li>指令后放置参数的地址，叫间接指令</li><li>通过CPU的通用寄存器传递参数，不适用于大量参数传递</li><li>在内存中开辟专门堆栈区传递参数</li></ol></li><li>操作系统实现系统调用的机制被称为陷阱或异常处理机制。</li><li>由系统调用引起处理器中断的机器指令称为访管指令、自陷指令或中断指令，其中访管指令为非特权指令。</li></ol><h2 id="10-3-系统调用的实现要点"><a href="#10-3-系统调用的实现要点" class="headerlink" title="10.3. 系统调用的实现要点"></a>10.3. 系统调用的实现要点</h2><ol><li>编写系统调用处理程序</li><li>设计一张<strong>系统调用入口地址表</strong>，每个入口地址指向一个系统调用的处理程序，并包含系统调用自带参数的个数</li><li>陷入处理机制需开辟现场保护区，以保存发生系统调用时的处理器现场</li></ol><h2 id="10-4-系统调用的实现流程"><a href="#10-4-系统调用的实现流程" class="headerlink" title="10.4. 系统调用的实现流程"></a>10.4. 系统调用的实现流程</h2><ol><li>由硬件和操作系统来合作完成<ol><li>中断是由硬件完成的</li><li>查入口地址和调用是由操作系统完成的</li></ol></li><li>CPU执行程序中编写的由访管指令实现的系统调用时会产生异常，通过陷阱机制，处理器的状态由用户态转换为内核态，进入操作系统并执行相应的服务例程，以获得操作系统服务。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/7.png"></p><blockquote><ol><li>SUB子程序部分是绝对不能向用户暴露的，很危险</li><li>A部分，可以通过地址偏移来发起调用，$4*i+x_0$调用的是第i号系统调用。</li></ol></blockquote><ol><li>处理器状态包括用户态、内核态<ol><li>用户态对应非特权指令</li><li>内核态对应特权和非特权指令</li></ol></li><li>Linux中是通过为每个系统调用构造一个同名封装函数，将系统调用封装后供用户编程使用，详见P25</li></ol><h3 id="10-4-1-Transition-from-user-to-kernel-mode"><a href="#10-4-1-Transition-from-user-to-kernel-mode" class="headerlink" title="10.4.1. Transition from user to kernel mode"></a>10.4.1. Transition from user to kernel mode</h3><ol><li>特权指令和非特权指令混编实现代码</li><li>如下图的Linux系统调用执行流程：两个进程之间切换，会损失一定的时间(内核消耗时间)，应该是会非常快速的进行切换的。</li></ol><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/4.png"></p><blockquote><p>更多过程见课本P31-34</p></blockquote><h2 id="10-5-系统调用和函数调用之间的区别"><a href="#10-5-系统调用和函数调用之间的区别" class="headerlink" title="10.5. 系统调用和函数调用之间的区别"></a>10.5. 系统调用和函数调用之间的区别</h2><table><thead><tr><th></th><th>系统调用</th><th>函数调用</th></tr></thead><tbody><tr><td>调用形式</td><td>按地址转向</td><td>功能号调用</td></tr><tr><td>实现方式</td><td>用户态转换内核态，在内核态执行访问核心栈</td><td>用户态</td></tr><tr><td>被调用代码位置</td><td>动态调用，服务例程位于操作系统内</td><td>静态调用，调用程序和被调用程序在同一程序内</td></tr><tr><td>提供方式</td><td>由操作系统提供</td><td>编程语言提供</td></tr></tbody></table><h1 id="11-系统结构的角度"><a href="#11-系统结构的角度" class="headerlink" title="11. 系统结构的角度"></a>11. 系统结构的角度</h1><h2 id="11-1-操作系统软件的规模"><a href="#11-1-操作系统软件的规模" class="headerlink" title="11.1. 操作系统软件的规模"></a>11.1. 操作系统软件的规模</h2><ol><li>在计算机软件发展史上，OS是第一个大规模的软件系统</li><li>1960年代，由OS开发所衍生的体系结构、模块化开发、测试与验证、演化与维护等研究，直接催生了软件工程这一新兴研究领域(另一个催生来源是DB应用引发的需求与规格)</li><li>OS作为大型软件，结构设计是关键</li></ol><h2 id="11-2-操作系统软件的结构设计"><a href="#11-2-操作系统软件的结构设计" class="headerlink" title="11.2. 操作系统软件的结构设计"></a>11.2. 操作系统软件的结构设计</h2><blockquote><p>内核设计是OS设计中最为复杂的部分</p></blockquote><h3 id="11-2-1-OS构件"><a href="#11-2-1-OS构件" class="headerlink" title="11.2.1. OS构件"></a>11.2.1. OS构件</h3><ol><li>内核:核心的部分，操作系统必须有一个内核<ol><li>一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作，通常驻留在内核空间，运行于内核他，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行特权指令的程序。</li><li>内核的功能<ol><li>中断处理</li><li>时钟管理</li><li>短程调度</li><li>原语管理：原语是内核中实现特定功能的不可中断过程<ol><li>原语由内核实现，系统调用由系统进程实现</li><li>例子：通信原语、同步原语、I&#x2F;O设备原语</li></ol></li></ol></li><li>内核的属性<ol><li>内核是由中断驱动的</li><li>内核是不可抢占的</li><li>内核可以在屏蔽中断状态下进行</li><li>内核可以使用特权指令</li></ol></li></ol></li><li>进程</li><li>线程</li><li>管程</li></ol><h3 id="11-2-2-设计概念"><a href="#11-2-2-设计概念" class="headerlink" title="11.2.2. 设计概念"></a>11.2.2. 设计概念</h3><ol><li>模块化</li><li>层次式</li><li>虚拟化</li></ol><h3 id="11-2-3-操作系统内核"><a href="#11-2-3-操作系统内核" class="headerlink" title="11.2.3. 操作系统内核"></a>11.2.3. 操作系统内核</h3><ol><li>单内核：内核中各部件杂然混居的形态，始于1960年代，广泛使用；如Unix&#x2F;Linux，及Windows(自称采用混合内核的CS结构)，单内核导致内核会非常大</li></ol><blockquote><p>单内核结构的操作系统:写错了的Tanebaum,2015</p></blockquote><ol start="2"><li>微内核：<ol><li>仅将所有应用必须的核心功能放入内核，其他功能都在内核之外，由在用户态运行的服务进程实现</li><li>1980年代始，强调结构性部件与功能性部件的分离，大部分OS研究都集中在此，效率不高</li><li>详见课本P37页</li></ol></li></ol><blockquote><p>微内核结构的操作系统，存在一定的不确定性，会增加切换的次数，带来一定的性能损耗</p></blockquote><ol start="3"><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行，以获得更快的执行速度</li><li>外内核：尽可能减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化；部分嵌入式系统使用</li></ol><blockquote><p>安卓内核架构、C&#x2F;S(Client&#x2F;Server)模型</p></blockquote><h3 id="11-2-4-单内核和微内核对比"><a href="#11-2-4-单内核和微内核对比" class="headerlink" title="11.2.4. 单内核和微内核对比"></a>11.2.4. 单内核和微内核对比</h3><h3 id="11-2-5-鸿蒙操作系统的软件架构"><a href="#11-2-5-鸿蒙操作系统的软件架构" class="headerlink" title="11.2.5. 鸿蒙操作系统的软件架构"></a>11.2.5. 鸿蒙操作系统的软件架构</h3><h2 id="11-3-操作系统实现的层次结构"><a href="#11-3-操作系统实现的层次结构" class="headerlink" title="11.3. 操作系统实现的层次结构"></a>11.3. 操作系统实现的层次结构</h2><h3 id="11-3-1-操作系统实现的第一种层次结构"><a href="#11-3-1-操作系统实现的第一种层次结构" class="headerlink" title="11.3.1. 操作系统实现的第一种层次结构"></a>11.3.1. 操作系统实现的第一种层次结构</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/8.png"></p><ol><li>现在文件系统也会划归到内核中</li></ol><h3 id="11-3-2-操作系统实现的第二种层次结构"><a href="#11-3-2-操作系统实现的第二种层次结构" class="headerlink" title="11.3.2. 操作系统实现的第二种层次结构"></a>11.3.2. 操作系统实现的第二种层次结构</h3><p><img src="/2023/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lec1/9.png"></p><ol><li>过程机制、指令解译、电路执行是由硬件完成，实现中断等机制。</li><li>当前操作系统除了硬件电路以外都是由操作系统管理</li></ol><h1 id="12-补充"><a href="#12-补充" class="headerlink" title="12. 补充"></a>12. 补充</h1><ol><li>$i++$ 返回成机器指令:<ol><li>$i -&gt; R_0$</li><li>$R_0 + 1 -&gt; R_0$</li><li>$R_0 -&gt; i$</li></ol></li></ol><h1 id="13-操作系统运行模型"><a href="#13-操作系统运行模型" class="headerlink" title="13. 操作系统运行模型"></a>13. 操作系统运行模型</h1><p>P42-44</p><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01-软件工程基础</title>
    <link href="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/"/>
    <url>/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/</url>
    
    <content type="html"><![CDATA[<h2 id="01-软件工程基础"><a href="#01-软件工程基础" class="headerlink" title="01-软件工程基础"></a>01-软件工程基础</h2><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/01.png"></p><h1 id="1-Software-软件"><a href="#1-Software-软件" class="headerlink" title="1. Software 软件"></a>1. Software 软件</h1><ol><li>信息可以记录、交流和存储</li><li>信息 -&gt; 计算 -&gt; 数字计算机 -&gt; 软件</li></ol><h2 id="1-1-数字计算历史"><a href="#1-1-数字计算历史" class="headerlink" title="1.1. 数字计算历史"></a>1.1. 数字计算历史</h2><h3 id="1-1-1-Foundation-of-Digital-Computing-30s"><a href="#1-1-1-Foundation-of-Digital-Computing-30s" class="headerlink" title="1.1.1. Foundation of Digital Computing - 30s"></a>1.1.1. Foundation of Digital Computing - 30s</h3><ol><li>硬件:微分计算器、继电器式计算机、ABC原型计算、Harvard Mark 1 IBM实验室</li><li>Theory 理论<ol><li>《论可计算数及其在判定问题上的应⽤》-Alan Turing</li><li>电⼦继电器可以实现布尔符号逻辑  Claude Elwood Shannon</li></ol></li></ol><h3 id="1-1-2-Digital-Computers-40s"><a href="#1-1-2-Digital-Computers-40s" class="headerlink" title="1.1.2. Digital Computers - 40s"></a>1.1.2. Digital Computers - 40s</h3><ol><li>ENIAC:第一台计算机</li><li>Programming the ENIAC</li><li>Programming chart</li><li>编程的步骤<ol><li>将问题映射到机器上的任务很复杂，通常需要几个星期。</li><li>程序在纸上完成后，通过操纵开关和电缆将程序”导入”ENIAC的过程需要额外的几天时间。</li><li>随后是一段时间的验证和调试，借助于机器的”单步”能力。</li></ol></li><li>EDVAC：(了解)<ol><li>EDVAC(Electronic Discrete Variable Automatic Computer)是最早的电子计算机之一。与它的前身ENIAC不同，ENIAC是二进制的，而不是十进制的，它是一台存储程序计算机。</li><li>埃克特、莫奇利和其他ENIAC设计师与约翰·冯·诺依曼一起担任顾问职务；冯·诺依曼在1945年EDVAC报告初稿中总结和讨论了逻辑设计发展。埃克特、莫奇利和其他ENIAC设计师与约翰·冯·诺依曼一起担任顾问职务；冯·诺依曼在1945年EDVAC报告初稿中总结和讨论了逻辑设计发展。</li></ol></li></ol><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/1.png"></p><h3 id="1-1-3-Software-is-one-part-of-Hardware-50s"><a href="#1-1-3-Software-is-one-part-of-Hardware-50s" class="headerlink" title="1.1.3. Software is one part of Hardware -50s"></a>1.1.3. Software is one part of Hardware -50s</h3><ol><li>商业大型机：Ferranti Mark I、UNIVAC I、LEO I、IBM 701、IBM 650</li><li>编程语言，1955 FORTRAN，1958 LISP，1959 COBAL</li><li>命名：John W. Tukey在1958年发表在《美国数学月刊》上的一篇文章中，成为第一个定义运行电子计算器的程序的人。</li></ol><h3 id="1-1-4-Software-is-not-Hardware-60s"><a href="#1-1-4-Software-is-not-Hardware-60s" class="headerlink" title="1.1.4. Software is not Hardware - 60s"></a>1.1.4. Software is not Hardware - 60s</h3><ol><li>变革、ASCII美国信息交换标准码出现、ATM、IBM信息管理系统IMS应⽤于阿波罗航天器、软件咨询业务、IBM S&#x2F;360、信⽤卡、DEC PDP-1⼩型机</li><li>软件的特性<ol><li>软件与现实世界关系更加密切，对需求的规格化更加困难</li><li>软件⽐硬件容易修改的多，并且不需要昂贵的⽣产线复制产品</li><li>软件没有损耗</li><li>软件不可见</li></ol></li></ol><h3 id="1-1-5-Program-x3D-Algorithm-Data-Structure-70s-80s"><a href="#1-1-5-Program-x3D-Algorithm-Data-Structure-70s-80s" class="headerlink" title="1.1.5. Program &#x3D; Algorithm + Data Structure - 70s ~ 80s"></a>1.1.5. Program &#x3D; Algorithm + Data Structure - 70s ~ 80s</h3><ol><li>Algorithms + Data Structures &#x3D; Programs是Niklaus Wirth在1976年写的一本书，涵盖了计算机编程的一些基本主题，特别是算法和数据结构之间的内在联系。</li><li>For example, if one has a sorted list one will use a search algorithm optimal for sorted lists. 例如，如果一个人有一个已排序的列表，他将使用一个对已排序列表最合适的搜索算法。</li></ol><h3 id="1-1-6-Software-Development-is-much-more-complicated-than-Programming-90s-now"><a href="#1-1-6-Software-Development-is-much-more-complicated-than-Programming-90s-now" class="headerlink" title="1.1.6. Software Development is much more complicated than Programming  - 90s ~ now"></a>1.1.6. Software Development is much more complicated than Programming  - 90s ~ now</h3><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/2.png"><br><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/3.png"></p><ol><li>软件类别<ul><li>系统软件:操作系统、数据库、数据仓库、嵌⼊式设备、安全</li><li>编程软件IDE、测试、持续集成、建模、度量</li><li>应用软件:商业、政府、休闲、医疗、教育、国防、 个⼈、专业、科学</li></ul></li><li>应用软件基于现实又高于现实<ul><li>应用软件被开发的目的和意图来源于现实世界的问题。</li><li>应用软件必须基于现实才能解决问题。</li><li>软件最终要被用于现实并改进现实。</li></ul></li></ol><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/4.png"></p><ol start="3"><li>如上图，所以我们可以形成进一步的迭代。</li></ol><h2 id="1-2-什么是软件工程总结"><a href="#1-2-什么是软件工程总结" class="headerlink" title="1.2. 什么是软件工程总结"></a>1.2. 什么是软件工程总结</h2><ol><li>软件独立于硬件</li><li>软件是工具</li><li>软件 &#x3D; 程序 + 文档 + 数据 + 知识</li><li>软件的发展比编码更加复杂</li><li>应用软件源于现实，但是高于现实(课本P4)</li></ol><h1 id="2-工程"><a href="#2-工程" class="headerlink" title="2. 工程"></a>2. 工程</h1><ol><li>美国工程师专业发展委员会(ECPD，ABET的前身)将”工程”定义为：创造性地应用科学原理，设计或开发结构、机器、仪器或制造工艺，或单独或组合使用它们的工程；或在充分了解它们的设计的情况下建造或操作它们；或在特定操作条件下预测它们的行为；就预期功能、运行的经济性或生命财产安全而言</li><li>CCSE - About Engineer 关于工程师<ol><li>工程师通过⼀系列的<strong>讨论决策</strong>，仔细评估项⽬的可选活动，并在每个决策点选择⼀种在当前环境中适合工当前任务的⽅法进⾏工作。可以通过对成本和收益进⾏折衷分析调整相应策略。</li><li>工程师需要对某些对象进⾏度量，有时需要定量的工作；他们要校准和确认度量⽅法，并根据经验和实验数据进⾏估算。</li><li>软件工程师强调<strong>项目设计过程的纪律性</strong>，这是团队⾼效工作的条件。</li><li>工程师可胜任研究、开发、设计、⽣产、测试、构造、操作、管理，以及销售、咨询和培训等<strong>多种角色</strong>。</li><li>工程师们需要在某些过程中使⽤工具，选择和使用合适的工具是工程的关键要素。</li><li>工程师们通过专业协会发展和确认原理、标准和最佳实践⽅法，并提⾼个⼈能⼒。</li><li>工程师们能够重用设计和设计制品。</li></ol></li><li>工程师的决策往往进行折中，选择最优解。</li></ol><h2 id="2-1-工程学科的发展"><a href="#2-1-工程学科的发展" class="headerlink" title="2.1. 工程学科的发展"></a>2.1. 工程学科的发展</h2><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/5.png"></p><h2 id="2-2-工程要素"><a href="#2-2-工程要素" class="headerlink" title="2.2. 工程要素"></a>2.2. 工程要素</h2><ol><li>问题:动力</li><li>科学知识:工具</li><li>解决方法&#x2F;机器:物体</li><li>成本效益&#x2F;条件</li></ol><h1 id="3-软件工程"><a href="#3-软件工程" class="headerlink" title="3. 软件工程"></a>3. 软件工程</h1><h2 id="3-1-什么是软件工程？-重要，需要背下来"><a href="#3-1-什么是软件工程？-重要，需要背下来" class="headerlink" title="3.1. 什么是软件工程？(重要，需要背下来)"></a>3.1. 什么是软件工程？(重要，需要背下来)</h2><ol><li>应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</li><li>对1)中各种方法的研究。</li></ol><h2 id="3-2-软件的工程的特点"><a href="#3-2-软件的工程的特点" class="headerlink" title="3.2. 软件的工程的特点"></a>3.2. 软件的工程的特点</h2><ol><li>具有解决实际问题的动机：工程学解决实际问题，⽽这些问题来源于工程领域之外的⼈：消费者。</li><li>应⽤科学知识指导工程活动：工程学不依赖于个⼈的技能，⽽是强调以科学知识为指导，按照特定⽅法与技术，进⾏规律性的设计、分析等活动，实现工程活动的可学习性和可重复性。</li><li>以成本效益⽐有效为基本条件：工程学不单单只是解决问题，它要有效利⽤所有资源，⾄少成本要低于效益，即成本效益⽐有效。</li><li>构建机器或事物：工程学强调构建实物⼯具，例如机器、事物等，并利⽤实物⼯具来解决问题。</li><li><strong>以服务人类为最终目的</strong>：工程学考虑的不是单个客户的需要，⽽是要运⽤技术和经验实现全社会的进步。</li></ol><h3 id="3-2-1-软件工程师面临的问题"><a href="#3-2-1-软件工程师面临的问题" class="headerlink" title="3.2.1. 软件工程师面临的问题"></a>3.2.1. 软件工程师面临的问题</h3><ol><li>现实世界是复杂的：如果现实世界的状况与我们的期望不符，这就产生了问题。</li><li>很广阔的范围：所有人类所涉及的领域、在其他工程领域，问题是有限的</li><li>大多数是不明确的，需要我们去发现：在其他工程领域，问题是确定和明确的</li><li>工程思维：客观的，知道你想要什么</li></ol><h3 id="3-2-2-科学知识"><a href="#3-2-2-科学知识" class="headerlink" title="3.2.2. 科学知识"></a>3.2.2. 科学知识</h3><ol><li>以计算科学为科学基础，基于科学和逻辑作为标准工具</li><li>很多领域都是被对称的创造出来的，依据方法&#x2F;方法论&#x2F;技术，使用语言、工具，进行研究</li></ol><h3 id="3-2-3-工程-x3D-科学-原则-艺术"><a href="#3-2-3-工程-x3D-科学-原则-艺术" class="headerlink" title="3.2.3. 工程 &#x3D; 科学 + 原则 + 艺术"></a>3.2.3. 工程 &#x3D; 科学 + 原则 + 艺术</h3><ol><li>科学:计算科学知识是软件工程的基础</li><li>原则:实践知识也应该被广泛的分享</li><li>艺术：创造力:分析，设计</li></ol><h3 id="3-2-4-问题-x2F-机器和产品"><a href="#3-2-4-问题-x2F-机器和产品" class="headerlink" title="3.2.4. 问题&#x2F;机器和产品"></a>3.2.4. 问题&#x2F;机器和产品</h3><ol><li>虚拟机 &#x3D; 通用机 + 特定的解决方案</li><li>解决方案可以在编程语言的帮助下映射到通用计算机上</li><li>并不像其他工程一样，不同问题有不同机器</li><li>解决方案的发展是软件工程首要的任务</li><li>将解决方案映射到通用机上是软件工程的次要任务</li></ol><h3 id="3-2-5-成本效益"><a href="#3-2-5-成本效益" class="headerlink" title="3.2.5. 成本效益"></a>3.2.5. 成本效益</h3><ol><li>可行性研究<ul><li>利益取决于用户</li><li>成本取决于软件工程师</li></ul></li><li>到达目的地的方法总是很多的，软件工程师应该选择最具成本效益的方法(而不是最先进的方法)</li><li>当成本和效益的关系不再重要的时候，软件工程师将会消失<ul><li>成本低：小规模编程</li><li>收益不明确：勘探研究</li><li>不计成本：计算科学研究</li><li>工程思想：成本和收益相平衡</li><li>控制和管理</li></ul></li></ol><h3 id="3-2-6-Understanding-of-Software-Engineering-软件工程的理解"><a href="#3-2-6-Understanding-of-Software-Engineering-软件工程的理解" class="headerlink" title="3.2.6. Understanding of Software Engineering 软件工程的理解"></a>3.2.6. Understanding of Software Engineering 软件工程的理解</h3><ol><li>软件工程是⼀种工程活动</li><li>软件工程的动机是解决实际问题</li><li>软件工程是科学性、实践性和⼯艺性并重的</li><li>软件工程追求⾜够好，不是最好</li><li>软件工程真正的产品是基于虚拟计算机的软件⽅案</li><li>软件工程的最终⽬的是要<strong>促进整个社会的进步</strong></li></ol><h1 id="4-知识域"><a href="#4-知识域" class="headerlink" title="4. 知识域"></a>4. 知识域</h1><h2 id="4-1-SWEBOK"><a href="#4-1-SWEBOK" class="headerlink" title="4.1. SWEBOK"></a>4.1. SWEBOK</h2><ol><li>软件工程知识体系(SWEBOK)是由IEEE计算机协会赞助的软件工程协调委员会的产品</li></ol><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/6.png"><br><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/7.png"><br><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/8.png"></p><h2 id="4-2-软件开发活动"><a href="#4-2-软件开发活动" class="headerlink" title="4.2. 软件开发活动"></a>4.2. 软件开发活动</h2><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/9.png"></p><h2 id="4-3-软件发展活动"><a href="#4-3-软件发展活动" class="headerlink" title="4.3. 软件发展活动"></a>4.3. 软件发展活动</h2><p><img src="/2023/03/28/%E8%BD%AF%E5%B7%A5%E2%85%A1-lec1/10.png"></p><h2 id="4-4-角色分工"><a href="#4-4-角色分工" class="headerlink" title="4.4. 角色分工"></a>4.4. 角色分工</h2><ol><li>需求工程师，⼜被称为需求分析师：承担需求开发任务。软件产品的需求开发⼯作通常由多个需求工程师来完成，他们共同组成⼀个需 求工程师⼩组，在⾸席需求工程师的领导下开展⼯作。通常⼀个团队只有⼀个需求工程师⼩组。</li><li>软件体系结构师：承担软件体系结构设计任务。通常也是由多⼈组成⼀个⼩组，并在⾸席软件体系结构师的领导下开 展⼯作。通常⼀个团队只有⼀个软件体系结构师⼩组。</li><li>软件设计师：承担详细设计任务。在软件体系结构设计完成之后，可以将其部件分配给不同的开发⼩组。开发⼩ 组中负责所分配部件详细设计⼯作的⼈员就是软件设计师。⼀个团队可能有⼀个或多个开发⼩组。 ⼀个⼩组可能有⼀个或多个软件设计师。</li><li>程序员：承担软件构造任务。程序员与软件设计师通常是同⼀批⼈，也是根据其所分配到的任务开展⼯作。</li><li>⼈机交互设计师：承担⼈机交互设计任务。⼈机交互设计师与软件设计师可以是同⼀批⼈，也可以是不同⼈员。在有 多个⼩组的软件工程团队中，可以有⼀个单独的⼈机交互设计师⼩组，也可以将⼈机交互设计师分 配到各个⼩组。</li><li>软件测试⼈员：承担软件测试任务。软件测试⼈员通常需要独⽴于其他的开发⼈员⻆⾊。⼀个团队可能有⼀个或多个测试⼩组。⼀个⼩组可能有⼀个或多个软件测试⼈员。</li><li>项⽬管理⼈员：负责计划、组织、领导、协调和控制软件开发的各项⼯作。相⽐于传统意义上的管理者，他们不完全是监控者和控制者，更多得是协调者。通常⼀个 团队只有⼀个项⽬管理⼈员。</li><li>软件配置管理⼈员：管理软件开发中产⽣的各种制品，具体⼯作是对重要制品进⾏标识、变更控制、状态报告等。通常⼀个团队只有⼀个软件配置管理⼈员。</li><li>质量保障⼈员：在⽣产过程中监督和控制软件产品质量的⼈员。通常⼀个团队有⼀个质量保障⼩组，由⼀个或多个⼈员组成。</li><li>培训和⽀持⼈员：负责软件移交与维护任务。他们可以是其他开发⼈员的⼀部分，也可以是独⽴的⼈员。</li><li>⽂档编写⼈员：专⻔负责写作软件开发各种⽂档的⼈员。他们的存在是为了充分利⽤部分宝贵的⼈⼒资源(例如需求工程师和软件体系结构师)，让这些⼈⼒资源从繁杂的⽂档化⼯作中解放出来。</li></ol><p>本文主要内容来自 <a href="https://spricoder.github.io/">SpriCoder的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>2023Spring-软工Ⅱ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
